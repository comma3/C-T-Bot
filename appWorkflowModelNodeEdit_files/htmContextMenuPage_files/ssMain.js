

/**
 * Constructor
 */
function CTIUtility() {
	this.phoneEvent						= CTIUtility_phoneEvent;
	this.beginCall						= CTIUtility_beginCall;
	this.endCall						= CTIUtility_endCall;
	this.startTime						= 0;
	this.callDuration					= 0;
	this.callRunning					= CTIUtility_callRunning;
	this.launchCTICallManager			= CTIUtility_launchCTICallManager;
	this.launchCTIApp					= CTIUtility_launchCTIApp;
	this.setupFormForCommunicationType	= CTIUtility_setupFormForCommunicationType;
	this.createFixedNumber				= CTIUtility_createFixedNumber;
	this.callState						= null;
	this.callDirection					= null;
	this.telNo							= null;
	this.callID							= null;
	this.getCTIContextMenuOptionsForType = CTIUtility_getCTIContextMenuOptionsForType;
	this.getActualCTITypeByContextType	= CTIUtility_getActualCTITypeByContextType;
}

/**
 * Process the phone event.
 * Called from VBScript function CTIPhone_PhoneEvent.
 * @param objPhone embedded phone object
 * @param vars All information for the call (Oak format)
 */
function CTIUtility_phoneEvent(objPhone, vars) {
//pdebug("CTIUtility_phoneEvent: State: " + objPhone.packetGetVar(vars, "State"));
//pdebug("CTIUtility_phoneEvent: Cause: " + objPhone.packetGetVar(vars, "Cause"));
//pdebug("CTIUtility_phoneEvent: Cmd: " + objPhone.packetGetVar(vars, "Cmd"));
//pdebug("CTIUtility_phoneEvent: CalId: " + objPhone.packetGetVar(vars, "CallId"));
//pdebug("CTIUtility_phoneEvent: Caller: " + objPhone.packetGetVar(vars, "Caller"));
//pdebug("CTIUtility_phoneEvent: Called: " + objPhone.packetGetVar(vars, "Called"));
//pdebug("CTIUtility_phoneEvent: " + vars);
//pdebug("CTIUtility_phoneEvent: CTIpopup: " + frmMenuOptions.getHTMLFieldByRef("CTIpopup").checked);

	if (checkForCallInProgress(objPhone, vars) == true)
		return; // Cannot process this new call as a call is currently in progress

	setCallState(objPhone, vars);
//pdebug("CTIUtility_phoneEvent: callState: " + objCTI.callState + ", callDirection: " + objCTI.callDirection);
	if (objCTI.callDirection == CTI_CALLDIRECTION_INBOUNDEXTERNAL &&
		objCTI.callState == CTI_CALLSTATUS_RINGING &&
		(frmMenuOptions.getHTMLFieldByRef("CTIpopup").checked == true)) {
		processInbound(objCTI.telNo);
	}
}

/**
 * Check to see if we already have a call in progress
 * @param objPhone embedded phone object
 * @param vars All information for the call (Oak format)
 */
function checkForCallInProgress(objPhone, vars) {
//pdebug("CTIUtility: checkForCallInProgress: callID: " + objCTI.callID + ", vars callID: " + objPhone.packetGetVar(vars, "CallId"));
	if ((objCTI.callID == objPhone.packetGetVar(vars, "CallId")) ||
		objCTI.callID == null) {
		// its an event for the current call so process ('null' indicates a new call)
		return false;
	}

	return true;
}

/**
 * Make a call
 * @param telNo The number to call
 */
function CTIUtility_beginCall(telNo) {
	objCTI.callDirection = CTI_CALLDIRECTION_OUTBOUND;
	objCTI.callState = CTI_CALLSTATUS_RINGING;
	objCTI.telNo = telNo;
	document.getElementById("CTIPhone").Dial(telNo);
}

/**
 * End the call
 */
function CTIUtility_endCall() {
	document.getElementById("CTIPhone").Hangup();
}

/**
 * Process the current state of the call
 * @param objPhone embedded phone object
 * @param vars All information for the call (Oak format)
 */
function setCallState(objPhone, vars) {
	var state = objPhone.packetGetVar(vars, "State");
	var cause = objPhone.packetGetVar(vars, "Cause");
	var cmd = objPhone.packetGetVar(vars, "Cmd");
//pdebug("CTIUtility: setCallState: IN: callState: " + objCTI.callState);
//pdebug("CTIUtility: setCallState: state: " + state + ", cause: " + cause + ", cmd: " + cmd + ", callID: " + objPhone.packetGetVar(vars, "Cause"));

	objCTI.callID = objPhone.packetGetVar(vars, "CallId");
	
	if (cause == "NewCall" && state == "Connected") {
		objCTI.callState = CTI_CALLSTATUS_RINGING;
		objCTI.callDirection = CTI_CALLDIRECTION_OUTBOUND;
	}
	else if (cause == "NewCall" && state == "Ringing") {
		objCTI.callState = CTI_CALLSTATUS_RINGING;
		
		var callerVars = objPhone.packetGetVar(vars, "Caller");

		if (objPhone.packetGetVar(callerVars, "External") == 1) {
			objCTI.callDirection = CTI_CALLDIRECTION_INBOUNDEXTERNAL;
			objCTI.telNo = objPhone.packetGetVar(callerVars, "Tel");
		}
		else
			objCTI.callDirection = CTI_CALLDIRECTION_INBOUNDINTERNAL;
	}
	else if (cause == "Answered" && state == "Connected") {
		var objEfacsCalendar = objApplication.getCalendarParser();
		objCTI.startTime = objEfacsCalendar.getDateTimeInMilliseconds();
		
		objCTI.callState = CTI_CALLSTATUS_ANSWERED;
	}
	else if (cmd == "DeleteCall") {
		objCTI.callDuration = CTIUtility_callRunning();
//pdebug("CTIUtility: setCallState: CTI_CALLSTATUS_END: duration: " + objCTI.callDuration);
		objCTI.callState = CTI_CALLSTATUS_END;
		objCTI.callID = null;
		objCTI.startTime = 0;
	}
//pdebug("CTIUtility: setCallState: OUT: callState: " + objCTI.callState + ", callDirection: " + objCTI.callDirection);
}

/**
 * Calculate the active call time
 * @return String Time format string
 */
function CTIUtility_callRunning() {
	var objEfacsCalendar = objApplication.getCalendarParser();

	if (objCTI.startTime == 0)
		return "00:00:00";
		
	var diff = (objCTI.startTime - objEfacsCalendar.getDateTimeInMilliseconds()) * -1;

	var iHours = parseInt(diff/3600000);
	var iMins = parseInt((diff/60000)%60);
	var iSecs = parseInt((diff/1000)%60);

	var sHours = (iHours < 10 ? "0" : "") + iHours;
	var sMins = (iMins < 10 ? "0" : "") + iMins;
	var sSecs = (iSecs < 10 ? "0" : "") + iSecs;

	return sHours + ":" + sMins + ":" + sSecs;
}

/**
 * Sets up the form dependent on the communication method
 * @param entryMode - Either "Customer|Engineer|Prospective|Site|Supplier"
 * @param objForm - Form reference
 */
function CTIUtility_setupFormForCommunicationType(entryMode, objForm) {
	var strCTIType = objForm.getFieldByRef ("type").getValue()
	var isMobile = objForm.getFieldByRef ("ismobile").getValue()
	
	if (strCTIType == "Telephone" || strCTIType == "Fax") {
		if (isMobile == 0) {
			objForm.getFieldByRef ("destination").hide();
			
			objForm.getFieldByRef ("fixednumber").disable();
			
			objForm.getFieldByRef ("countrycode").enable();
			objForm.getFieldByRef ("areacode").enable();
			objForm.getFieldByRef ("localnumber").enable();
			objForm.getFieldByRef ("extension").enable();
			
			objForm.getFieldByRef ("countrycode").show();
			objForm.getFieldByRef ("areacode").show();
			objForm.getFieldByRef ("localnumber").show();
			objForm.getFieldByRef ("extension").show();
			objForm.getFieldByRef ("fixednumber").show();
			
			objForm.getFieldByRef ("localnumber").setRequiredField(true);
		}
		else { // Mobile
			objForm.getFieldByRef ("destination").hide();
			objForm.getFieldByRef ("areacode").hide();
			objForm.getFieldByRef ("localnumber").hide();
			objForm.getFieldByRef ("extension").hide();
			
			objForm.getFieldByRef ("countrycode").enable();
			objForm.getFieldByRef ("fixednumber").enable();
			
			objForm.getFieldByRef ("countrycode").show();
			objForm.getFieldByRef ("fixednumber").show();
			
			objForm.getFieldByRef ("fixednumber").setRequiredField(true);
		}
	}
	else if (strCTIType == "Email" || strCTIType == "Postal") {
		objForm.getFieldByRef ("countrycode").hide();
		objForm.getFieldByRef ("areacode").hide();
		objForm.getFieldByRef ("localnumber").hide();
		objForm.getFieldByRef ("extension").hide();
		objForm.getFieldByRef ("fixednumber").hide();
		
		objForm.getFieldByRef ("destination").enable();
		
		objForm.getFieldByRef ("destination").show();
		
		objForm.getFieldByRef ("destination").setRequiredField(true);
	}
	else { // New record
		// Disable all fields until we know the communication method being created
		objForm.getFieldByRef ("destination").hide();
		objForm.getFieldByRef ("countrycode").hide();
		objForm.getFieldByRef ("areacode").hide()
		objForm.getFieldByRef ("localnumber").hide();
		objForm.getFieldByRef ("extension").hide();
		objForm.getFieldByRef ("fixednumber").hide();
	}
	
	objForm.getFieldByRef("fixednumber").setCTIVisibility();
}

/**
 * Construct the fixed number that will be used through CTI
 * entryMode "Customer|Engineer|Prospective|Site|Supplier"
 * @param objForm Form reference
 * @param objField Field reference
 */
function CTIUtility_createFixedNumber(entryMode, objForm, objField) {
	if (objField.isInvalid == true)
		return;
	
	var strCTIType = objForm.getFieldByRef ("type").getValue()
	var isMobile = objForm.getFieldByRef ("ismobile").getValue()
	
	if (strCTIType == "Telephone" || strCTIType == "Fax") {
		// remove any white space
		objField.setValue(util_removeWhiteSpace(objField.getValue()));
		
		// make sure only numerics
		if ((isInteger(objField.getValue()) == false) && (isEmpty(objField.getValue()) == false)) {
			objField.setInvalid();
			objForm.objWindow.objStatusBar.error("Only numeric values allowed");
			return;
		}
		
		if (isMobile == 0) {
			objForm.getFieldByRef("fixednumber").setValue(objForm.getFieldByRef("areacode").getValue() + objForm.getFieldByRef("localnumber").getValue());
		}
	}
	else if (strCTIType == "Email" || strCTIType == "Postal") {
		// ?
	}
}

/**
 *
 */
function CTIUtility_getCTIContextMenuOptionsForType(traderID, contactID, CTIType) {
	if (CTIType == "CUSTOMER" || CTIType == "SUPPLIER")
		return getTraderContacts(traderID, CTIType);
	else // "CUSTOMERCONTACT|SUPPLIERCONTACT|SITECONTACT"
		return getContactTelephoneNumbers(traderID, contactID, CTIType);
}

/**
 * Get the contacts for the trader
 * @param traderID Trader ID
 * @param CTIType Mode
 * @return Array 
 */
function getTraderContacts(traderID, CTIType) {
	var arrValues = new Array();
	var beanName;
	
	if (CTIType == "CUSTOMER")
		beanName = "CustomerContact";
	else if (CTIType == "SUPPLIER")
		beanName = "SupplierContact";

	var objRPC = new RPCObject(beanName);
	var strXML = objRPC.execute("loadContactsForCTI", objApplication.Connection.strConnectionString, traderID);
	
	if (! objRPC.isEmpty()) {
		var objXML = objApplication.createXMLDocument();
		objXML.loadXML(strXML);
		
		var objNodes = objXML.selectNodes("/contacts/contact");
		
		for (var x = 0; x < objNodes.length(); x++) {
			arrValues[x] = new Array(objNodes.item(x).getText(), "");
		}
	}
	
	return arrValues;
}

/**
 * Get the contacts callable numbers
 * @param traderID Trader ID
 * @param contactID Contact ID
 * @param CTIType Mode
 * @return Array 
 */
function getContactTelephoneNumbers(traderID, contactID, CTIType) {
	var arrValues = new Array();
	var beanName;
	var methodName;
	var XPath;
	
	if (CTIType == "CUSTOMERCONTACT") {
		beanName = "CustomerContactCommunication";
		methodName = "loadAllByCustomerContact";
		XPath = "customercontactcommunication";
	}
	else if (CTIType == "SUPPLIERCONTACT") {
		beanName = "SupplierContactCommunication";
		methodName = "loadAllBySupplierContact";
		XPath = "suppliercontactcommunication";
	}
	else if (CTIType == "SITECONTACT") {
		beanName = "SiteContactCommunication";
		methodName = "loadAllBySiteContact";
		XPath = "sitecontactcommunication";
	}

	var objRPC = new RPCObject(beanName);
	var strXML = objRPC.execute(methodName, objApplication.Connection.strConnectionString, traderID, contactID);
	
	if (! objRPC.isEmpty()) {
		var objXML = objApplication.createXMLDocument();
		objXML.loadXML(strXML);
		
		var x = 0;
		var objNodes = objXML.selectNodes("/" + XPath + "s/" + XPath);
		for (var objNode = objNodes.nextNode(); objNode != null; objNode = objNodes.nextNode()) {
			var type = objNode.selectSingleNode("type/value").getText();
			if (type != "Telephone")
				continue;

			arrValues[x++] = new Array(objNode.selectSingleNode("fixednumber/value").getText(), objNode.selectSingleNode("communicationmethodid/value").getText());
		}
	}
	
	return arrValues;
}

/**
 * Launch the call manager app
 * @param args Array of arguments
 */
function CTIUtility_launchCTICallManager(args) {
	if (objCTI.callState == CTI_CALLSTATUS_ANSWERED)
			return eMsgBox(fl("CTICALLACTIVE"), 0, msg_Critical, window);
				
	var strNumber = args[0];
	var strTraderID = args[1];
	var strTraderType = args[2];
	var strContactID = b64Decode(args[3]);
	var strMode = typeof(args[4]) == "undefined" ? "" : args[4];
	
	var strKeyValues = "traderid=" + replaceForURL(b64Encode(strTraderID));
	strKeyValues += "&tradertype=" + replaceForURL(b64Encode(strTraderType));
	strKeyValues += "&contactid=" + replaceForURL(b64Encode(strContactID));
	//strKeyValues += "&type=" + ???;
	strKeyValues += "&fixednumber=" + replaceForURL(b64Encode(strNumber));
	strKeyValues += "&mode=" + strMode;
	var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Applications_HTML/appCallMan.html?" + strKeyValues;
	if (! isBlank(objApplication.appID))	{
		strURL += "&appid=" + objApplication.appID;
		strURL += "&menuid=" + objApplication.menuID;
	}

	objApplication.openChildWindow(window, strURL, "appCallMan");
}

/**
 * Incomming call
 * @param telno Telephone number
 */
function processInbound(telno) {
//pdebug("CTIUtility: processInbound: telno: " + telno);
	var objRPC = new RPCObject("ContactCommunication");
	objRPC.execute("loadAllByTelephone", objApplication.Connection.strConnectionString, telno);
	if (objRPC.isEmpty())
		return; // No trader found with this contact number
		
	var objContactXML = objRPC.getReturnedXMLDom();

	var traderID = objContactXML.selectSingleNode("/contactcommunications/contactcommunication/traderid/value").getText();
	var traderType = objContactXML.selectSingleNode("/contactcommunications/contactcommunication/tradertype/value").getText();
	var contactID = objContactXML.selectSingleNode("/contactcommunications/contactcommunication/contactid/value").getText();

	var arr = new Array();
	arr[0] = telno;
	arr[1] = traderID;
	arr[2] = traderType;
	arr[3] = b64Encode(contactID);
	arr[4] = "INBOUND";
		
	CTIUtility_launchCTICallManager(arr);
}

/**
 * Launch the relevant EFACS application for CTI call
 */
function CTIUtility_launchCTIApp(app, appTitle, traderID) {
	objApplication.openChildWindow(window, app + "?apptitle=" + appTitle + "&CTIArg0=" + traderID);
}

/**
 * Need to get the actual trader type (CTIType) for generic types of TRADER and CONTACT
 * @param type "TRADER|CONTACT"
 * @param obj Trader type
 * @return String CTI type
 */
function CTIUtility_getActualCTITypeByContextType(type, source, contextObjectField) {
	var CTIType = "";
	var tradertype;
	var errFlag = 0;

	if (type == "TRADER") {
		if (source == "FORM") {
			var objField = contextObjectField.objForm.getFieldByRef("tradertype");
			if (objField != null) {
				tradertype = objField.getValue();
			}
			else {
				errFlag = 1;
			}
		}
		else { // GRID
			var objField = contextObjectField.getSelectedColumnValue("tradertype");
			if (objField != null) {
				tradertype = objField[0];
			}
			else {
				errFlag = 2;
			}
		}
	}
	else { // CONTACT
		if (source == "FORM") {
			var objField = contextObjectField.objForm.getFieldByRef("tradertype");
			if (objField != null) {
				tradertype = objField.getValue();
			}
			else {
				errFlag = 1;
			}
		}
		else {
			var objField = contextObjectField.getSelectedColumnValue("tradertype");
			if (objField != null) {
				tradertype = objField[0];
			}
			else {
				errFlag = 2;
			}
		}
	}
	
	if (errFlag == 1) {
		eMsgBox(fl("CTITRADERTYPENOTDEFINEDONFORM"), 0, msg_Critical, window);
		return null;
	}
	else if (errFlag == 2) {
		eMsgBox(fl("CTITRADERTYPENOTDEFINEDONGRID"), 0, msg_Critical, window);
		return null;
	}
	else if (isBlank(tradertype)) {
		eMsgBox(fl("CTITRADERTYPENOTSET"), 0, msg_Critical, window);
		return null;
	}
	
	if (type == "TRADER") {
		switch (tradertype) {
			case "Customer":
			case "C":
				CTIType = "CUSTOMER";
			break;
			
			case "Supplier":
			case "S":
				CTIType = "SUPPLIER";
			break;
			
			case "HQ":
				CTIType = "SITE";
			break;
		}
	}
	else {
		switch (tradertype) {
			case "Customer":
			case "C":
				CTIType = "CUSTOMERCONTACT";
			break;
			
			case "Supplier":
			case "S":
				CTIType = "SUPPLIERCONTACT";
			break;
			
			case "HQ":
				CTIType = "SITECONTACT";
			break;
		}
	}
	
	return CTIType;
}



/**
 * Create a new application title object
 */
function ApplicationTitle () {
	this.flgShowCompanyName = "false";
	this.setName = AT_setName;
	this.setCompanyNameRequired = AT_setCompanyNameRequired;
	this.multipleGrids = false; // Whether there are multiple grids on the page
}

/**
 * Sets the title name to be displayed.
 * If the option to show the company name along side the application title is 
 * chosen then this is included too.
 * @param strName The title to be displayed.
 */
function AT_setName(strName) {
	window.document.getElementById("lblAppTitle").innerHTML = strName;
	
	if (this.flgShowCompanyName == "true")
	{
		window.document.getElementById("lblCompanyName").style.fontStyle = "normal";
		window.document.getElementById("lblCompanyName").style.fontSize = "14px";
		window.document.getElementById("lblCompanyName").innerHTML = "&nbsp;-&nbsp;&nbsp;" + objApplication.User.companyName;
	}

	var objGridWrapper = window.document.getElementById("grdDivWrapper");
	var objHeaderDiv = window.document.getElementById("grdDivHeader");
	
	/* If there is a single grid on the page then set the title in the grid header */
	if (!this.multipleGrids && strName != null && strName != "" && strName != "undefined") {
		var objTitleLabel = window.document.getElementById("grdTitleLabel");
		if (objTitleLabel != null) {
			objHeaderDiv.style.display = "inline";
			
			var strDisplayName = strName;
			if (strName.indexOf("Manage ") == 0) {
				strDisplayName = strName.substring(7);
			} else if (strName.indexOf("Query ") == 0) {
				strDisplayName = strName.substring(6);
			} else if (strName.lastIndexOf(" Query") == (strName.length - 6)) {
				strDisplayName = strName.substring(0, strName.length - 6);
			}
			
			objTitleLabel.innerHTML = strDisplayName + objTitleLabel.innerHTML;
			window.document.getElementById("grdTitleSpan").innerHTML = strDisplayName;
		}

		if (objGridWrapper != null) {
			objGridWrapper.className = "GridDivWrapper";
		}
	} else if (objHeaderDiv != null) {
		objHeaderDiv.style.display = "none";
		if (objGridWrapper != null) {
			objGridWrapper.className = "NoGridDivWrapper";
		}
	}
}

/**
 * Confirms whether the company name should be displayed or not.
 * @param flgCompanyNameRequired Whether the company name should be displayed or not.
 */
function AT_setCompanyNameRequired(flgCompanyNameRequired) {
	this.flgShowCompanyName = flgCompanyNameRequired;
}



// Constructor
function Applet(name, code, width, height) 
{
	this.details = objApplication.createXMLDocument();
	this.details.loadURL("../XML/xmlAppletDetails.xml", window.document.URL);

	this.objObjectHTML = objApplication.createXMLDocument();
	this.objObjectHTML.loadXML(this.details.selectSingleNode("//code/object").xml());
	
	this.objEmbedHTML = objApplication.createXMLDocument();
	this.objEmbedHTML.loadXML(this.details.selectSingleNode("//code/embed").xml());

	this.addAttr("id", name);
	this.addAttr("tabindex", "-1");
	this.addAttr("width", width);
	this.addAttr("height", height);

	this.addParam("code", code);
	this.addAttr("code", code, "EMBED");
	
	var javaArguments = "-Djava.net.preferIPv4Stack=true";
	this.addParam("java_arguments", javaArguments);
	this.addAttr("java_arguments", javaArguments, "EMBED");
	
	this.version = "";
	this.path = "";
}

function createApplet(name, code, width, height) 
{
	var applet = new Applet(name, code, width, height);
	
	// Extra params are all archives containing the java classes
	for (var n = 4; n < arguments.length; n++) {
		applet.addArchive(arguments[n]);
	}
	return applet.getHTML();
}

Applet.prototype.addParam = function (name, val) 
{
	var param = this.objObjectHTML.selectSingleNode("param[@name='" + name + "']");
	if (param == null) {
		param = this.objObjectHTML.ownerDocument().createElement("param");
		param.setAttribute("name", name);
		//param.addAttr("OBJECT", "name", name);
		this.objObjectHTML.appendChild(param);
	}

	param.setAttribute("value", val == true ? "true" : val == false ? "false" : val);
}

Applet.prototype.addAttr = function (name, val, tag)
{
	var attrib = this.objEmbedHTML.getAttribute(name);
	if (isBlank(attrib)) {
		if (tag == null) { // add attribute to both object and embed tags
			this.objObjectHTML.setAttribute(name, val);
			// Need to append "NN" to the applet ID and reference this in Netscape, otherwise
			// getElementById would pick up OBJECT and not the EMBED tag.
			this.objEmbedHTML.setAttribute(name, name == "id" || name == "name" ? val + "NN" : val);
		}
		else if (tag == "OBJECT")
			this.objObjectHTML.setAttribute(name, val);
		else
			this.objEmbedHTML.setAttribute(name, name == "id" ? val + "NN" : val);
	}
}

Applet.prototype.addArchive = function (name) {
	var detail = this.details.selectSingleNode("//archives/archive[@id='" + name + "']");

	if (detail == null) {
		this.addJar("../Applets/" + name + ".jar", "1.0.0.0");
	} else {
		this.addJar(detail.selectSingleNode("path").getText(), detail.selectSingleNode("version").getText());
	}
}

Applet.prototype.addJar = function(path, version) {
	if (this.version == "") {
		this.version = version;
		this.path = path;
	} else {
		this.version = this.version + ", " + version;
		this.path = this.path + ", " + path;
	}
}

Applet.prototype.getHTML = function () {
	this.addParam("cache_version", this.version);
	this.addAttr("cache_version", this.version, "EMBED");
	this.addParam("cache_archive", this.path);
	this.addAttr("cache_archive", this.path, "EMBED");
	
	this.objObjectHTML.documentElement().appendChild(this.objEmbedHTML);
	return this.objObjectHTML.xml();
}


	

// ADAPT constants.
var ADAPT_ONAPPLICATIONLOAD = 0x1;
var ADAPT_ONAPPLICATIONUNLOAD = 0x2;
var ADAPT_ONAPPLICATIONLOADRECORD = 0x4;

// This object should only really be created ONCE for each session.  The reference to the first
// only only instance of this object is passed from window to window. (JKH)

/** 
 * Constructor for the Application object
 *
 * @param strDescription The application description.
 * @param strFileName The application file name.
 * @param strAppID The application id.
 * @param objAppWindow The window object.
 */
function Application(strDescription, strFileName, strAppID, objAppWindow) {

	this.browser			= navigator.appName == "Microsoft Internet Explorer" ? APPLICATION_IE : APPLICATION_NN;
	this.objAppWindow		= objAppWindow;
	this.addScript			= Application_addScript;
	this.intScripts			= 0;
	this.Scripts			= new Array();
	this.strRevision		= "";
	this.strLastModified	= "";
	this.hadCriticalError	= false;

	this.description		= strDescription;
	this.fileName			= strFileName;

	if (strAppID == "undefined")
		strAppID = null;
	this.appID				= strAppID;
	this.menuID				= null;
	this.logNumber			= 0;
	this.bMobile			= false;

	this.aboutApplication = Application_aboutApplication;
	this.helpApplication = Application_helpApplication;
	this.closeApplication = Application_closeApplication;
	this.getWindowFileName = Application_getWindowFileName;

	this.Data = new ApplicationData();
	this.Schema = new ApplicationSchema();

	this.Queries = Application_Queries;							// Provides easy access from the array of queries.
	this.arrQueries = new Array();								// Internal array.
	this.addQuery = Application_addQuery;
	this.removeQuery = Application_removeQuery;

	this.Forms = Application_Forms;								// Provides easy access from the array of forms.
	this.arrForms = new Array();								// Internal array.
	this.addForm = Application_addForm;
	this.removeForm = Application_removeForm;

	this.Grids = Application_Grids;								// Provides easy access from the array of grids.x
	this.arrGrids = new Array();								// Internal array.
	this.addGrid = Application_addGrid;
	this.removeGrid = Application_removeGrid;

	this.EditWindowManagers = Application_EditWindowManagers;	// Provides easy access from the array of edit window managers.
	this.arrEditWindowManagers = new Array();					// Internal array.
	this.addEditWindowManager = Application_addEditWindowManager;
	this.removeEditWindowManager = Application_removeEditWindowManager;

	this.Toolbars			= Application_Toolbars;
	this.arrToolbars		= new Array();
	this.removeToolbar		= Application_removeToolbar;

	this.Containers			= Application_Containers;
	this.arrContainers		= new Array();
	this.removeContainer	= Application_removeContainer;

	this.TabbedDialogs		= Application_TabbedDialogs;
	this.arrTabbedDialogs	= new Array();
	this.removeTabbedDialog	= Application_removeTabbedDialog;

	this.ListPickers		= Application_ListPickers;
	this.arrListPickers		= new Array();
	this.removeListPicker	= Application_removeListPicker;

	this.Messages			= Application_Messages;
	this.arrMessages		= new Array();
	this.addMessage			= Application_addMessage;
	this.removeMessage		= Application_removeMessage;

	this.openChildWindow = Application_openChildWindow;			// Generally used if edit window manager not required.
	this.openModalWindow = Application_openModalWindow;			// Enables messages to be displayed using standard Emerald features

	this.EfacsApplet = getEfacsApplet();

	this.dateParser = null;
	this.getDateParser = Application_getDateParser;
	this.CalendarParser = null;
	this.getCalendarParser = Application_getCalendarParser;

	this.getNumberFormatter = Application_getNumberFormatter;
	this.NumberFormatter	= null;
	this.getForeignNumberFormatter = Application_getForeignNumberFormatter;
	this.arrForeignNumberFormatters = new Array();
	
	this.createXMLDocument		= Application_createXMLDocument;
	this.toXML					= Application_toXML;
	this.getFormsToXML			= Application_getFormsToXML;
	this.getToolbarsToXML		= Application_getToolbarsToXML;
	this.getGridsToXML			= Application_getGridsToXML;
	this.getContainersToXML		= Application_getContainersToXML;
	this.getTabbedDialogsToXML	= Application_getTabbedDialogsToXML;
	this.getListPickersToXML	= Application_getListPickersToXML;
	this.performADAPTScript		= Application_performADAPTScript;

	this.Connection = null;
	this.User = null;
	this.PersistentXML = null;
	this.FieldHistory = null;
	
	this.Modules = Application_Modules;
	this.arrModules = new Array();
	this.addModule = Application_addModule;
	this.updateLog = Application_updateLog;

	this.getCookieValue = Application_getCookieValue;
	this.setCookieValue = Application_setCookieValue;
	
	this.dialogHTML = "";
	this.dialogReturnValue = null;
	
	/*
	 * Flag indicating which menu system we are using (Sapphire or Emerald)
	 */
	this.isSapphireMenuLauncher = true;
	
	// Copy the User, Connection and other objects from the parent window - originally setup in appMenu.
	// Assume app running in an IFrame.
	var objApp = window.parent.objApplication;

	// Is this app running in a new window ?
	if (objApp == null && window.opener != null && window.document.URL.indexOf("appMenu.html") == -1)
		var objApp = window.opener.parent.objApplication;
		
	// Is this app launching from htmEmeraldLauncher? 
	if (objApp == null && window.opener != null 
			&& window.opener.document != null 
			&& window.opener.document.URL != null
			&& window.opener.document.URL.indexOf("htmEmeraldLauncher.htm") != -1) {
		objApp = window.opener.objApplication;
	}

	// If objApp is still null then the caller must be login.jsp - creating the initial connection.
	// Do not attempt to copy objects if this is the case.
	if (objApp != null)
	{
		this.User = new User();
		copyObject(objApp.User, this.User);
		
		this.Connection = new Connection();
		copyObject(objApp.Connection, this.Connection);
		
		this.Schema = objApp.Schema;
		this.FieldHistory = objApp.FieldHistory;
		this.PersistentXML = objApp.PersistentXML;
		
		if (objApp.EfacsApplet.BaseHref.indexOf("sapphire/appMenu.html") == -1) {
			this.isSapphireMenuLauncher = false;
		}
	} else {
		if (this.EfacsApplet.BaseHref.indexOf("sapphire/appMenu.html") == -1) {
			this.isSapphireMenuLauncher = false;
		}
	}
	
	// Has the User object been initialised yet - the caller may be login.jsp.
	if (this.User != null)
	{
		try {
			this.User.homeCurrency = this.Data.getSystemParameter("LEHOMECURR").selectSingleNode("spvalue/value").getText();
		} catch (error) {
		}
	}
	
	this.debugSetup			= Application_debugSetup;
	this.Debug				= null;

	this.getServerDate		= Application_getServerDate;	
	this.closeAllChildWindows	= Application_closeAllChildWindows;
	
	this.comboFormFieldObjectRef = null;
}

/** 
 * Used by ADAPT - returns a tree formatted xml representation of this object.
 *
 * @param objWindow The window object.
 * @return The tree formatted xml representation of this object.
 */
function Application_toXML(objWindow)
{
	if (objWindow == null)
		objWindow = this.objAppWindow;

	var strUID = objWindow.m_strComponentId.replace(".xml", "");

	var strXML = "<tv:treeview xmlns:tv='http://www.exel.co.uk/xml/treeview'>";
	strXML += "<node uid='" + strUID + "' icon='http://" + objApplication.Connection.applicationServer + "/efacs/English/GIF/gifapplication.gif' open='true' level='1' tooltip='" + objApplication.description + "' fire-onclick='true'>";
	strXML += "<vals>";
	strXML += "<val id='label'>" + strUID + "</val>";

	strXML += "<val id='name'>" + objApplication.description + "</val>";
	strXML += "<val id='event1'>onLoad</val>";
	strXML += "<val id='event2'>onUnload</val>";
	strXML += "<val id='event3'>onLoadRecord</val>";
	strXML += "</vals>";
	strXML += "<nodes>";
	strXML += this.getFormsToXML(strUID, objWindow);

	strXML += this.getToolbarsToXML(strUID, objWindow);

	strXML += this.getGridsToXML(strUID, objWindow);

	strXML += this.getContainersToXML(strUID, objWindow);

	strXML += this.getTabbedDialogsToXML(strUID, objWindow);

	strXML += this.getListPickersToXML(strUID, objWindow);

	// End application node.
	strXML += "</nodes>";
	strXML += "</node>";
	strXML += "</tv:treeview>";

	// replace &nbsp; as the former only works with html.
	
	var regEx = /&nbsp;/g;
	strXML = strXML.replace(regEx, "");

	return strXML;
}

/**
 * Returns tree formatted FormXML used in ADAPT.
 * 
 * @param strUID The unique application id.
 * @param objWindow The window object.
 * @return The string of tree formatted FormXML.
 */
function Application_getFormsToXML(strUID, objWindow)
{
	var strXML = "";
	
	var flgFound = false;
	for (var intCtr = 0; intCtr < this.arrForms.length; intCtr++)
	{
		var objForm = this.arrForms[intCtr];
		if (objForm.objWindow == objWindow)
		{
			flgFound = true;
			break;
		}
	}
	
	if (flgFound)
	{
		// FORMS	
		strXML += "<node uid='FORMS_" + strUID + "' icon='http://" + objApplication.Connection.applicationServer + "/efacs/English/GIF/gifform.gif' open='true' level='2' tooltip='Forms'>";
		strXML += "<vals>";
		strXML += "<val id='label'>Forms</val>";
		strXML += "</vals>";
		strXML += "<nodes>";
		for (var intCtr = 0; intCtr < this.arrForms.length; intCtr++)
		{
			var objForm = this.arrForms[intCtr];
			if (objForm.objWindow == objWindow)
			{
				var strFormXML = objForm.toXML();
				if (strFormXML != null)
					strXML += strFormXML;
				
			}
		}
		strXML += "</nodes>";
		strXML += "</node>";
	}

	return strXML;	
}

/**
 * Returns tree formatted ToolbarXML used in ADAPT.
 * 
 * @param strUID The unique application id.
 * @param objWindow The window object.
 * @return The string of tree formatted ToolbarXML.
 */
function Application_getToolbarsToXML(strUID, objWindow)
{
	var strXML = "";
	
	var flgFound = false;
	for (var intCtr = 0; intCtr < this.arrToolbars.length; intCtr++)
	{
		var objToolbar = this.arrToolbars[intCtr];
		if (objToolbar.objWindow == objWindow)
		{
			flgFound = true;
			break;
		}
	}

	if (flgFound)
	{
		// Toolbars	
		strXML += "<node uid='TOOLBARS_" + strUID + "' icon='http://" + objApplication.Connection.applicationServer + "/efacs/English/GIF/giftoolbar.gif' open='true' level='2' tooltip='Toolbars'>";
		strXML += "<vals>";
		strXML += "<val id='label'>Toolbars</val>";
		strXML += "</vals>";
		strXML += "<nodes>";
		for (var intCtr = 0; intCtr < this.arrToolbars.length; intCtr++)
		{
			var objToolbar = this.arrToolbars[intCtr];
			if (objToolbar.objWindow == objWindow)
			{
				var strToolbarXML = objToolbar.toXML();
				if (strToolbarXML != null)
					strXML += strToolbarXML;
				
			}
		}
		strXML += "</nodes>";
		strXML += "</node>";
	}

	return strXML;	
}

/**
 * Returns tree formatted GridXML used in ADAPT.
 * 
 * @param strUID The unique application id.
 * @param objWindow The window object.
 * @return The string of tree formatted GridXML.
 */
function Application_getGridsToXML(strUID, objWindow)
{
	var strXML = "";
	
	var flgFound = false;
	for (var intCtr = 0; intCtr < this.arrGrids.length; intCtr++)
	{
		var objGrid = this.arrGrids[intCtr];
		if (objGrid.objAppWindow == objWindow)
		{
			flgFound = true;
			break;
		}
	}

	if (flgFound)
	{
		// Grids	
		strXML += "<node uid='GRIDS_" + strUID + "' icon='http://" + objApplication.Connection.applicationServer + "/efacs/English/GIF/gifgrid.gif' open='true' level='2' tooltip='Grids'>";
		strXML += "<vals>";
		strXML += "<val id='label'>Grids</val>";
		strXML += "</vals>";
		strXML += "<nodes>";
		for (var intCtr = 0; intCtr < this.arrGrids.length; intCtr++)
		{
			var objGrid = this.arrGrids[intCtr];
			if (objGrid.objAppWindow == objWindow)
			{
				var strGridXML = objGrid.toXML();
				if (strGridXML != null)
					strXML += strGridXML;
				
			}
		}
		strXML += "</nodes>";
		strXML += "</node>";
	}

	return strXML;	
}

/**
 * Returns tree formatted ContainerXML used in ADAPT.
 * 
 * @param strUID The unique application id.
 * @param objWindow The window object.
 * @return The string of tree formatted ContainerXML.
 */
function Application_getContainersToXML(strUID, objWindow)
{
	var strXML = "";
	
	var flgFound = false;
	for (var intCtr = 0; intCtr < this.arrContainers.length; intCtr++)
	{
		var objContainer = this.arrContainers[intCtr];
		if (objContainer.objWindow == objWindow)
		{
			flgFound = true;
			break;
		}
	}

	if (flgFound)
	{
		// Containers	
		strXML += "<node uid='CONTAINERS_" + strUID + "' icon='http://" + objApplication.Connection.applicationServer + "/efacs/English/GIF/gifcontainer.gif' open='true' level='2' tooltip='Containers'>";
		strXML += "<vals>";
		strXML += "<val id='label'>Containers</val>";
		strXML += "</vals>";
		strXML += "<nodes>";
		for (var intCtr = 0; intCtr < this.arrContainers.length; intCtr++)
		{
			var objContainer = this.arrContainers[intCtr];
			if (objContainer.objWindow == objWindow)
			{
				var strContainerXML = objContainer.toXML();
				if (strContainerXML != null)
					strXML += strContainerXML;
				
			}
		}
		strXML += "</nodes>";
		strXML += "</node>";
	}

	return strXML;	
}

/**
 * Returns tree formatted TabbedDialogXML used in ADAPT.
 * 
 * @param strUID The unique application id.
 * @param objWindow The window object.
 * @return The string of tree formatted TabbedDialogXML.
 */
function Application_getTabbedDialogsToXML(strUID, objWindow)
{
	var strXML = "";
	
	var flgFound = false;
	for (var intCtr = 0; intCtr < this.arrTabbedDialogs.length; intCtr++)
	{
		var objTabbedDialog = this.arrTabbedDialogs[intCtr];
		if (objTabbedDialog.objWindow == objWindow)
		{
			flgFound = true;
			break;
		}
	}

	if (flgFound)
	{
		// TabbedDialogs	
		strXML += "<node uid='TABBEDDIALOGS_" + strUID + "' icon='http://" + objApplication.Connection.applicationServer + "/efacs/English/GIF/giftabbeddialog.gif' open='true' level='2' tooltip='Tabbed dialogs'>";
		strXML += "<vals>";
		strXML += "<val id='label'>Tabbed dialogs</val>";
		strXML += "</vals>";
		strXML += "<nodes>";
		for (var intCtr = 0; intCtr < this.arrTabbedDialogs.length; intCtr++)
		{
			var objTabbedDialog = this.arrTabbedDialogs[intCtr];
			if (objTabbedDialog.objWindow == objWindow)
			{
				var strTabbedDialogXML = objTabbedDialog.toXML();
				if (strTabbedDialogXML != null)
					strXML += strTabbedDialogXML;
				
			}
		}
		strXML += "</nodes>";
		strXML += "</node>";
	}

	return strXML;	
}

/**
 * Returns tree formatted ListPickerXML used in ADAPT.
 * 
 * @param strUID The unique application id.
 * @param objWindow The window object.
 * @return The string of tree formatted ListPickerXML.
 */
function Application_getListPickersToXML(strUID, objWindow)
{
	var strXML = "";
	
	var flgFound = false;
	for (var intCtr = 0; intCtr < this.arrListPickers.length; intCtr++)
	{
		var objListPicker = this.arrListPickers[intCtr];
		if (objListPicker.objAppWindow == objWindow)
		{
			flgFound = true;
			break;
		}
	}

	if (flgFound)
	{
		// ListPickers	
		strXML += "<node uid='LISTPICKERS_" + strUID + "' icon='http://" + objApplication.Connection.applicationServer + "/efacs/English/GIF/giflistpicker.gif' open='true' level='2' tooltip='List pickers'>";
		strXML += "<vals>";
		strXML += "<val id='label'>List pickers</val>";
		strXML += "</vals>";
		strXML += "<nodes>";
		for (var intCtr = 0; intCtr < this.arrListPickers.length; intCtr++)
		{
			var objListPicker = this.arrListPickers[intCtr];
			if (objListPicker.objAppWindow == objWindow)
			{
				var strListPickerXML = objListPicker.toXML();
				if (strListPickerXML != null)
					strXML += strListPickerXML;
				
			}
		}
		strXML += "</nodes>";
		strXML += "</node>";
	}

	return strXML;	
}

function Application_helpApplication() {
	var objEarl = new Earl(this.objAppWindow);
	
	objEarl.sessionString		= this.Connection.strConnectionString;
	objEarl.applicationServer	= this.Connection.applicationServer;
	objEarl.report				= "repUserGuide"; 
	objEarl.title				= "Help";
	objEarl.mode				= "HTML";
	objEarl.layout				= "A4 (Portrait)";
	objEarl.orderBy				= "menu-group";
	objEarl.appID				= this.appID;
	objEarl.viaURL				= true;

	objEarl.addParameter(this.appID);
	objEarl.addParameter("APP");
	objEarl.addParameter(this.User.language);
	objEarl.run();
}

function Application_aboutApplication() {
	this.openChildWindow(window, "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Applications_HTML/appDiagnostics.html");
}

function Application_closeApplication(objAppWindow) {
	if (objAppWindow == null)
		objAppWindow = window;


	// If this application in running in an app container then do not close window - 
	// just navigate to to blank.htm
	if (objAppWindow.parent.MenuTreeContainer)
	{
		objAppWindow.location= "http://" + objApplication.Connection.applicationServer + "/efacs/English/HTML/htmBlank.htm";
		objAppWindow.parent.MenuTreeContainer.expand();
		objAppWindow.parent.ModuleContainer.expand();
	}
	else
		objAppWindow.close();
}

function Application_addScript(strFileName, strVersion, strRevision, strModified) {
	this.Scripts[this.intScripts++] = new Application_Component("Script",
		strFileName.replace("../Scripts/", ""), strVersion, strRevision, strModified);
}

function Application_Component(p_strType, p_strFileName, p_strVersion, p_strRevision, p_strModified) {
	this.strType = p_strType;
	this.strID = p_strFileName;
	this.strVersion = p_strVersion;
	this.strRevision = p_strRevision;
	this.strModified = p_strModified;
}

/*---------------------------------- QUERY MANAGEMENT --------------------------------------*/

function Application_addQuery(queryID, p_objAppWindow) {
	var intNewArrNum = this.arrQueries.length;
	var objQuery = new Query(queryID, p_objAppWindow);
	this.arrQueries[intNewArrNum] = objQuery;
	return objQuery;
}

function Application_removeQuery(queryID)
{
	var arrNewArray = new Array();
	var flgFound = false;

	for (var intCtr = 0, intLen = this.arrQueries.length; intCtr < intLen; intCtr++)
	{
		var objQuery = this.arrQueries[intCtr];
		if (objQuery == null)
			continue;
		if (objQuery.id != queryID)
			arrNewArray[arrNewArray.length] = objQuery;
		else {
			flgFound = true;
			objQuery.destroy();
			objQuery = null;
		}
	}
	
	if (flgFound)
		this.arrQueries = arrNewArray;
}

function Application_Queries(strQueryID) {
	var retVal;
	for (var intCtr = 0, intLen = this.arrQueries.length; intCtr < intLen; intCtr++)
	{
		var objQuery = this.arrQueries[intCtr];
		if (objQuery == null)
			continue;
		if (objQuery.id == strQueryID)
		{
			retVal = objQuery;
			break;
		}
	}
	return retVal;
}

/*---------------------------------- FORM MANAGEMENT --------------------------------------*/

function Application_addForm(objHTMLElement, p_objWindow) {
	var intNewArrNum = this.arrForms.length;
	var objForm = new Form(objHTMLElement, p_objWindow);
	this.arrForms[intNewArrNum] = objForm;
	return objForm;
}

function Application_removeForm(objForm)
{
	var arrNewArray = new Array();
	var flgFound = false;

	for (var intCtr = 0, intLen = this.arrForms.length; intCtr < intLen; intCtr++)
	{
		if (objForm != this.arrForms[intCtr]) {
			if (this.arrForms[intCtr] != null)
				arrNewArray[arrNewArray.length] = this.arrForms[intCtr];
		}
		else {
			flgFound = true;
			this.arrForms[intCtr].destroy();
			this.arrForms[intCtr] = null;
		}
	}
	
	if (flgFound)
		this.arrForms = arrNewArray;
}

function Application_Forms(strFormID) {
	var retVal;
	for (var intCtr = 0, intLen = this.arrForms.length; intCtr < intLen; intCtr++)
	{
		var objForm = this.arrForms[intCtr];
		if (objForm == null)
			continue;
		if (objForm.id == strFormID)
		{
			retVal = objForm;
			break;
		}
	}
	return retVal;
}

/*---------------------------------- GRID MANAGEMENT --------------------------------------*/

function Application_addGrid(objGridDivID, strSelectType, strSortable, strAutoResize, strOnRowSelect, strOnRowDblClick, strOnColumnResize, objAppWindow) {
	var intNewArrNum = this.arrGrids.length;
	var objGrid = new Grid(objGridDivID, strSelectType, strSortable, strAutoResize, strOnRowSelect, strOnRowDblClick, strOnColumnResize, objAppWindow);
	this.arrGrids[intNewArrNum] = objGrid;
	return objGrid;
}

function Application_removeGrid(objGrid)
{
	var arrNewArray = new Array();
	var flgFound = false;

	for (var intCtr = 0, intLen = this.arrGrids.length; intCtr < intLen; intCtr++)
	{
		if (objGrid != this.arrGrids[intCtr]) {
			if (this.arrGrids[intCtr] != null)
				arrNewArray[arrNewArray.length] = this.arrGrids[intCtr];
		} else {
			flgFound = true;
			this.arrGrids[intCtr].destroy();
			this.arrGrids[intCtr] = null;
		}
	}
	
	if (flgFound)
		this.arrGrids = arrNewArray;
}

function Application_Grids(strGridID) {
	var retVal;
	for (var intCtr = 0, intLen = this.arrGrids.length; intCtr < intLen; intCtr++)
	{
		var objGrid = this.arrGrids[intCtr];
		if (objGrid == null)
			continue;
		if (objGrid.id == strGridID)
		{
			retVal = objGrid;
			break;
		}
	}
	return retVal;
}

/*-------------------------- EDIT WINDOW MANAGEMENT --------------------------------------*/

function Application_addEditWindowManager(strEditWindowManagerID, strApplicationName, strGridId, AppWindow) {
	var objEditWindowManager = new EditWindowManager(strEditWindowManagerID, strApplicationName, strGridId, AppWindow);
	var intNewArrNum = this.arrEditWindowManagers.length;
	this.arrEditWindowManagers[intNewArrNum] = objEditWindowManager;
	return objEditWindowManager;
}

function Application_removeEditWindowManager(objEditWindowManager)
{
	var arrNewArray = new Array();
	var flgFound = false;

	for (var intCtr = 0, intLen = this.arrEditWindowManagers.length; intCtr < intLen; intCtr++)
	{
		if (objEditWindowManager != this.arrEditWindowManagers[intCtr]) {
			if (this.arrEditWindowManagers[intCtr] != null)
				arrNewArray[arrNewArray.length] = this.arrEditWindowManagers[intCtr];
		} else {
			flgFound = true;
			this.arrEditWindowManagers[intCtr].destroy();
			this.arrEditWindowManagers[intCtr] = null;
		}
	}
	
	if (flgFound)
		this.arrEditWindowManagers = arrNewArray;
}

function Application_EditWindowManagers(strEditWindowManagerID) {
	var retVal;

	for (var intCtr = 0, intLen = this.arrEditWindowManagers.length; intCtr < intLen; intCtr++)
	{
		var objEditWindowManager = this.arrEditWindowManagers[intCtr];
		if (objEditWindowManager == null)
			continue;
		if (objEditWindowManager.id == strEditWindowManagerID)
		{
			retVal = objEditWindowManager;
			break;
		}
	}

	return retVal;
}

/*-------------------------- WINDOW OPEN/SIZE/POSITION ROUTINES --------------------------------------*/

Application.prototype.getCClientApplet = function() {
	var client = this.objAppWindow.document.getElementById("EfacsCClientApplet" + (objApplication.browser == APPLICATION_NN ? "NN" : ""));
	
	if (client != null) {
		return client;
	} 
	
	return this.EfacsApplet;
}
// Launch a Legacy application
Application.prototype.openLegacyApplication = function (strCommand, strTitle, strMenuId, intLog) {

	var client = this.getCClientApplet();
	if (objApplication.PersistentXML.getPersistentTag("showCompanyName", "appMenu.xml") == "true")
		strTitle += (" - " + objApplication.User.companyName);
	client.RunProgram(strCommand, strTitle, strMenuId, objApplication.User.userID, objApplication.User.company, intLog);
}

//Connect the service
Application.prototype.connectCClient = function () {
	var client = this.getCClientApplet();
	var objRPC = new RPCObject("company");
	var strPassword = objRPC.execute("getCPassword", objApplication.Connection.strConnectionString);
	client.connect(objApplication.Connection.cServer,
							objApplication.Connection.masterDatabaseServer,
							8989,
							objApplication.User.company,
							objApplication.Connection.databaseName,
							objApplication.User.language,
							objApplication.Connection.databaseProvider,
							objApplication.Connection.strConnectionString,
							objApplication.Connection.applicationServer,
							objApplication.User.languageDirectory,
							objApplication.User.companyName,
							objApplication.Connection.databaseName,
							strPassword);
}

/** 
 * Opens child application window.
 *
 * @param AppWindow The launching window.
 * @param strURL The url for the child window.
 * @param strTargetName The child window target name.
 * @param strFeatures The child window features.
 * @return Reference to the newly opened child window.
 */
function Application_openChildWindow(AppWindow, strURL, strTargetName, strFeatures)
{
	var strAddress;

	// Use current time to create unique target name
	var intAppCounter = this.getServerDate();

	// Get target name
	if (strTargetName == null)
		strTargetName = this.EfacsApplet.getWindowTargetName(AppWindow.objApplication.getWindowFileName(strURL));

	// hyphens are not legal in the Window.Open command
	var regEx = /\-/g;
	strTargetName = strTargetName.replace(regEx, "_");
	regEx = / /g;
	strTargetName = strTargetName.replace(regEx, "_");
	regEx = /\./g;
	strTargetName = strTargetName.replace(regEx, "_");
		
	// Generate the features string
	// Basically turn off everything apart from resizing and set window position
	if (strFeatures == null)
	{
		strFeatures = "directories=no, location=no, menubar=no,";
		strFeatures += " scrollbars=no, status=no, titlebar=no,";
		strFeatures += " toolbar=no, resizable=yes";
		strFeatures += AppWindow.objApplication.PersistentXML.getWindowSettings(strURL, false);
	}

	if (objApplication.hadCriticalError)
		return;

	// Calculate the full address for the Child
	if (strURL.indexOf("?") != -1)
		strAddress = strURL + "&login=no";
	else
		strAddress = strURL + "?login=no";

	// Add application of main window to all child windows - used by cryptservlet for style sheet requests.
	if (!isBlank(this.appID))
	{
		strAddress += "&appid=" + this.appID;
		strAddress += "&menuid=" + this.menuID;
	}

	// Open the Child window.
	// URL  Name for target plus features.
	var objNewWindow = AppWindow.open(strAddress, strTargetName, strFeatures);
	
	AppWindow.m_arrChildWindows[AppWindow.m_arrChildWindows.length] = objNewWindow;

	return objNewWindow;
}

/** 
 * Opens a modal child application window.
 * This is useful for display messages with a richer content that can use standard
 * emerald features
 *
 * @param AppWindow The launching window.
 * @param strURL The url for the child window.
 * @param strFeatures The child window features.
 * @param bMessage Indicates if this is a message box or not
 * @param strSize Size of the dialog
 * @return Value from modal dialog
 */
function Application_openModalWindow(AppWindow, strURL, strFeatures, bMessage, strSize)
{
	// Generate the features string
	if (strFeatures == null)
	{
		strFeatures = "scroll:no; help:no; status:no;";
		
		if (bMessage == true)
			strFeatures += "center=yes;";
		
		if (!isBlank(strSize))
			strFeatures += strSize;
		else
		{
			strFeatures += "resizable:yes;";
			strFeatures += AppWindow.objApplication.PersistentXML.getWindowSettings(strURL, true);
		}
	}

	if (objApplication.hadCriticalError)
		return;

	if (!isBlank(objApplication.appID))
	{
		if (strURL.indexOf("?") == -1)
			strURL += "?appid=" + objApplication.appID;
		else
			strURL += "&appid=" + objApplication.appID;
		strURL += "&menuid=" + objApplication.menuID;
	}

    return showModalWindow(strURL, objApplication, strFeatures, AppWindow);
}

function Application_getWindowFileName(strURL) {
	var strTmp;

	if (strURL.indexOf("?") == -1)
		strTmp = strURL;
	else
		strTmp = strURL.substring(0, strURL.indexOf("?"));

	strTmp = strTmp.substring(strTmp.lastIndexOf("/") + 1, strTmp.length).replace(".", "_");

	if (strTmp == "appInfoPanel_html")
		strTmp += "_" + ParseStringFromURL("panel", strURL);

	return strTmp;
}

function Application_sendData(Source, AppXml, Command) {

	var objXMLHTTP;
	var objXML;

	objXMLHTTP = new ActiveXObject("Microsoft.XMLHTTP");

	objXML = objApplication.createXMLDocument(AppXml);

	objXMLHTTP.open("POST", Source + Command, false);
	objXMLHTTP.send(objXML);

	// If the objXMLHTTP request fails
	if (objXMLHTTP.status == "500")
	{
		window.alert(fl("REQUESTFAILED"));
		return;
	}

	return objXMLHTTP.responseXML;
}

/*----------------------------------------MODULE MANAGEMENT----------------------------------------*/
function Application_Modules(strModuleID)
{
	var retVal = false;
	var flgFound = false;
	var objModule;

	// Use application object from top window so they are cached for all child apps.
	var objMenuApplication = getTopWindow().objApplication;

	// First check the array for the module, if its not in the array then call the licence
	// and add to the array so won't be called on subsequent calls.
	// Usually the module check will only be called once from the application, but with mapping
	// for example the call will be on each change of addressid so we don't want to do a SOAP
	// call each time.
	for (var intCtr = 0; intCtr < objMenuApplication.arrModules.length; intCtr++) {
		objModule = objMenuApplication.arrModules[intCtr];
		
		if (objModule.id == strModuleID) {
			retVal = objModule.value;
			flgFound = true;
			break;
		}
	}
	
	if (flgFound == true)
		return retVal;
	else {
		objModule = objMenuApplication.addModule(strModuleID);
		return objModule.value;
	}
}

function Application_addModule(strModuleID) {
	// Use application object from top window so they are cached for all child apps.
	var objMenuApplication = getTopWindow().objApplication;

	var intNewArrNum = objMenuApplication.arrModules.length;
	var objModule = new Module(strModuleID);
	
	objMenuApplication.arrModules[intNewArrNum] = objModule;
	return objModule;
}

/*---------------------------------------- COOKIES ----------------------------------------*/

// Cookie is arranged as "idX=valueX;idY=valueY;idZ=valueZ"
// This gets the valueA for idA passed
function Application_getCookieValue(strID) 
{
	var strIdValue;
	var index = 0;
	var nextIndex = 0;
	var equalIndex = -1;

	var objCookie = this.objAppWindow.document.cookie;

	while(nextIndex != -1) 
	{
		nextIndex = objCookie.indexOf("; ", index);
		if (nextIndex == -1)
			strIdValue = objCookie.substring(index, objCookie.length);
		else
			strIdValue = objCookie.substring(index, nextIndex);
		
		equalIndex = strIdValue.indexOf("=");
		if (strID.toLowerCase() == strIdValue.substring(0, equalIndex).toLowerCase())
			return strIdValue.substring(equalIndex+1, strIdValue.length);

		index = nextIndex+2;
	}
	return "";
}

// NB when you set a cookie all you need to do is put the value in
function Application_setCookieValue(strID, strValue) 
{// REVIEW
	var expires = this.getServerDate();
	// Set expiry date into future
	expires.setFullYear(expires.getFullYear() + 10);
	this.objAppWindow.document.cookie = strID + "=" + strValue + "; expires=" + expires.toGMTString();
}

function Application_updateLog(logNumber)
{
//REVIEW
	if (logNumber == 0 || objApplication.User.logUser == "false" || objApplication.User.logUser == "0")
		return;
			
	var objRPC = new RPCObject("UserActivityLog");
	objRPC.execute("Load", objApplication.Connection.strConnectionString, logNumber);

	var LogXML = objRPC.getReturnedXMLDom();
	
	objLog = LogXML.selectSingleNode("/useractivitylogs/useractivitylog");

	if (objLog == null)
		return;
	
	CurDat = this.getServerDate();
	
	var MM = CurDat.getMonth() + 1;
	MM = "0" + MM;
	var DD = "0" + CurDat.getDate();
	var hh = "0" + CurDat.getHours();
	var mm = "0" + CurDat.getMinutes();
	var ss = "0" + CurDat.getSeconds();

	var strDate = CurDat.getFullYear() + "-" + MM.substring(MM.length-2) +
	"-" + DD.substring(DD.length-2) + "T" + hh.substring(hh.length-2) +
	":" + mm.substring(mm.length-2) + ":" + ss.substring(ss.length-2) + "Z";	
	
	objLog.selectSingleNode("enddate/value").setText(strDate);
	
	var strSaveXML = objApplication.Data.prepareForSave(objLog);
	
	var retVal = objRPC.execute("Save", objApplication.Connection.strConnectionString, strSaveXML);
}

function Application_createXMLDocument(strXML)
{
	var objXML;
	
	if (objApplication.browser == APPLICATION_IE)
		objXML = new MSDocument();
	else
		objXML = getEfacsApplet().createXMLDocument();

	if (strXML != null)
	{
		objXML.loadXML(strXML);
	}
	return objXML;
}

function Application_getNumberFormatter()
{
	if (this.NumberFormatter == null)
		this.NumberFormatter = this.EfacsApplet.createNumberFormatter(objApplication.User.localeid, window.document.URL, "../XML/xmlRegionalSettings.xml");

	return this.NumberFormatter;
}

function Application_getForeignNumberFormatter(strLocaleId)
{
	var intNumFormatters = this.arrForeignNumberFormatters.length;
	for (var intCtr = 0; intCtr < intNumFormatters; intCtr++)
	{
		if (this.arrForeignNumberFormatters[intCtr].localeId == strLocaleId)
			return this.arrForeignNumberFormatters[intCtr].NumberFormatter;
	}
	this.arrForeignNumberFormatters[intNumFormatters] = new ForeignNumberFormatter(strLocaleId);
	return this.arrForeignNumberFormatters[intNumFormatters].NumberFormatter;
}

function ForeignNumberFormatter(strLocaleId)
{
	this.localeId = strLocaleId;
	this.NumberFormatter = this.EfacsApplet.createNumberFormatter(strLocaleId, window.document.URL, "../XML/xmlRegionalSettings.xml");
}

function Application_getDateParser()
{
	if (this.dateParser == null)
		this.dateParser = this.EfacsApplet.getEfacsDateParser(objApplication.User.localeid, "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/XML/xmlRegionalSettings.xml");

	return this.dateParser;
}

/**
 * Create a reference to an EfacsCalendar object.
 * 
 * @return EfacsCalendar a reference to an EfacsCalendar object.
 */
function Application_getCalendarParser()
{
	if (this.calendarParser == null)
		this.calendarParser = this.EfacsApplet.getEfacsCalendarParser(objApplication.User.localeid, "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/XML/xmlRegionalSettings.xml");
	
	// this instances is held by the applet so may need to be reset to current date/time after previous operations
	this.calendarParser.setCurrentDateTime();
	return this.calendarParser;
}

/**
 * Initialises Debug object for apps running in debug mode.
 * 
 * @param objWindow Reference to the window being debugged.
 */
function Application_debugSetup(objWindow)
{
	this.Debug = new Debug(objWindow);
	this.Debug.initialise();
}

/**
 * Removes the passed toolbar from the applications toolbar array.
 * Fired when a window is unloaded.
 * 
 * @param objToolbar The toolbar to be removed from the application array.
 */
function Application_removeToolbar(objToolbar)
{
	var arrNewArray = new Array();
	var flgFound = false;

	for (var intCtr = 0; intCtr < this.arrToolbars.length; intCtr++)
	{
		if (objToolbar != this.arrToolbars[intCtr]) {
			if (this.arrToolbars[intCtr] != null)
				arrNewArray[arrNewArray.length] = this.arrToolbars[intCtr];
		} else {
			flgFound = true;
			this.arrToolbars[intCtr].destroy();
			this.arrToolbars[intCtr] = null;
		}
	}
	
	if (flgFound)
		this.arrToolbars = arrNewArray;
}

/**
 * Returns a reference to the toolbar object based on the passed toolbar id.
 * 
 * @param strToolbarId The id of the toolbar being requested.
 * @return A reference to the requested toolbar object.
 */
function Application_Toolbars(strToolbarId) {
	var retVal;
	for (var intCtr = 0; intCtr < this.arrToolbars.length; intCtr++)
	{
		var objToolbar = this.arrToolbars[intCtr];
		if (objToolbar == null)
			continue;
		if (objToolbar.id == strToolbarId)
		{
			retVal = objToolbar;
			break;
		}
	}
	return retVal;
}

/**
 * Removes the passed container from the applications container array.
 * Fired when a window is unloaded.
 * 
 * @param objContainer The container to be removed from the application array.
 */
function Application_removeContainer(objContainer)
{
	var arrNewArray = new Array();
	var flgFound = false;

	for (var intCtr = 0; intCtr < this.arrContainers.length; intCtr++)
	{
		if (objContainer != this.arrContainers[intCtr]) {
			if (this.arrContainers[intCtr] != null)
				arrNewArray[arrNewArray.length] = this.arrContainers[intCtr];
		} else {
			flgFound = true;
			this.arrContainers[intCtr].destroy();
			this.arrContainers[intCtr] = null;
		}
	}
	
	if (flgFound)
		this.arrContainers = arrNewArray;
}

/**
 * Returns a reference to the container object based on the passed container id.
 * 
 * @param strContainerId The id of the container being requested.
 * @return A reference to the requested container object.
 */
function Application_Containers(strContainerId) {
	var retVal;
	for (var intCtr = 0; intCtr < this.arrContainers.length; intCtr++)
	{
		var objContainer = this.arrContainers[intCtr];
		if (objContainer == null)
			continue;
		if (objContainer.id == strContainerId)
		{
			retVal = objContainer;
			break;
		}
	}
	return retVal;
}

/**
 * Removes the passed tabbed dialog from the applications tabbed dialog array.
 * Fired when a window is unloaded.
 * 
 * @param objTabbedDialog The tabbed dialog to be removed from the application array.
 */
function Application_removeTabbedDialog(objTabbedDialog)
{
	var arrNewArray = new Array();
	var flgFound = false;

	for (var intCtr = 0; intCtr < this.arrTabbedDialogs.length; intCtr++)
	{
		if (objTabbedDialog != this.arrTabbedDialogs[intCtr]) {
			if (this.arrTabbedDialogs[intCtr] != null)
				arrNewArray[arrNewArray.length] = this.arrTabbedDialogs[intCtr];
		 } else  {
			flgFound = true;
			this.arrTabbedDialogs[intCtr].destroy();
			this.arrTabbedDialogs[intCtr] = null;
		}
	}
	
	if (flgFound)
		this.arrTabbedDialogs = arrNewArray;
}

/**
 * Returns a reference to the tabbed dialog object based on the passed tabbed dialog id.
 * 
 * @param strTabbedDialogId The id of the tabbed dialog being requested.
 * @return A reference to the requested tabbed dialog object.
 */
function Application_TabbedDialogs(strTabbedDialogId) {
	var retVal;
	for (var intCtr = 0; intCtr < this.arrTabbedDialogs.length; intCtr++)
	{
		var objTabbedDialog = this.arrTabbedDialogs[intCtr];
		if (objTabbedDialog == null)
			continue;
		if (objTabbedDialog.id == strTabbedDialogId)
		{
			retVal = objTabbedDialog;
			break;
		}
	}
	return retVal;
}

/**
 * Removes the passed list picker from the applications list picker array.
 * Fired when a window is unloaded.
 * 
 * @param objListPicker The list picker to be removed from the application array.
 */
function Application_removeListPicker(objListPicker)
{
	var arrNewArray = new Array();
	var flgFound = false;

	for (var intCtr = 0; intCtr < this.arrListPickers.length; intCtr++)
	{
		if (objListPicker != this.arrListPickers[intCtr])
			arrNewArray[arrNewArray.length] = this.arrListPickers[intCtr];
		else
			flgFound = true;
	}
	
	if (flgFound)
		this.arrListPickers = arrNewArray;
}

/**
 * Returns a reference to the list picker object based on the passed list picker id.
 * 
 * @param strListPickerId The id of the list picker being requested.
 * @return A reference to the requested list picker object.
 */
function Application_ListPickers(strListPickerId) {
	var retVal;
	for (var intCtr = 0; intCtr < this.arrListPickers.length; intCtr++)
	{
		var objListPicker = this.arrListPickers[intCtr];
		if (objListPicker.id == strListPickerId)
		{
			retVal = objListPicker;
			break;
		}
	}
	return retVal;
}

/** 
 * Fires any attached ADAPT javascript.
 *
 * @param flgEventType Binary operator parameter determines which event to fire.
 * @return Returns false if the adapt javascript decided to cancel the event.
 */
function Application_performADAPTScript(flgEventType, objWindow)
{
	var strMethodName;
	var strAppId = objWindow.m_strComponentId.replace(".xml", "");
	
	if (flgEventType & ADAPT_ONAPPLICATIONLOAD) {
		strMethodName = strAppId + "_onLoad";
	} else if (flgEventType & ADAPT_ONAPPLICATIONUNLOAD) {
		strMethodName = strAppId + "_onUnload";
	} else if (flgEventType & ADAPT_ONAPPLICATIONLOADRECORD) {
		strMethodName = strAppId + "_onLoadRecord";
	} else {
		alert("Application event type not supported");
	}
	
	if (typeof(strMethodName) != "undefined" && objWindow[strMethodName] != null) {
		if (objWindow[strMethodName](this) == false) {
			return false;
		}
	}
	
	return true;
}

/**
 *	Gets the current date/time from the Server.
 *	@return	the current date/time as a Date object.
 */
function Application_getServerDate()
{
	return new Date();
//	var urlconnection = "http://" + objApplication.Connection.applicationServer + "/efacs/servlet/ServerDateTime";
//	var parameters = "";
//	return new Date(Number(objApplication.EfacsApplet.post(urlconnection, parameters)));
}

/*---------------------------------- MESSAGE MANAGEMENT --------------------------------------*/

/** 
 * Adds a message to the current application's message list
 *
 * @param	messageID		message identifier
 *			strText			message text
 *			strLocation		location of external message template
 *			intButtons		buttons to display on the message box
 *			intType			type of message to display
 *			objAppWindow	window to display the message in
 *
 * @return	message object
 */
function Application_addMessage(messageID, strText, strLocation, intButtons, intType, objAppWindow) 
{
	var intNewArrNum = this.arrMessages.length;
	
	var objMessage = new Message(messageID, objAppWindow);
	objMessage.setText(strText);
	objMessage.setLocation(strLocation);
	objMessage.setType(intType);
	objMessage.setButtons(intButtons);
	
	this.arrMessages[intNewArrNum] = objMessage;

	return objMessage;
}

/** 
 * Removes a message from the current application's message list
 *
 * @param	objMessage		message object to remove
 */
function Application_removeMessage(objMessage) 
{
	var arrNewArray = new Array();
	var flgFound = false;

	for (var intCtr = 0; intCtr < this.arrMessages.length; intCtr++)
	{
		if (objMessage != this.arrMessages[intCtr]) {
			if (this.arrMessages[intCtr] != null)
				arrNewArray[arrNewArray.length] = this.arrMessages[intCtr];
		} else {
			flgFound = true;
			this.arrMessages[intCtr].destroy();
			this.arrMessages[intCtr] = null;
		}
	}
	
	if (flgFound)
		this.arrMessages = arrNewArray;
}

/** 
 * Retrieves the specified message from the current application's message list
 *
 * @param	strMessageID	message identifier
 *
 * @return	message object
 */
function Application_Messages(strMessageID) 
{
	var retVal;
	
	for (var intCtr = 0; intCtr < this.arrMessages.length; intCtr++)
	{
		var objMessage = this.arrMessages[intCtr];
		if (objMessage == null)
			continue;
		if (objMessage.id == strMessageID)
		{
			retVal = objMessage;
			break;
		}
	}

	return retVal;
}

/**
 * Closes all child windows of the passed window reference.
 *
 * @param objWindow The window reference.
 */
function Application_closeAllChildWindows(objWindow)
{
	var fallbackCtr = 10000;
	var flgFailed = false;
	
	// This window is unloading - need to also close any open child windows.
	while (objWindow.m_arrChildWindows.length > 0)
	{
		fallbackCtr--;
		
		// Make sure there has not been a critical error.
		if (typeof(objApplication.hadCriticalError) == "unknown" || objApplication.hadCriticalError == true)
		{
			if (typeof(objWindow.m_arrChildWindows[0].objApplication) != "unknown")
				objWindow.m_arrChildWindows[0].objApplication.hadCriticalError = true;
		}

		if (typeof(objWindow.m_arrChildWindows[0]) != "unknown")
		{
			var objChildWindow = objWindow.m_arrChildWindows[0];
			var flgSapphireWindow = false;
			
			if (objChildWindow != null) {
				try {
					if (objChildWindow.m_strComponentId == null)
						flgSapphireWindow = true;
				} catch (error) {
					//Null check failed, so must not be able to access m_strComponentId.
					flgSapphireWindow = true;
				}
			
				try {
					objChildWindow.document.body.focus();
				} catch (error) {}
				
				try {
					if (!flgSapphireWindow) {
						objChildWindow.appTrans_onbeforeunload();
						objChildWindow.document.body.onbeforeunload = null;
						objChildWindow.ignoreOnBeforeUnload = true;
					}
				} catch (error) {
					flgFailed = true;
				}				
				
				try {
					objChildWindow.close();
					if (flgSapphireWindow) {
						objWindow.m_arrChildWindows[0] = null;
					}
				} catch (error) {
					if (flgSapphireWindow) {
						objWindow.m_arrChildWindows[0] = null;
					} else {
						flgFailed = true;
					}
				}
			}
				
		}
		
		cleanSapphirePlaceholders(objWindow);
		
		//Prevent infinite loop if a window could not be closed and for some reason it didn't
		//get caught by the above try catch.
		if (fallbackCtr == 0) {
			flgFailed = true;
			break;
		}
	}
	
	if (flgFailed)
		alert("Error closing application windows - Please close them manually and contact your system administrator if the problem persists.");
}

/**
 * Cleans the parent window child windows array of any null elements.
 * Replaces the array with a new array containing only window objects and
 * no null place holders.
 * @param objWindow - The application parent window object.
 */
function cleanSapphirePlaceholders(objWindow) {
	var arrNewArray = new Array();
	var flgFound = false;

	// Find this window in the parents' child window array.
	for (var intCtr = 0, intLen = objWindow.m_arrChildWindows.length; intCtr < intLen; intCtr++)
	{
		if (objWindow.m_arrChildWindows[intCtr] != null)
			arrNewArray[arrNewArray.length] = objWindow.m_arrChildWindows[intCtr];
		else {
			flgFound = true;
		}
	}

	if (flgFound)	{
		objWindow.m_arrChildWindows = arrNewArray;
	}
}

/**
 * Checks whether a button is dependent on a module.
 * If a module is defined against the button then check that we have the module - if we don't then disable the button.
 * Current policy is to disable not hide.
 */
function checkButtonModuleDependencies() {
	var tlbcount = objApplication.arrToolbars.length;
	
	for (var x = 0; x < tlbcount; x++) {
		var tlbbuttoncount = objApplication.arrToolbars[x].arrButtons.length;
		
		for (var y = 0; y < tlbbuttoncount; y++) {
			var objButton = objApplication.arrToolbars[x].arrButtons[y];
			
			if (typeof(objButton.moduleRequired) != "undefined" && objButton.moduleRequired != "") {
				if (objApplication.Modules(objButton.moduleRequired) != true) {
					objButton.haveModule = false;
					objButton.disable();
				}
			}
			
			if (objButton.arrOptions != null) {
				for (var z = 0; z < objButton.arrOptions.length; z++) {
					var objOption = objButton.arrOptions[z];
					if (typeof(objOption.moduleRequired) != "undefined" && objOption.moduleRequired != "") {
						if (objApplication.Modules(objOption.moduleRequired) != true) {
							objOption.haveModule = false;
							objOption.disable();
						}
					}
				}
			}
		}
	}
}



 
// Constructor
function ApplicationContainer(objElement) {

// properties
	this.objHTMLElement		= objElement;

// methods
	this.load			= AC_load;
	this.hide			= AC_hide;
	this.show			= AC_show;
	this.isVisible			= true;
}

function AC_load(strApplication) {
	this.objHTMLElement.src = strApplication;
}


// The following two methods allow the actual container to be hidden / made visible.
function AC_hide() {
	this.objHTMLElement.style.display = "none";
	this.isVisible = false;
}

function AC_show() {
	this.objHTMLElement.style.display = "inline";
	this.isVisible = true;
}



function ApplicationData() {

	var objUserData;

	this.strRootNodeName	= "application-data";
	this.lngUniqueID		= 0;

	if (navigator.appName == "Microsoft Internet Explorer")
		this.DOM = new MSDocument("<" + this.strRootNodeName + " />");
	else
	{
		this.DOM = getEfacsApplet().createXMLDocument();
		this.DOM.loadXML("<" + this.strRootNodeName + " />");
	}

	this.reset				= AppData_reset;
	this.add				= AppData_add;
	this.addToRoot			= AppData_addToRoot;
	this.addToNodeString	= AppData_addToNodeString;
	this.addUnlimitedIDs	= AppData_addUnlimitedIDs;
	this.getXML				= AppData_getXML;
	this.getAppData			= AppData_getAppData;
	this.getRootNode		= AppData_getRootNode;
	this.generateNewRow     = AppData_generateNewRow;
	this.removeRows			= AppData_removeRows;
	this.getSystemParameter = ApplicationData_getSystemParameter;
	this.getHomeCurrencyXML = ApplicationData_getHomeCurrencyXML;
	this.homeCurrencyXML	= null;
	this.getQuantityUOMLookup = ApplicationData_getQuantityUOMLookup;
	
	this.decimalSymbol		= null;
	this.isDirty			= AppData_isDirty;
	this.setAsNotDirty		= AppData_setAsNotDirty;
	this.prepareForSave		= AppData_prepareForSave;
	this.convertToCollection = AppData_convertToCollection;
	this.convertFromCollection = AppData_convertFromCollection;
}

function AppData_reset() {
	// Clear down application-data area - preserve any loaded system parameters and quantity-uom-lookups.
	var strXML = "<" + this.strRootNodeName + ">";

	// Keep any existing system parameters.
	if (this.getRootNode().selectSingleNode("system-parameters") != null)
		strXML += this.getRootNode().selectSingleNode("system-parameters").xml();
	
	// Keep any existing quantity uom lookups.
	if (this.getRootNode().selectSingleNode("quantity-uom-lookups") != null)
		strXML += this.getRootNode().selectSingleNode("quantity-uom-lookups").xml();
	
	strXML += "</" + this.strRootNodeName + ">";

	this.DOM.loadXML(strXML);
	this.lngUniqueID = 0;
}

function AppData_getXML() {
	return String(this.DOM.xml());
}

function AppData_getAppData() {
	return this.DOM;
}

function AppData_getRootNode() {
	return this.DOM.documentElement();
}

function AppData_addToNodeString(strNodeName, strXMLData) {

	var objNode = this.DOM.selectSingleNode(strNodeName);

	if (objNode == null) {
		alert("AppData.addToNodeString: Cannot find node for XPath: " + strNodeName);
		return;
	}
	this.add(objNode, strXMLData);

}

function AppData_addToRoot(strXMLData) {
	this.add(this.getRootNode(), strXMLData);
}

// Returns the last new uniqueID
function AppData_add(objXMLNode, strXMLData) {

	var objXML = objApplication.createXMLDocument();
	this.lngUniqueID = objXML.loadXMLWithUniqueIDs(strXMLData, this.lngUniqueID);

	// Now add to main application-data
	objXMLNode.appendChild(objXML.documentElement());
	
	return this.lngUniqueID;
}

// Returns the last new uniqueID
// Currently just used by KitIssue/Allocation as these need unlimited IDs
function AppData_addUnlimitedIDs(objXMLNode, strXMLData)
{
	if (objApplication.browser == APPLICATION_IE)
		return this.add(objXMLNode, strXMLData);

	var objXML = objApplication.createXMLDocument();
	this.lngUniqueID = objXML.loadXMLWithUnlimitedUniqueIDs(strXMLData, this.lngUniqueID);

	// Now add to main application-data
	objXMLNode.appendChild(objXML.documentElement());
	
	return this.lngUniqueID;
}

// Generate XML for a new row based on schema
// Returns an new xml node.
function AppData_generateNewRow(strSchemaID) {
	return objApplication.Schema.generateNewRow(strSchemaID);
}

// Returns deleted rows xml which can be used in SOAP Save call from the application edit window.
function AppData_removeRows(arrUniqueIDs) {

	for (var i=0; i < arrUniqueIDs.length; i++)
	{
		var objNode = objApplication.Data.DOM.selectSingleNode("//*[@uniqueid = '" + arrUniqueIDs[i] + "']");
		
		if (i == 0)
		{
			var strCollectionName = objNode.parentNode().nodeName();
			var strXML = "<" + strCollectionName + " xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>";
			if (objNode.parentNode().selectSingleNode("dataprocess") != null)
				strXML += objNode.parentNode().selectSingleNode("dataprocess").xml();
		}
		objNode.setAttribute("isdeleted", "true");
		strXML += objNode.xml();

		objNode.parentNode().removeChild(objNode);
	}

	strXML += "</" + strCollectionName + ">";
	
	return strXML;
	
}

function AppData_isDirty(objXML)
{
	var objSchema;
	var strNodeName;
	var intCtr;
	var flgIsDirty = false;

	if (objXML == null)
		return false;

	// Create collections of dirty data.
	var objNullChildren = objXML.selectNodes(".//*[original/@xsi:nil != value/@xsi:nil]");
	var objUpdatedChildren = objXML.selectNodes(".//*[original != value]");
	var objDeletedChildren = objXML.selectNodes(".//*[@isdeleted = 'true']");
	var objNullNodes = objXML.selectNodes("*[original/@xsi:nil != value/@xsi:nil]");
	var objUpdatedNodes = objXML.selectNodes("*[original != value]");
	var objDeletedNodes = objXML.selectNodes("*[@isdeleted = 'true']");

	// Test to see whether the collections have any content.
	var flgNullChildren = (objNullChildren.length() > 0)?true:false;
	var flgNullNodes = (objNullNodes.length() > 0)?true:false;
	var flgUpdatedChildren = (objUpdatedChildren.length() > 0)?true:false;
	var flgDeletedChildren = (objDeletedChildren.length() > 0)?true:false;
	var flgUpdatedNodes = (objUpdatedNodes.length() > 0)?true:false;
	var flgDeletedNodes = (objDeletedNodes.length() > 0)?true:false;

	// If there are any deleted nodes, the data are dirty.
	if (flgDeletedChildren || flgDeletedNodes || flgNullChildren || flgNullNodes)
	{
		// Set the flag to true.  We now don't care about any other collections.
		flgIsDirty = true;
	}
	if (!flgIsDirty && flgUpdatedChildren)
	{
		// Loop through the collection of updated child nodes.
		for (intCtr = 0; intCtr < objUpdatedChildren.length(); intCtr++)
		{
			strNodeName = objUpdatedChildren.item(intCtr).nodeName();

			// Get the schema for this node via its parent.
			objSchema = objApplication.Schema.getSchema(objUpdatedChildren.item(intCtr).parentNode().nodeName());
			if (objSchema != null)
			{
				// If the dirty node is not readonly, the data are dirty.
				if (objSchema.selectSingleNode(".//xsd:element[@name='" + strNodeName + "']").getAttribute("ex:readOnly") == "false")
				{
					// Set the flag to true.  We now don't care about any other collections.
					flgIsDirty = true;
					break;
				}
			}
			else
			{
				flgIsDirty = true;
				break;
			}
		}
	}
	if (!flgIsDirty && flgUpdatedNodes)
	{
		// Loop through the collection of updated nodes.
		for (intCtr = 0; intCtr < objUpdatedNodes.length(); intCtr++)
		{
			strNodeName = objUpdatedNodes.item(intCtr).nodeName();

			// Get the schema for this node via its parent.
			objSchema = objApplication.Schema.getSchema(objUpdatedNodes.item(intCtr).parentNode().nodeName());
			if (objSchema != null)
			{
				// If the dirty node is not readonly, the data are dirty.
				if (objSchema.selectSingleNode(".//xsd:element[@name='" + strNodeName + "']").getAttribute("ex:readOnly") == "false")
				{
					// Set the flag to true.  We now don't care about any other collections.
					flgIsDirty = true;
					break;
				}
			}
			else
			{
				flgIsDirty = true;
				break;
			}
		}
	}
	return flgIsDirty;
}

function AppData_setAsNotDirty(objXML, objReturnXML)
{
	var objNodes;
	var objNode;

	if (objReturnXML != null)
	{
		var objBusFieldNodes = objReturnXML.selectNodes("*/*[@etype = 'property']");
		
		for (var objBusFieldNode = objBusFieldNodes.nextNode(); objBusFieldNode != null; objBusFieldNode = objBusFieldNodes.nextNode())
		{
			var objNode = objXML.selectSingleNode("*[name() = '" + objBusFieldNode.nodeName() + "']");
			if (objNode != null)
				objNode.selectSingleNode("value").setText(objBusFieldNode.selectSingleNode("value").getText());
		}
	}

	objNodes = objXML.selectNodes(".//*[original != value]");
	for (objNode=objNodes.nextNode(); objNode != null; objNode=objNodes.nextNode())
	{
		objNode.selectSingleNode("original").setText(objNode.selectSingleNode("value").getText());
		if (isBlank(objNode.selectSingleNode("value").getAttribute("xsi:nil")))
		{
			objNode.selectSingleNode("original").removeAttribute("xsi:nil");
		}
		else
		{
			objNode.selectSingleNode("original").setAttribute("xsi:nil","true");
		}
	}
	objNodes = objXML.selectNodes("*[original != value]");
	for (objNode=objNodes.nextNode(); objNode != null; objNode=objNodes.nextNode())
	{
		objNode.selectSingleNode("original").setText(objNode.selectSingleNode("value").getText());
		if (isBlank(objNode.selectSingleNode("value").getAttribute("xsi:nil")))
		{
			objNode.selectSingleNode("original").removeAttribute("xsi:nil");
		}
		else
		{
			objNode.selectSingleNode("original").setAttribute("xsi:nil","true");
		}
	}

	objNodes = objXML.selectNodes("*/*[@isnew = 'true']");
	for (objNode=objNodes.nextNode(); objNode != null; objNode=objNodes.nextNode())
	{
		objNode.setAttribute("isnew", "false");
	
		var objChildNodes = objNode.selectNodes("*");
		for (var objChildNode=objChildNodes.nextNode(); objChildNode != null; objChildNode=objChildNodes.nextNode())
		{
			objChildNode.selectSingleNode("original").setText(objChildNode.selectSingleNode("value").getText());
	
			if (objChildNode.selectSingleNode("value").getText() != "")
			{
				objChildNode.selectSingleNode("value").removeAttribute("xsi:nil");
				objChildNode.selectSingleNode("original").removeAttribute("xsi:nil");
			}
		}
	}

	if (objXML.getAttribute("isnew") == "true")
	{
		objXML.setAttribute("isnew", "false");
		
		var objChildNodes = objXML.selectNodes("*[original]");
		for (var objChildNode=objChildNodes.nextNode(); objChildNode != null; objChildNode=objChildNodes.nextNode())
		{
			objChildNode.selectSingleNode("original").setText(objChildNode.selectSingleNode("value").getText());

			if (objChildNode.selectSingleNode("value").getText() != "")
			{
				objChildNode.selectSingleNode("value").removeAttribute("xsi:nil");
				objChildNode.selectSingleNode("original").removeAttribute("xsi:nil");
			}
		}
	}
}

// This function removes any nodes from the entire XML document that are not dirty and returns a 
// string which is in a suitable state to be used in a SOAP save call.
function AppData_prepareForSave(objDataCollection) {
	var objDataXML = objApplication.createXMLDocument();

	objDataXML.loadXML("<xxx xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>" + objDataCollection.xml() + "</xxx>");

	var objNodes = objDataXML.selectNodes("//*[@uniqueid]");
	for (var objNode = objNodes.nextNode(); objNode != null; objNode = objNodes.nextNode())
	{
		if (this.isDirty(objNode) == false && objNode.getAttribute("isdeleted") != "true")
		{
			if (objNode.parentNode() != null)
				objNode.parentNode().removeChild(objNode);
		}
	}

	// Remove xsi:nil attributes if <value> node contains data.
	var objNodes = objDataXML.selectNodes("//*[@xsi:nil and text() != '']");
	for (var objNode = objNodes.nextNode(); objNode != null; objNode = objNodes.nextNode())
		objNode.removeAttribute("xsi:nil");

	return objDataXML.selectSingleNode("/*/*").xml();
}

// A collection wrapper element is added and the <dataprocesses> (if available) and <properties> 
// elements are added.
function AppData_convertToCollection(objDataNode) {

	var strSchemaID = objDataNode.nodeName();

	var strCollectionName = objApplication.Schema.getSchemaCollectionName(strSchemaID);

	var strXML = "<" + strCollectionName + " xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>";
	strXML += objDataNode.xml();
	strXML += "</" + strCollectionName + ">";

	var objDataXML = objApplication.createXMLDocument();
	objDataXML.loadXML(strXML);

	return objDataXML.documentElement();
}

// Removes collection wrapper from passed string of XML.
function AppData_convertFromCollection(strXML, strBusinessName)
{
	var objXML = objApplication.createXMLDocument();
	objXML.loadXML(strXML);
	var objNode = objXML.selectSingleNode("/*/" + strBusinessName);

	if (objNode != null)
		return objNode;
	else
		return objXML.documentElement();
}

function ApplicationData_getSystemParameter(strParameterID) 
{
	var strParam = objApplication.EfacsApplet.getSystemParameter(strParameterID);
	var objParameter;

	// See if we've already got the parameter
	if (!isBlank(strParam))
		objParameter = objApplication.createXMLDocument(strParam).documentElement();
	else
	{
		// Parameter cannot be found in app data - make a soap call to load it.
		var objRPC = new RPCObject("Parameter");
		objRPC.execute("load", objApplication.Connection.strConnectionString, strParameterID);

		if (objApplication.hadCriticalError)
			return;

		if (objRPC.isEmpty())
		{
			eMsgBox(fl("SYSPARAMNOTFOUND", strParameterID), 0, msg_Critical, window);

			if(window != objApplication.objAppWindow) 
			{
				// NB this window might not be registered in the child windows collection yet so can try to close it.
				window.ignoreOnBeforeUnload = true; // Cos this may not be setup properly yet
				window.close();
			}
			
			objApplication.hadCriticalError = true;
			objApplication.closeApplication();
			return;
		}

		var objRetVal = objRPC.getReturnedXMLDom();

		// Add this system parameter to the applet so it can be re-used if required without making another soap call.
		objParameter = objRetVal.selectSingleNode("/parameters/parameter");
		objApplication.EfacsApplet.addSystemParameter(strParameterID, objParameter.xml());
	}
	
	return objParameter;
}

/**
 * Gets the system home currency based on the parameter LEHOMECURR.
 * Caches the returned XML for future requests - improves performance.
 * Causes a critical error if LEHOMECURR is set to an invalid currency code.
 * 
 * @param objWindow The window reference of the application making the request.
 *                  Used for error reporting.
 */
function ApplicationData_getHomeCurrencyXML(objWindow) 
{
	if (this.homeCurrencyXML == null)
	{
		// See whether we've already got this stored on the applet
		var strHomeCurrency = objApplication.EfacsApplet.getHomeCurrencyXML();
		var appletHomeCurrencyXML;
		
		if (!isBlank(strHomeCurrency))
			this.homeCurrencyXML = objApplication.createXMLDocument(strHomeCurrency).documentElement();
		else
		{
			// If this is the first time we the home currency symbol has been requested, then make a soap call to fetch it.
			var objParameter = this.getSystemParameter("LEHOMECURR");

			var objRPCObject = new RPCObject("Currency");
			var strParameterID = objParameter.selectSingleNode("spvalue/value").getText();
			objRPCObject.execute("load", objApplication.Connection.strConnectionString, strParameterID);

			if (objRPCObject.isEmpty())
			{
				eMsgBox(fl("INVALIDHOMECURRENCY", strParameterID), 0, msg_Critical, objWindow);
				objApplication.hadCriticalError = true;
				objApplication.closeApplication();
				return;
			}

			var objRetVal = objRPCObject.getReturnedXMLDom();

			this.homeCurrencyXML = objRetVal.selectSingleNode("/currencies/currency");
			objApplication.EfacsApplet.setHomeCurrencyXML(this.homeCurrencyXML.xml());
		}
	}

	return this.homeCurrencyXML;
}

function ApplicationData_getQuantityUOMLookup(strPartID)
{
	var strUOMLookup = objApplication.EfacsApplet.getUOM(strPartID);
	
	if (isBlank(strUOMLookup))
	{
		var objRPC = new RPCObject("Part");
		objRPC.execute("load", objApplication.Connection.strConnectionString, strPartID);
		
		if (objRPC.isEmpty())
			return "";
		
		var objRetVal = objRPC.getReturnedXMLDom();

		strUOMLookup = objRetVal.selectSingleNode("/*/part/uom/value").getText();
		objApplication.EfacsApplet.setUOM(strPartID, strUOMLookup);
	}

	return strUOMLookup;
}



function ApplicationSchema() 
{
	this.strRootNodeName	= "application-schema";

	this.DOM				= getEfacsApplet().createXMLDocument();
	this.DOM.loadXML("<" + this.strRootNodeName + " />");

	this.reset				= AppSchema_reset;
	this.add				= AppSchema_add;
	this.addCustomSchema			= AppSchema_addCustomSchema;
	this.getSchema			= AppSchema_getSchema;
	this.generateNewRow     = AppSchema_generateNewRow;
	this.getSchemaCollectionName = AppSchema_getSchemaCollectionName;
	this.objSchemaCache        = new Object();
	this.clearSchemaCache	= AppSchema_clearSchemaCache;
}

function AppSchema_reset() {
	this.DOM.loadXML("<" + this.strRootNodeName + " />");
}

// Public function
function AppSchema_getSchema(strSchemaID) {
	// Call internal function to perform the getSchema
	return AppSchema_localGetSchema(this, strSchemaID);
}

function AppSchema_add(strSchemaXML) {
	var objXML = objApplication.createXMLDocument();
	objXML.loadXML(strSchemaXML);

	this.DOM.selectSingleNode("/" + this.strRootNodeName).appendChild(objXML.documentElement());
}

function AppSchema_addCustomSchema(strURL) {

	// Get the schema ID as this will be used for looking the schema up.
	var strSchemaID = strURL.substring(strURL.lastIndexOf("/") + 1, strURL.lastIndexOf("."));
	var strFullSchemaID = this.strRootNodeName + "/xsd:schema/xsd:element[@name = '" + strSchemaID.toLowerCase() + "' and @ex:etype='item']";
	var objSchemaXML = this.objSchemaCache[strFullSchemaID];

	// If objSchemaXML is null then load it and add to the EfacsApplet
	if (objSchemaXML == null)
	{
		var objXML = objApplication.createXMLDocument();
		objXML.loadURL(strURL, window.document.URL);
		
		objSchemaXML = objXML.selectSingleNode("/xsd:schema/xsd:element[@name = '" + strSchemaID.toLowerCase() + "' and @ex:etype='item']");
		this.objSchemaCache[strFullSchemaID] = objSchemaXML;
	}
}

// Generate XML for a new row based on schema
// Returns an new xml node.
function AppSchema_generateNewRow(strSchemaID) 
{
	var objEfacsCalendar=objApplication.getCalendarParser();
	var dateNow = objEfacsCalendar.getDateTimeInISO();
	var objSchemaXML = AppSchema_localGetSchema(this, strSchemaID);

	if (objSchemaXML == null)
	{
		eMsgBox(fl("CANNOTLOADSCHEMA", strSchemaID), 0, msg_Critical, window);
		return;
	}		
		
	var objMetaNodes = objSchemaXML.selectNodes("xsd:complexType/xsd:all/xsd:element[@ex:etype='property']");
	var strBusinessID = objSchemaXML.getAttribute("name");
	var strHasDocs = objSchemaXML.getAttribute("hasDocs");

	// Generate a row - add in starting tag
	var strNewRow = "<" + strBusinessID + " xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' isnew='true' isdeleted='false' etype='item' hasDocs='" + strHasDocs + "'>";

	for (var objNode=objMetaNodes.nextNode(); objNode != null; objNode=objMetaNodes.nextNode())
	{
	    // Find the default for this column
		var strDefault = objNode.getAttribute("ex:default");
		
		// When backend is changed need to change this to check for function calls
		if (strDefault == "getdate()")
			strDefault = dateNow;
			
		var strColumnName = objNode.getAttribute("name");
		// Set the modified date to today.  This will in the
		// end be solved on the back end
		if (isBlank(strDefault) && strColumnName == "modifieddate")
			strDefault = dateNow;

		// This will not be needed when we get rid of modifiedtimestamp.			
		if (strColumnName == "modifiedtimestamp")
			strDefault = "000=";

		// Add this column
		strNewRow += "<" + strColumnName + " etype='property'>";
		if (isBlank(strDefault))
		{
			strNewRow += "<original xsi:nil='true' />";
			strNewRow += "<value xsi:nil='true' />";
		}
		else
		{
			strNewRow += "<original>" + strDefault + "</original>";
			strNewRow += "<value>" + strDefault + "</value>";
		}
		strNewRow += "</" + strColumnName + ">";
	}
	// Add closing tag
	strNewRow += "</" + strBusinessID + ">";

	var objXML = objApplication.createXMLDocument();
	objXML.loadXML(strNewRow);
	
	return objXML;
}

/**
 * Load a copy of the schema, getting it from the cache if it 
 * already exists.
 * @param objAppSchema The application schema object
 * @param strSchemaID The id of the required schema
 * @return The schema
 */
function AppSchema_localGetSchema(objAppSchema, strSchemaID)
{
	strSchemaID = strSchemaID.toLowerCase();
	var objSchema = objAppSchema.objSchemaCache[strSchemaID];
	
	// See if we've already got the schema.
	if (objSchema == null) {
		// Schema cannot be found in app data - make a soap call to load it.
		var objRPCObject = new RPCObject(strSchemaID);
		objRPCObject.execute("loadSchema", objApplication.Connection.strConnectionString);
		objSchema = objRPCObject.getReturnedXMLDom();

		var objSchemaNode = objSchema.selectSingleNode("/xsd:schema/xsd:element/xsd:annotation/xsd:appinfo/ex:docs");
		var strHasDocs = (objSchemaNode.getAttribute("ex:hasDocs") == "true")? "true" : "false";
		objSchema.selectSingleNode("/xsd:schema/xsd:element[@name = '" + strSchemaID + "' and @ex:etype='item']").setAttribute("hasDocs", strHasDocs);

		// Add this schema to the applet so it can be re-used if required without making another soap call.
		objAppSchema.objSchemaCache[strSchemaID] = objSchema;
	}
	
	return objSchema.selectSingleNode("/xsd:schema/xsd:element[@name = '" + strSchemaID + "' and @ex:etype='item']");
}

function AppSchema_getSchemaCollectionName(strSchemaID) {
	var objSchemaXML = AppSchema_localGetSchema(this, strSchemaID);
	return objSchemaXML.parentNode().selectSingleNode("xsd:element[@ex:etype = 'collection'][xsd:complexType/xsd:sequence/xsd:element/@ref = '" + strSchemaID + "']").getAttribute("name");
}

/**
 * Clears the schema cache
 */
function AppSchema_clearSchemaCache()
{
	this.objSchemaCache = new Object();
}




// Constructor
function Chart(p_objElement, p_strXMLFile)
{
	// Set up class members once only...
 	if (typeof(_CH_prototype_called) == 'undefined')
	{
		_CH_prototype_called = true;
		 Chart.prototype.setup = setup;
		 Chart.prototype.setFile = setFile;
	}
	
// properties
	this.server			= "";
	this.connection		= "";
	this.objHTMLElement	= p_objElement;
	this.strXMLFile		= p_strXMLFile;
	this.isVisible		= true;

	function setup(p_strConnection, p_strApplicationServer)
	{
		this.server = p_strApplicationServer;
		this.connection = p_strConnection;
		
		if (p_strXMLFile != "")
			this.setFile(this.strXMLFile);
	}

	function setFile(p_strXMLFile)
	{
		this.strXMLFile = p_strXMLFile;

		var chartApplet = new Applet("ChartApplet", "EfacsChart", "100%", "100%");
		chartApplet.addParam("src", "../Charts/" + this.strXMLFile);
		chartApplet.addParam("connection-string", this.connection);
		chartApplet.addParam("soap-server", this.server);
		chartApplet.addArchive("jarEfacsChart");
		chartApplet.addArchive("chart");
		chartApplet.addArchive("jaxp");
		chartApplet.addArchive("xercesImpl");
		chartApplet.addArchive("xml-apis");
		chartApplet.addArchive("jarexelrpc");
		chartApplet.addArchive("jarEfacsApplet");
		
		this.objHTMLElement.innerHTML = chartApplet.getHTML();
	}
}

/*function Container_hide() {
	this.objHTMLElement.style.display = "none";
	this.isVisible = false;
}

function Container_show() {
	this.objHTMLElement.style.display = "inline";
	this.isVisible = true;
}*/

  
	
function checkMSXMLVersion() {
	var check;
	try {
		check = new ActiveXObject("MSXML2.DOMDocument.3.0");
		return true;
	}
	catch (e) {
		try {
			check = new ActiveXObject("MSXML2.DOMDocument.4.0");
			return true
		}
		catch (e) {}
	}
}

function isAdobeAcrobatInstalled(browser) {
	if (browser == 'ie7' || browser == 'ie8' || browser == 'ie9' || browser == 'ie10' ) {
		try {
			var adobeControl = new ActiveXObject("PDF.PdfCtrl");
			return true;
		} catch(e)
		{}
		try {
			var adobeControl = new ActiveXObject("AcroPDF.PDF");
			return true;
		} catch(e)
		{}

	} else if (browser == 'ns6') {
		return detectplugins("acrobat");
	}
}


// Enumerate and display all installed plug-ins
function detectplugins( pluginType) {
	var plugintype = pluginType
	var pluginName;
	var flgFound = false;
	// refresh plugins in case anything has been changed
	var numPlugins = navigator.plugins.length;

	if (pluginType == "acrobat") {
		pluginName = "Adobe Acrobat";
	}
	for (var i = 0; i < numPlugins; i++)
	{
		var plugin = navigator.plugins[i];
		if (plugin) {
			if (plugin.name == pluginName) {
				flgFound = true
				break;
			}
		}
	}
	return flgFound;
}
	


		function Clipboard() {	

			// Methods
			this.getData = Clipboard_getData;
			this.setData = Clipboard_setData;

		}

		function Clipboard_getData(strDataFormat)
		{
			if (objApplication.browser == APPLICATION_IE)
				return window.clipboardData.getData(strDataFormat);
			else if (objApplication.browser == APPLICATION_NN)
			{
				netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect"); 

				var objClipboard = Components.classes["@mozilla.org/widget/clipboard;1"].createInstance(Components.interfaces.nsIClipboard); 
				
				if (!objClipboard)
					return "";

				var objTransferrable = Components.classes["@mozilla.org/widget/transferable;1"].createInstance(Components.interfaces.nsITransferable);
	
				if (!objTransferrable)
					return "";

				var strDataFlavour;

				if (strDataFormat == "Text" || strDataFormat == null)
					strDataFlavour = "text/unicode";

				objTransferrable.addDataFlavor(strDataFlavour);
				objClipboard.getData(objTransferrable, objClipboard.kGlobalClipboard);

				var objString = new Object();
				var objStringLength = new Object();

				try {
					objTransferrable.getTransferData(strDataFlavour, objString, objStringLength);
				} catch(err) {
					return "";
				}

				if (objString) 
					objString = objString.value.QueryInterface(Components.interfaces.nsISupportsString);
				else
					return "";

				if (objString) 
					return objString.data.substring(0, objStringLength.value / 2);
				else
					return "";
			}
			else
				return "";
		}

		function Clipboard_setData(strDataFormat, strData) 
		{
			if (objApplication.browser == APPLICATION_IE)
				window.clipboardData.setData(strDataFormat, strData);
			else if (objApplication.browser == APPLICATION_NN)
			{
				netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect"); 

				var objString = Components.classes["@mozilla.org/supports-string;1"].createInstance(Components.interfaces.nsISupportsString);

				if (!objString)
					return;

				objString.data = strData;

				var objTransferrable = Components.classes["@mozilla.org/widget/transferable;1"].createInstance(Components.interfaces.nsITransferable);
				
				if (!objTransferrable)
					return;

				var strDataFlavour;
				
				if (strDataFormat == "Text" || strDataFormat == null)
					strDataFlavour = "text/unicode";
					
				objTransferrable.addDataFlavor(strDataFlavour);
				objTransferrable.setTransferData(strDataFlavour, objString, strData.length * 2);

				var objClipboard = Components.classes["@mozilla.org/widget/clipboard;1"].getService(Components.interfaces.nsIClipboard);

				if (!objClipboard)
					return;

				objClipboard.setData(objTransferrable, null, Components.interfaces.nsIClipboard.kGlobalClipboard);
			}
		}



//--------------------------------------------------------------------------------
// Main constructor for "ComboBox" object

function ComboBox(strRef, objForm, objHTMLElement) {
	this.strRef					= strRef;
	this.objForm				= objForm;
	this.listValueOnly			= false;

	this.Captions				= new Array();
	this.Values					= new Array();
	this.lastSelectedValues		= null;

	// Emerald version
	this.addComboItem			= ComboBox_addComboItem;
	this.HTMLElement			= objHTMLElement;
	
	// HTML select version - phasing out - MCB
	this.addItem				= ComboBox_addItem;
	this.removeItem				= ComboBox_removeItem;
	this.HTMLselect				= objForm.getHTMLFieldByRef(strRef);

	this.clear					= ComboBox_clear;

	this.getComboItemValue		= ComboBox_getComboItemValue;
	this.getComboItemCaption	= ComboBox_getComboItemCaption;
	this.destroy				= ComboBox_destroy;
	
	this.objField				= null;
	this.objDiv					= null;
	this.comboFrame				= null; //This iFrame lies behind the combo to prevent the combo from going behind applets
	this.rowHighlightedColour	= "";
	this.rowPointer				= 0;
	this.flgNoRowsInCombo		= false;
	this.setFieldRef			= ComboBox_setFieldRef;
	this.populateFromItemList	= ComboBox_populateFromItemList;
	this.setFocus				= ComboBox_setFocus;
	this.searchForRow			= ComboBox_searchForRow;
	this.highlightRow			= ComboBox_highlightRow;
	this.unhighlightRow			= ComboBox_unhighlightRow;
	this.selectRow				= ComboBox_selectRow;
	this.setSize				= ComboBox_setSize;
	
	this.doBodyClick			= ComboBox_doBodyClick;
	this.doKeyDown				= ComboBox_doKeyDown;
	this.doHighlightOn			= ComboBox_doHighlightOn;
}

function ComboBox_addItem(strCaption, strValue) {
	this.Captions[this.Captions.length] = strCaption;
	this.Values[this.Values.length] = strValue;
	
	var objOption = this.objForm.objWindow.document.createElement("OPTION");
	this.HTMLselect.options.add(objOption);
	objOption.innerHTML = strCaption;
	objOption.value = strValue;
	this.HTMLselect.value = "";
}

function ComboBox_removeItem(strValue) {
	for (var intCtr = 0; intCtr < this.Values.length; intCtr ++)
	{
		if (this.Values[intCtr] == strValue)
		{
			this.HTMLselect.options.remove(intCtr);
			break;
		}
	}
}

/**
 * Clear the combo box
 */
function ComboBox_clear() {

	if (this.HTMLselect.innerHTML != "")
		this.HTMLselect.innerHTML = "";

	if (this.HTMLselect.value != "")
		this.HTMLselect.value = "";
		
	this.Captions = new Array();
	this.Values   = new Array();
}


/**
 * The combo value selected.
 * @param strCaption The value selected from the combo box.
 * @return the value of the caption as defined in the form source.
 */
function ComboBox_getComboItemValue(strCaption) {
	var retVal = null;

	for (var intCtr = 0; intCtr < this.Captions.length; intCtr++) {
		if ((isBlank(String(this.Captions[intCtr])) && String(strCaption) == "&nbsp;") ||
		    (String(this.Captions[intCtr]) == String(strCaption))) {
			retVal = this.Values[intCtr];
			break;
		}
	}
	
	return retVal;
}

function ComboBox_getComboItemCaption(strValue) {
	var retVal = null;
	
	for (var intCtr = 0; intCtr < this.Values.length; intCtr++)
	{
		if (String(this.Values[intCtr]) == String(strValue))
		{
			retVal = this.Captions[intCtr];
			break;
		}
	}
	
	return retVal;
}

function ComboBox_addComboItem(strCaption, strValue) {
	this.Captions[this.Captions.length] = strCaption;
	this.Values[this.Values.length] = strValue;
}


/**
 * Get and set the combo HTML
 * @param objField Field object
 * @param objDiv Div object
 */
function ComboBox_setFieldRef(objField, objDiv) {
	this.rowPointer = 0;
	
	this.objField = objField;
	this.objDiv = objDiv;
	this.comboFrame = this.objForm.objWindow.document.getElementById("ctlComboBoxFrame");
	
	var strHTML;
	
	if (this.objField.isDynamicCombo == true)
		strHTML = this.objField.dynamicComboMethod();
	else if (this.objField.DataEngine != null) {
		this.objField.DataEngine.addXSLTParam("SessionString", objApplication.Connection.strConnectionString);
		strHTML = this.objField.DataEngine.populateEngine();
	}
	else
		strHTML = this.populateFromItemList();
		
	if (objApplication.hadCriticalError) {
		window.parent.objApplication.hadCriticalError = true;
		return;
	}
	else if (window.parent.objApplication.hadCriticalError)	{
		objApplication.hadCriticalError = true;
		return;
	}

	// If user has received handled EFACS error - then exit.
	if (this.objField.DataEngine != null && this.objField.DataEngine.FAILED) {
		window.close();
		return;
	}
	this.objDiv.innerHTML = escapeStringDoubleSpaces(strHTML);

	var rows = this.objForm.objWindow.document.getElementById("comboTable").rows.length
	if (this.objField.DataEngine != null)
		rows -= 1; // Do not count the header
		
	if (rows == 0) {
		//window.document.getElementById("mainDiv").innerHTML = "<DIV id=mainDiv>" +
		this.objDiv.innerHTML = "<DIV id=mainDiv>" +
															"<TABLE width='" + (this.objField.HTMLElement.offsetWidth - 8) + "' id='comboTable' onkeydown='appTrans_doComboOnKeyDown()' cellSpacing='0' cellPadding='0' align='top' name='comboTable'>" +
															"<TBODY onclick='appTrans_doComboBodyClick()' onmouseover='appTrans_doComboHighlightOn()'>" +
															"<TR>" +
															"<TD style='CURSOR: default' noWrap unselectable='on'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>" +
															"</TR>" +
															"<DIV style='DISPLAY: none'><ROWS>0</ROWS></DIV></TBODY></TABLE></DIV>";
		this.flgNoRowsInCombo = true;
	}
	else
		this.flgNoRowsInCombo = false;

	// re-initialise div so as to override the previous sizes
	this.objDiv.style.width = "10px";
	this.objDiv.style.height = "10px";
	this.comboFrame.style.width = "10px";
	this.comboFrame.style.height = "10px";
}

/**
 * Create the HTML that constructs the combo box.
 * @return the combo box HTML.
 */
function ComboBox_populateFromItemList() {
	var strHTML = "<DIV id=mainDiv>" +
				  "<TABLE width='" + (this.objField.HTMLElement.offsetWidth - 8) + "' id='comboTable' onkeydown='appTrans_doComboOnKeyDown()' cellSpacing='0' cellPadding='0' align='top' name='comboTable'>" +
				  "<TBODY onclick='appTrans_doComboBodyClick()' onmouseover='appTrans_doComboHighlightOn()'>";
	
	var intItems = this.Values.length;
	if (intItems == 0) {
		strHTML += "<TR><TD style='CURSOR: default' noWrap unselectable='on'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD></TR>";
	}
	else {
		if (this.objForm.editMode == "filter" && this.objField.isRequiredField() == false) {
			var flgHasBlankItem = false;

			for (var intCtr = 0; intCtr < intItems; intCtr++) {
				strValue = this.Captions[intCtr];
				
				if (isBlank(strValue)) {
					flgHasBlankItem = true;
					break;
				}
			}

			if (flgHasBlankItem == false) {
				for (var i = intItems; i > 0; i--) {
					this.Captions[i] = this.Captions[i - 1];
					this.Values[i] = this.Values[i - 1];
				}

				this.Captions[0] = "";
				this.Values[0] = "";
				intItems++;
			}
		}

		var strValue;
		for (var intCtr = 0; intCtr < intItems; intCtr++) {
			strValue = this.Captions[intCtr];
			
			if (isBlank(strValue))
				strValue = "&#160";
			
			strHTML += "<TR><TD style='CURSOR: default' class='comboRow' noWrap unselectable='on'>" + strValue + "</TD></TR>";
		}
	}
	
	strHTML += "<DIV style='DISPLAY: none'><ROWS>" + intItems + "</ROWS></DIV></TBODY></TABLE></DIV>";
	
	return strHTML
}

/**
 * Set the focus to the combo box div
 */
function ComboBox_setFocus() {

	this.setSize();
	
	try {
		this.objDiv.focus();
	} 
	catch (objError) { }

	if (this.flgNoRowsInCombo)
		return;

	this.highlightRow(window.document.getElementById("comboTable").tBodies[0].rows[0]);
}

/**
 * Size the combo
 */
function ComboBox_setSize() {

	// Need to turn off auto scrolling so that we get the actual height of the combo table HTML.
	// If we dont and auto overflow was set (on the previous use of the combo) then we wont get the expanded length 
	// of the data which we need for the logic below
	this.objDiv.style.overflow = "";
	
	var intCurrentHeight = this.objDiv.offsetHeight;
	var intMaxHeight = window.document.body.offsetHeight / 3;

	if (intCurrentHeight > intMaxHeight)
		intCurrentHeight = intMaxHeight;

	if ((intCurrentHeight + window.document.getElementById("ctlComboBox").offsetTop) > window.document.body.offsetHeight)	{
		this.objDiv.style.posTop = window.document.body.offsetHeight - (intCurrentHeight + 13);
		this.objDiv.style.posLeft = window.document.getElementById("ctlComboBox").offsetLeft - 2;
		this.comboFrame.style.posTop = this.objDiv.style.posTop;
		this.comboFrame.style.posLeft = this.objDiv.style.posLeft;
	}

	var intWidth;
	var frameWidth;
	var objComboTable = window.document.getElementById("comboTable");
	if (objComboTable.offsetHeight > intMaxHeight) {
		this.objDiv.style.overflow = "auto"; // scroll bar required
		intWidth = window.document.getElementById("comboTable").clientWidth + 22;
		frameWidth = intWidth;
	}
	else {
		this.objDiv.style.overflow = ""; // no scroll bar required
		intWidth = window.document.getElementById("comboTable").clientWidth;
		frameWidth = intWidth + 6;
	}
	this.objDiv.style.height = intCurrentHeight;
	this.objDiv.style.width = intWidth;
	this.comboFrame.style.height = intCurrentHeight;
	this.comboFrame.style.width = frameWidth;
}

function ComboBox_searchForRow(strText) {
	var objRows = window.document.getElementById("comboTable").tBodies[0].rows;
	var gotoRow = -1;
	
	for (var intCtr = 0; intCtr < objRows.length; intCtr++) {
		var objRow = objRows[intCtr];
		
		if (String(objRow.cells[0].innerHTML) == String(strText)) {
			gotoRow = intCtr;
			break;
		}
		else if (intCtr < (objRows.length  - 1)) {
			var objNextRow = objRows[intCtr + 1];

			if(String(objRow.cells[0].innerHTML) < String(strText)) {
				if (String(objNextRow.cells[0].innerHTML) > String(strText)) 
				{
					gotoRow = intCtr + 1;
					break;
				}
			} 
			else {
				if (String(objNextRow.cells[0].innerHTML) < String(strText)) {
					gotoRow = intCtr;
					break;
				}
			}
		}
	}
	
	if (gotoRow != -1) {
		this.highlightRow(objRows[gotoRow]);
		objRow.scrollIntoView(true);
	}
}

/**
 * Highlight the row
 * @param objEvent Event object
 */
function ComboBox_doHighlightOn(objEvent) {
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;

	var objCurrentRow = getParentElement(objBrowserEvent, "tr");

	if (objCurrentRow == null)
		return;

	this.highlightRow(objCurrentRow);
}

/**
 * Highlight the row
 * @param objRow Row object
 */
function ComboBox_highlightRow(objRow) {
	// If this is the first time we are setting background colours, use the
	// className attribute to fetch all the background colours we need.
	// Next time we will be able to use the style.background property to set
	// the background colours as this is much faster than changing the class name
	// every highlight/de-highlight.
	if (this.rowHighlightedColour == "") {
		objRow.className = "comboRowHighlight";
		if (objRow.currentStyle) { // TODO: IE only
			this.rowHighlightedColour = objRow.currentStyle.backgroundColor;
		}
		else {
			this.rowHighlightedColour = "blue";
		}
	}
	else {
		objRow.style.backgroundColor = this.rowHighlightedColour;
	}

	if (this.objField.DataEngine != null) {
		if (this.rowPointer != objRow.rowIndex - 1) {
			this.unhighlightRow(window.document.getElementById("comboTable").tBodies[0].rows[this.rowPointer]);
			this.rowPointer = objRow.rowIndex - 1;
		}
	}
	else {
		if (this.rowPointer != objRow.rowIndex) {
			this.unhighlightRow(window.document.getElementById("comboTable").tBodies[0].rows[this.rowPointer]);
			this.rowPointer = objRow.rowIndex;
		}
	}
}

/**
 * Un-highlight the row
 * @param objRow Row object
 */
function ComboBox_unhighlightRow(objRow) {
	if (objRow == null)
		return;

	objRow.style.backgroundColor = "window";
}

/**
 * tbody onclick event function
 * @param objEvent Event object
 */
function ComboBox_doBodyClick(objEvent) {
	var objCurrentRow;
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;

	if (objBrowserEvent.tagName == "TBODY")
		return;
	
	objCurrentRow = getParentElement(objBrowserEvent, "tr");

	if (objCurrentRow == null)
		return;

	this.selectRow(objCurrentRow);
}

/**
 * Populates the emerald field with the selected combo value
 * @param objRow Row object
 */
function ComboBox_selectRow(objRow) {
	this.objDiv.style.display = "none";
	this.comboFrame.style.display = "none";

	if (this.flgNoRowsInCombo == false && objRow.cells.length > 2) {
		var arrSelectedValues = new Array();
		if (this.Values.length == 0) {
			for (var intCtr = 0; intCtr < objRow.cells.length; intCtr += 2)
				arrSelectedValues[arrSelectedValues.length] = objRow.cells[intCtr].innerHTML;
		}
		else {
			for (var intCtr = 0; intCtr < this.Values.length; intCtr ++)
				arrSelectedValues[arrSelectedValues.length] = this.Values[intCtr];
		}

		this.lastSelectedValues = arrSelectedValues;
	}
	else
		this.lastSelectedValues = null;
	
	try {
		this.objField.getHTMLElement().focus();
	}
	catch(error) { }
	
	if (this.flgNoRowsInCombo)
		this.objField.getHTMLElement().value = "";
	else {
		if (this.objField.selectOne && this.Values.length != 0)
			this.objField.getHTMLElement().value = this.getComboItemValue(objRow.cells[0].innerHTML);
		else
			this.objField.getHTMLElement().value = objRow.cells[0].innerHTML;
	}

	this.objField.selectOne.HTMLElement.hasFocus = false;
	
	this.objField.getHTMLElement().fireEvent("onchange");

	if (this.objField != null && this.objForm.userOnChange != null) {
		eval("this.objForm.objWindow." + this.objForm.userOnChange);
	}
}

/**
 * table onkeydown event function
 * @param objEvent Event object
 */
function ComboBox_doKeyDown(objEvent) {
	if (! objEvent) objEvent = window.event;
	var objHTMLRows = window.document.getElementById("comboTable").tBodies[0].rows;

	switch (objEvent.keyCode) {
		case 13: // ENTER KEY
			this.selectRow(objHTMLRows[this.rowPointer]);
			break;
			
		case 27: // ESCAPE
			this.objDiv.style.display = "none";
			this.comboFrame.style.display = "none";
			break;
			
		case 33: // PAGE UP
			break;
			
		case 34: // PAGE DOWN
			break;
			
		case 35: // END
			if (objHTMLRows.length > 0) {
				this.highlightRow(objHTMLRows[objHTMLRows.length - 1]);
				this.objDiv.scrollTop = getOffsetTopFromElement(objHTMLRows[this.rowPointer], "ctlComboBox");
			}
			
			objEvent.returnValue = false;
			objEvent.cancelBubble = true;
			break;
			
		case 36: // HOME
			if (objHTMLRows.length > 0) {
				this.highlightRow(objHTMLRows[0]);
				this.objDiv.scrollTop = getOffsetTopFromElement(objHTMLRows[this.rowPointer], "ctlComboBox");
			}
			
			objEvent.returnValue = false;
			objEvent.cancelBubble = true;
			break;
			
		case 38: // UP ARROW
			if (objHTMLRows.length > 0) {
				if (this.rowPointer > 0)
					this.highlightRow(objHTMLRows[this.rowPointer - 1]);
					
				this.objDiv.scrollTop = getOffsetTopFromElement(objHTMLRows[this.rowPointer], "ctlComboBox");
			}
			
			objEvent.returnValue = false;
			objEvent.cancelBubble = true;
			break;
		
		case 40: // DOWN ARROW
			if (objHTMLRows.length > 0) {
				if (this.rowPointer < objHTMLRows.length - 1)
					this.highlightRow(objHTMLRows[this.rowPointer + 1]);

				this.objDiv.scrollTop = getOffsetTopFromElement(objHTMLRows[this.rowPointer], "ctlComboBox");
			}

			objEvent.returnValue = false;
			objEvent.cancelBubble = true;
			break;
			
		default:
			this.searchForRow(String.fromCharCode(objEvent.keyCode));
			objEvent.returnValue = false;
			objEvent.cancelBubble = true;
			break;
	}
}

/**
 * Clear references for the combo box
 */
function ComboBox_destroy() {
	try {
		this.strRef					= null;
		this.listValueOnly			= null;

		if (this.Captions != null) {
			for (var i = 0, len = this.Captions.length; i < len; i++) {
				this.Captions[i] = null;
				this.Values[i] = null;
			}
		}
		this.Captions				= new Array();	
		this.Values					= new Array();

		if (this.HTMLselect != null) {
			this.HTMLselect.onkeydown = null;
			this.HTMLselect.onkeyup = null;
			this.HTMLselect.onkeypress = null;
			this.HTMLselect.onblur = null;
			this.HTMLselect.onfocus = null;
			this.HTMLselect.oncontextmenu = null;
			this.HTMLselect.onchange = null;
			this.HTMLselect = null;
		}

		this.lastSelectedValues		= null;

		if (this.HTMLElement != null) {
			this.HTMLElement.onclick = null;
			this.HTMLElement.onmousedown = null;
			this.HTMLElement = null;
		}

		this.objField				= null;
		this.objDiv					= null;
		this.comboFrame				= null;
		this.rowHighlightedColour	= "";
		this.rowPointer				= 0;

		this.objForm = null;
	} catch (error) {
	}
}

		

/** 
 * Constructor for the CompanyLicence object
 *
 * @param objWindow The window object.
 * @param objLicenceApplet Reference to the licence applet.
 */
function CompanyLicence(objWindow, objLicenceApplet)
{
// properties
	this.objWindow					= objWindow
	this.licenceApplet				= objLicenceApplet;
	this.strMasterDataSource		= null;
	this.strMasterConnection		= null;
	this.objCompanyXML				= null;
	this.objProductDetailsXML		= null;

// methods
	this.initialise					= CompanyLicence_initialise;
	this.getSessionString			= CompanyLicence_getSessionString;
	this.setupConnection			= CompanyLicence_setupConnection;
	this.changeCompanyConnection	= CompanyLicence_changeCompanyConnection;
	this.setupUserDetails			= CompanyLicence_setupUserDetails;
}

/** 
 * Initialises the company licence object.
 * Determines the master data source.
 */
function CompanyLicence_initialise()
{
	var objXML = objApplication.createXMLDocument();
	objXML.loadURL("../XML/xmlProductDetails.xml", this.objWindow.document.URL);
	this.strMasterDataSource = objXML.documentElement().selectSingleNode("content/product-details/master-datasource").getText();
	this.objProductDetailsXML = objXML;
}

/** 
 * Communicates with the licence applet to request a session string.
 *
 * @param strCompanyId The company id.
 * @param strDBName The database name.
 * @param strDataSource The database data source.
 * @param strLanguageId The user language.
 * @return The requested session string.
 */
function CompanyLicence_getSessionString(strCompanyId, strDBName, strDataSource, strLanguageId)
{
	return this.licenceApplet.getSessionString(strCompanyId, strDBName, strDataSource, strLanguageId, this.strMasterDataSource);
}

/** 
 * Sets up a new database connection for the passed userid.
 *
 * @param strUserId The user id.
 * @param strCompanyId The company id.
 * @param strLanguageId The user language id.
 * @param strLanguageDirectory The language virtual directory name.
 * @param strLanguageName The language name.
 */
function CompanyLicence_setupConnection(strUserId, strCompanyId, strLanguageId, strLanguageDirectory, strLanguageName)
{
	this.strMasterConnection = this.getSessionString(strCompanyId, "efacsmaster", "unknown", strLanguageId);

	var objRPC = new RPCObject("Company", this.objWindow);
	objRPC.execute("load", this.strMasterConnection, strCompanyId);
	this.objCompanyXML = objRPC.getReturnedXMLDom();

	var strConnection = this.getSessionString(strCompanyId,
		this.objCompanyXML.selectSingleNode("/companies/company/dbname/value").getText(), 
		this.objCompanyXML.selectSingleNode("/companies/company/datasource/value").getText(),
		strLanguageId);
	
	// Hold the database case sensitivity against the connection object for use throughout apps.
	objApplication.Connection.databaseSensitivity = objRPC.execute("getCaseSensitivity");

	this.setupUserDetails(strConnection, strUserId, strCompanyId, strLanguageId, strLanguageName, strLanguageDirectory);
}

/** 
 * Internal function to setup the application connection and user objects with
 * the passed session data.
 *
 * @param strConnection The connection string.
 * @param strUserId The user id.
 * @param strCompanyId The company id.
 * @param strLanguageId The user language id.
 * @param strLanguageDirectory The language virtual directory name.
 * @param strLanguageName The language name.
 */
function CompanyLicence_setupUserDetails(strConnection, strUserId, strCompanyId, strLanguageId, strLanguageName, strLanguageDirectory)
{
	objApplication.Connection.setConnectionString(strConnection);

	objApplication.Connection.masterDatabaseServer = this.objCompanyXML.selectSingleNode("/companies/company/dbserver/value").getText();
	
	objApplication.Connection.databaseName = this.objCompanyXML.selectSingleNode("/companies/company/dbname/value").getText();
	objApplication.Connection.applicationServer = this.objCompanyXML.selectSingleNode("/companies/company/appserver/value").getText().toLowerCase();
    objApplication.Connection.earlServer = this.objCompanyXML.selectSingleNode("/companies/company/earlserver/value").getText().toLowerCase();
    objApplication.Connection.dataSource = this.objCompanyXML.selectSingleNode("/companies/company/datasource/value").getText();
	objApplication.Connection.cServer = this.objCompanyXML.selectSingleNode("/companies/company/cserver/value").getText();
	objApplication.Connection.msAnalysisServer = this.objCompanyXML.selectSingleNode("/companies/company/msanalysisserver/value").getText();
	objApplication.Connection.msReportingServer = this.objCompanyXML.selectSingleNode("/companies/company/msreportingserver/value").getText();
	objApplication.Connection.crystalServer = this.objCompanyXML.selectSingleNode("/companies/company/crystalserver/value").getText();
	objApplication.User.userID = strUserId;
	objApplication.User.company = strCompanyId;
	objApplication.User.companyName = this.objCompanyXML.selectSingleNode("/companies/company/name/value").getText();
	objApplication.User.language = strLanguageId;

	objApplication.User.languageName = strLanguageName;
	objApplication.User.languageDirectory = strLanguageDirectory;

	objApplication.connectCClient();

	// fetch the correct currency for this user in this company.
	var objCurrency = new RPCObject("Parameter", this.objWindow);
	objCurrency.execute("load", strConnection, "LEHOMECURR");
	var objCurrencyXML = objCurrency.getReturnedXMLDom();
	objApplication.User.homeCurrency = objCurrencyXML.selectSingleNode("/parameters/parameter/spvalue/value").getText();
}

/** 
 * Changes current user and connection data to point to a new company.
 *
 * @param strCompanyId The company id to which the current user will change to.
 */
function CompanyLicence_changeCompanyConnection(strCompanyId)
{
	var objRPC = new RPCObject("Company", this.objWindow);
	objRPC.execute("load", objApplication.Connection.strConnectionString, strCompanyId);
	this.objCompanyXML = objRPC.getReturnedXMLDom();

	var objRPC = new RPCObject("Licence", this.objWindow);
	var strConnection = objRPC.execute("changeCompanyConnection", objApplication.Connection.strConnectionString, strCompanyId);
	
	this.setupUserDetails(strConnection, objApplication.User.userID, strCompanyId, objApplication.User.language, objApplication.User.languageName, objApplication.User.languageDirectory);
}




function Connection() {

// Properties

	this.objConnectionXML           = null;
	this.strConnectionString 	= null;
	this.SessionString		= null;
	this.masterDatabaseServer	= null;
	this.databaseName		= null;
	this.applicationServer		= null;
	this.earlServer             = null;
	this.msAnalysisServer             = null;
	this.msReportingServer             = null;
	this.crystalServer             = null;
	this.webServerPort             = null;
	this.dataSource             = null;
	this.databaseProvider		= null;
	this.databaseSensitivity	= null;
	this.cServer			= null;
	this.soapClient			= null;		// Cached soap client from applet to be intialised by soap.js
							// the first time it is used.  This will cache service objects
							// automatically in order to speed up soap calls.  NB the service
							// objects contain the parsed WSDL.
	this.rpcCache			= null;		// Cached rpc clients from applet to be intialised by RPCObject.js

// Methods

	this.setConnectionString	= Connection_setConnectionString;
	this.setupFromXML		= Connection_setupFromXML;
}

function Connection_setupFromXML(objXML) {

// Properties

	this.objConnectionXML 		= objXML;

	this.strConnectionString 	= this.objConnectionXML.selectSingleNode("/connectiondata/SessionString").getText();
	this.masterDatabaseServer	= this.objConnectionXML.selectSingleNode("/connectiondata/masterdatabaseserver").getText();
	this.databaseName		= this.objConnectionXML.selectSingleNode("/connectiondata/databasename").getText();
	this.applicationServer		= this.objConnectionXML.selectSingleNode("/connectiondata/applicationserver").getText();
	this.webServerPort = this.objConnectionXML.selectSingleNode("/connectiondata/webserverport").getText();
	this.databaseProvider		= this.objConnectionXML.selectSingleNode("/connectiondata/databaseprovider").getText();
	this.cServer			= this.objConnectionXML.selectSingleNode("/connectiondata/cserver").getText();

// Methods

	this.setConnectionString	= Connection_setConnectionString;
}


function Connection_setConnectionString(strConnection) {
	this.strConnectionString = strConnection;
}

	

// ADAPT constants.
var ADAPT_ONCOLLAPSE = 0x1;
var ADAPT_ONEXPAND = 0x2;
var ADAPT_ONCLOSE = 0x4;

/** 
 * Constructor for the Container object
 *
 * @param objElement The HTML element containing the container.
 * @param p_strTitle The container title
 * @param p_strDirection The container direction - horizontal or vertical.
 * @param p_blnIsVisible Whether the container is visible.
 * @param p_strTooltipExpand The tooltip to expand the container.
 * @param p_strTooltipCollapse The tooltip to collapse the container.
 * @param p_strOnClose The method to call when a container is closed.
 * @param p_strOnExpand The method to call when a container is expanded.
 * @param p_strOnCollapse The method to call when a container is collapsed.
 * @param p_objWindow The window object.
 */
function Container(objElement, p_strTitle, p_strDirection, p_blnIsVisible, p_strTooltipExpand, p_strTooltipCollapse, p_strOnClose, p_strOnExpand, p_strOnCollapse, objWindow) 
{
// properties
	this.objWindow			= objWindow;
	this.objHTMLElement		= objElement;
	this.id					= objElement.id;
	
	this.objHTMLTable       = objElement.getElementsByTagName("TABLE")[0];
	this.strTooltipExpand	= p_strTooltipExpand;
	this.strTooltipCollapse	= p_strTooltipCollapse;
	this.strTitle			= p_strTitle;
	this.strTitleData		= "";
	this.strDirection		= p_strDirection;
	this.isCollapsed		= false;
	this.isVisible			= p_blnIsVisible;
	this.objContent			= eval("document.getElementById(\"" + (objElement.id + "_content") + "\")");
	this.objHeading			= eval("document.getElementById(\"" + (objElement.id + "_heading") + "\")");

	this.objTitle			= window.document.getElementById(objElement.id + "_title");

	this.intOldHeight		= 0;
	this.intOldWidth		= 0;
	this.onClose			= p_strOnClose;
	this.onExpand			= p_strOnExpand;
	this.onCollapse			= p_strOnCollapse;

// methods
	this.toggleState		= Container_toggleState;
	this.collapse			= Container_collapse;
	this.expand				= Container_expand;
	this.hide				= Container_hide;
	this.show				= Container_show;
	this.setTitle			= Container_setTitle;
	this.setTitleData		= Container_setTitleData;
	this.setCollapsible     = Container_setCollapsible;
	this.toXML				= Container_toXML;
	this.performADAPTScript = Container_performADAPTScript;

	if (p_strDirection == "querytabplaceholder") {
        this.ondblclick = "";
	} else if (p_strDirection == "vertical")
        this.ondblclick = objElement.getElementsByTagName("TABLE")[0].ondblclick;
    else
        this.ondblclick = objElement.getElementsByTagName("TD")[0].ondblclick;

	if (p_blnIsVisible == false)
		this.hide(false);
		
	this.destroy = Container_destroy;
}

/** 
 * Used by ADAPT - returns an tree formatted xml representation of this object.
 *
 * @return The tree formatted xml representation of this object.
 */
function Container_toXML()
{
	var strUID = this.id.replace("cc", "");
	
	var strXML = "<node uid='" + strUID + "' level='3'>";
	strXML += "<vals>";
	strXML += "<val id='label'>" + strUID + "</val>";
	strXML += "<val id='name'>" + strUID + "</val>";
	strXML += "<val id='event1' parameter-name='objContainer'>onCollapse</val>";
	strXML += "<val id='event2' parameter-name='objContainer'>onExpand</val>";
	strXML += "<val id='event3' parameter-name='objContainer'>onClose</val>";
	strXML += "</vals>";
	strXML += "</node>";

	return strXML;
}

/* This method allows the developer to programmatically enable/disable
 * the expand/collapse facility of the container.
 *
 * @param flgCollapsible boolean - 'true' if container is collapsible, 'false' if container is not collapsible.
 */
function Container_setCollapsible(flgCollapsible)
{
    var objNode;
    var objNodes = this.objHTMLElement.getElementsByTagName("IMG");

    for (var intCtr = 0; intCtr < objNodes.length; intCtr ++)
    {
        var objNode = objNodes.item(intCtr)

        if (objNode.src.indexOf("Arrow") != -1)
        {
            if (flgCollapsible)
            {
                this.objHTMLTable.ondblclick = this.ondblclick;

                objNode.style.visibility = "visible";
            }
            else
            {
                this.objHTMLTable.ondblclick = "";

                objNode.style.visibility = "hidden";
            }

            break;
        }
    }
}

// This method allows the developer to programmatically collapse the container.
function Container_collapse(flgDoResize)
{
	// Suppress the container "contents" section of the control from the display.
	this.objContent.style.display = "none";

	if (this.strDirection == "vertical") {
		Container_setIcon(this.objHTMLElement, "../GIF/gifArrowDown.gif", this.strTooltipExpand);
		this.intOldHeight = this.objHTMLElement.style.height;
		this.objHTMLElement.style.height = "1px";
		this.objHeading.className = "ContainerHeading";
	}
	else {
		Container_setIcon(this.objHTMLElement, "../GIF/gifArrowRight.gif", this.strTooltipExpand);
		this.intOldWidth = this.objHTMLElement.style.width;
		this.objHTMLElement.style.width = "13px";
		this.objHeading.className = "ContainerHeading";
	}

	this.isCollapsed = true;

	if (this.onCollapse != null && this.isVisible)
		eval(this.onCollapse + ";");

	if (flgDoResize != false)
		localResize();

	// Persist the state of this container.
	if (this.objHTMLElement.id != null && this.objHTMLElement.id != "")
	{
		if (this.isCollapsed)
			objApplication.PersistentXML.setPersistentTag(objApplication.appID + "_ContainerState_" + this.objHTMLElement.id, "collapsed", m_strComponentId);
		else
			objApplication.PersistentXML.setPersistentTag(objApplication.appID + "_ContainerState_" + this.objHTMLElement.id, "expanded", m_strComponentId);
	}
}

function Container_expand(flgDoResize)
{
	// Expose the container "contents" section of the control.
	this.objContent.style.display = "inline";

	if (this.strDirection == "vertical") {
		Container_setIcon(this.objHTMLElement, "../GIF/gifArrowUp.gif", this.strTooltipCollapse);
		this.objHTMLElement.style.height = this.intOldHeight;
		this.objHeading.className = "ContainerHorizontalHeadingExpand";
	}
	else {
		Container_setIcon(this.objHTMLElement, "../GIF/gifArrowLeft.gif", this.strTooltipCollapse);
		this.objHTMLElement.style.width = this.intOldWidth;
		this.objHeading.className = "ContainerVerticalHeadingExpand";
	}

	this.isCollapsed = false;

	if (flgDoResize != false)
	{
		if (this.onExpand != null && this.isVisible)
			eval(this.onExpand + ";");

		localResize();
	}
	
	// Persist the state of this container.
	if (this.objHTMLElement.id != null && this.objHTMLElement.id != "")
	{
		if (this.isCollapsed)
			objApplication.PersistentXML.setPersistentTag(objApplication.appID + "_ContainerState_" + this.objHTMLElement.id, "collapsed", m_strComponentId);
		else
			objApplication.PersistentXML.setPersistentTag(objApplication.appID + "_ContainerState_" + this.objHTMLElement.id, "expanded", m_strComponentId);
	}
}

// The following two methods allow the actual container to be hidden / made visible.
function Container_hide(flgDoResize)
{
	if (this.objHTMLElement.parentNode.children == 1 && this.objHTMLElement.parentNode.parentNode.className == "control-wrapper")
		this.objHTMLElement.parentNode.parentNode.style.display = "none";
	else
		this.objHTMLElement.style.display = "none";

	this.isVisible = false;

	if (flgDoResize != false)
	{
		if (this.onClose != null)
			eval(this.onClose + ";");

		localResize();
	}
	
	this.performADAPTScript(ADAPT_ONCLOSE);
}

function Container_show(flgDoResize)
{
	if (this.objHTMLElement.parentNode.children == 1 && this.objHTMLElement.parentNode.parentNode.className == "control-wrapper")
		this.objHTMLElement.parentNode.parentNode.style.display = "inline";
	else
		this.objHTMLElement.style.display = "inline";

	this.isVisible = true;

	if (flgDoResize != false)
		localResize();
}

// This method is called from the container when the user clicks on the graphic that
// indicates that the control can be expanded/collapsed.
function Container_toggleState()
{
	if (this.isCollapsed == true)
	{
		this.expand();
		this.performADAPTScript(ADAPT_ONEXPAND);
	}
	else
	{
		this.collapse();
		this.performADAPTScript(ADAPT_ONCOLLAPSE);
	}
}

function Container_setTitle(p_strTitle) {
	this.strTitle = p_strTitle;

	Container_writeTitle(this);
}

function Container_setTitleData(p_strTitleData) {
	this.strTitleData = p_strTitleData;

	Container_writeTitle(this);
}

function Container_writeTitle(objContainer) {
	objContainer.objTitle.innerHTML = objContainer.strTitle;
	if (objContainer.strTitleData != "")
		objContainer.objTitle.innerHTML += " : " + objContainer.strTitleData;
}

// -------------------------- PRIVATE FUNCTIONS USED INTERNALLY BY THIS OBJECT --------------------
// The following methods (which shoud not be used exernally resets the icon and tooltip of the container.
function Container_setIcon(objContainer, strFileName, strTooltip) {
	var objNode;

	objNodes = objContainer.getElementsByTagName("IMG");

	for (var intCtr=0; intCtr < objNodes.length; intCtr++)
	{
		var objNode = objNodes.item(intCtr)

		if (objNode.src.indexOf("Arrow") != -1)
		{
			objNode.src = strFileName;
			objNode.title = strTooltip;
			break;
		}
	}
}

/** 
 * Fires any attached ADAPT javascript.
 *
 * @param flgEventType Binary operator parameter determines which event to fire.
 * @return Returns false if the adapt javascript decided to cancel the event.
 */
function Container_performADAPTScript(flgEventType)
{
	var strMethodName;

	if (flgEventType & ADAPT_ONEXPAND) {
		strMethodName = this.id.replace("cc", "") + "_onExpand";
	} else if (flgEventType & ADAPT_ONCOLLAPSE) {
		strMethodName = this.id.replace("cc", "") + "_onCollapse";
	} else if (flgEventType & ADAPT_ONCLOSE) {
		strMethodName = this.id.replace("cc", "") + "_onClose";
	} else {
		alert("Container event type not supported");
	}
	
	if (typeof(strMethodName) != "undefined" && this.objWindow[strMethodName] != null) {
		if (this.objWindow[strMethodName](this) == false) {
			return false;
		}
	}
	
	return true;
}

/**
 * Clear references for the container object
 */
function Container_destroy() {
	try {	
		if (this.objHTMLTable != null) {
			this.objHTMLTable.ondblclick = null;
			if (this.objHTMLTable.children != null && this.objHTMLTable.children[0] != null) {
				if (this.objHTMLTable.children[0].rows != null && this.objHTMLTable.children[0].rows[0] != null) {
					if (this.objHTMLTable.children[0].rows[0].cells != null) {
						for (var i = 0, len = this.objHTMLTable.children[0].rows[0].cells.length; i < len; i++) {
							if (this.objHTMLTable.children[0].rows[0].cells[i].children != null && this.objHTMLTable.children[0].rows[0].cells[i].children[0] != null) {
								this.objHTMLTable.children[0].rows[0].cells[i].children[0].onkeypress = null;
								this.objHTMLTable.children[0].rows[0].cells[i].children[0].onclick = null;
							}
						}
					}
				}
			}
			this.objHTMLTable = null;
		}

		this.objContent			= null;
		this.objHeading			= null;
		this.objTitle			= null;
		this.ondblclick 		= null;
		if (this.objWindow != null && this.objWindow.document != null && this.objWindow.document.body != null) {
			this.objWindow.document.body.onclick = null;
			this.objWindow.document.body.onfocus = null;
			this.objWindow.document.body.onblur = null;
			this.objWindow.document.body.onmousedown = null;
			this.objWindow.document.body.onmouseup = null;
			this.objWindow.document.body.onmouseover = null;
			this.objWindow.document.body.onkeypress = null;
			this.objWindow.document.body.onkeydown = null;
			this.objWindow.document.body.onkeyup = null;
			this.objWindow.document.body.ondblclick = null;
			this.objWindow.document.body.onresize = null;
			this.objWindow.document.body.ondragover = null;
			this.objWindow.document.body.onbeforeunload = null;
			this.objWindow.document.body.onload = null;
			this.objWindow.document.body.onunload = null;
		}
		this.objWindow = null;		
		this.objHTMLElement		= null;
		this.id					= null;
	} catch (error) {
	}
}



var m_CMNormalHighlight = null;
var m_CMNormalHighlightBorder = null;
var m_CMToggleHover = null;
var m_CMToggleHoverBorder = null;
var m_CMToggleFilter = null;
var m_CMToggleFilterBorder = null;

// Object to handle events and to check 
var ContextMenuHandler = {
	idPrefix		: "CONTEXT_MENU",
	idCounter		: -1,
	initialised		: 0,
	initialise		: function (cascadeLevel) {
						if (this.initialised == 0 ) {
							addEvent(document.body, "onmousedown", function () { document.getElementById("ContextMenuElement1").style.display = 'none'; });
							addEvent(document.body, "oncontextmenu", this.eventOnContextMenu);
							this.initialised = 1;
						}
						else  {
							addEvent(document.body, "onmousedown", function () { document.getElementById("ContextMenuElement" + cascadeLevel).style.display = 'none'; });
							addEvent(document.body, "oncontextmenu", this.eventOnContextMenu);
						}
				  },
	menus			: {},
	reset			: function () { this.idCounter = -1; this.menus = {}; },
	getId			: function () { return this.idPrefix + ++this.idCounter; },
	addMenu			: function (menu, cascadeLevel) {
						if (typeof(cascadeLevel) == "undefined")
							cascadeLevel = "1";
							
						this.initialise(cascadeLevel);
						menu.id = this.getId();
						menu.idNumber = this.idCounter;
						menu.srcElement = document.getElementById("ContextMenuElement" + cascadeLevel);

						this.menus[this.idCounter] = menu;
				  },
	eventOnContextMenu	: function(event) {
					// Find the context menu for this element
					contextMenu = ContextMenuHandler.findContextMenu(event.srcElement);
					if (contextMenu) {
						contextMenu.show(getPosX(event), getPosY(event));
					}
					return false;
				  },
	findContextMenu		: function(element) {
					// Iterate through the parent elements
					// until we find an element with
					// contextmenuid set
					currentElement = element;
					while (currentElement != null) {
						if (currentElement.contextmenu)
							return currentElement.contextmenu;
						currentElement = currentElement.parentNode;
					}
				  }
};

function ContextMenu(cascadeLevel) {
	this.options = new Array();
	ContextMenuHandler.addMenu(this, cascadeLevel);
}

ContextMenu.prototype.addToElement = function (srcElement) {
	srcElement.contextmenu = this;
	srcElement.contextmenuid = this.id;
};

/**
 * Allows an option to be added to the context menu
 * @param text The text
 * @param icon The icon
 * @param action The method to be called
 * @param params The parameters to be passed to the action
 * @param flgDisabled Whether the button should be disabled
 * @param tooltip The tooltip
 * @param actionObject The action object
 * @param flgToggle Whether the button on the toolbar is a toggle button
 * @param strToolbarid The corresponding toolbar
 * @param strButtonid The id of the corresponding toolbar button
 */
ContextMenu.prototype.addOption = function (text, icon, action, params, 
	CTIType, topContextLabel, parentContextLabel, flgCascading, cascadeLevel, 
	flgDisabled, tooltip, actionObject, flgToggle, strToolbarid, strButtonid) {

	this.options[this.options.length] = new ContextMenuOption(this, text, icon, action, params, 
		CTIType, topContextLabel, parentContextLabel, flgCascading, cascadeLevel, 
		flgDisabled, tooltip, actionObject, flgToggle, strToolbarid, strButtonid);
};

ContextMenu.prototype.generateHTML = function () 
{
	var strHTML = "<table class='ContextMenuTable' unselectable='on' cellspacing='0' cellpadding='0' oncontextmenu='return false';>";
	
	for (var intCtr = 0; intCtr < this.options.length; intCtr++) {
		strHTML += this.options[intCtr].generateHTML();
	}
	
	strHTML += "</table>";
	
	return strHTML;
};
ContextMenu.prototype.move = function (x, y) {
					// srcElement is set to the IFRAME containing the menu
					element = this.srcElement;
					
					// Check that the frame lies within the page
					var doch = document.body.clientHeight;
					var dh = element.offsetHeight + y - doch;
					if (dh > 0) {
						// The element will run off the page
						element.style.top = y - dh + "px";
					} else {
						element.style.top = y + "px";
					}
					
					var docw = document.body.clientWidth;
					var dw = element.offsetWidth + x - docw;
					if (dw > 0) {
						// The element will run off the page
						element.style.left = window.option.parent.srcElement.offsetLeft - element.offsetWidth + "px";
					} else {
						element.style.left = x + "px";
					}
				  },
	
ContextMenu.prototype.resize = function (cascadeLevel) {
	var frame = window.frames["ContextMenuElement" + cascadeLevel];
	var body = frame.document.body;
	var element = this.srcElement;
 	
	element.style.width = "10px";  // This this so that it does not end up too wide - too thin and the height goes wierd
	//element.style.height = "100000px"; // I don't think this is needed
	
	// Sometimes the height is wrong call this 2x to make sure it is correct
	var h = body.scrollHeight;
	var w = body.scrollWidth;
	// Real calculations
	h = body.scrollHeight + element.offsetHeight - body.clientHeight;
	w = body.scrollWidth + element.offsetWidth - body.clientWidth;
	element.style.height = h + "px";
	element.style.width = w + "px";
};

ContextMenu.prototype.show = function (x, y, cascadeLevel) {
	if (typeof(cascadeLevel) == "undefined")
		cascadeLevel = "1";
	
	window.frames["ContextMenuElement" + cascadeLevel].document.body.innerHTML = this.generateHTML();
	// Set style to display
	// Should display before move to position or height is always zero and we cannot work out if it is partly off the screen
	document.getElementById("ContextMenuElement" + cascadeLevel).style.display = "block";
	
	// Set height and width
	if (objApplication.browser == APPLICATION_IE) // Netscape doesn't like this?
		this.resize(cascadeLevel);

	// Move to position
	this.move(x, y);
};

ContextMenu.prototype.hide = function (cascadeLevel) {
	if (typeof(cascadeLevel) == "undefined" || cascadeLevel == "1") {
		document.getElementById("ContextMenuElement1").style.display = "none";
		document.getElementById("ContextMenuElement2").style.display = "none";
		document.getElementById("ContextMenuElement3").style.display = "none";
	}
	else if (cascadeLevel == 2) {
		document.getElementById("ContextMenuElement2").style.display = "none";
		document.getElementById("ContextMenuElement3").style.display = "none";
	}
};

var ContextMenuOptionHandler = {
	idPrefix		: "CONTEXT_MENU_OPTION",
	idCounter		: -1,
	initialised		: 0,
	options			: {},
	initialise		: function () {
						if (this.initialised == 0) {
							this.initialised = 1;
							window.cmoh = this;
						}
					  },
	eventOnClick	: function (element) {
						option = this.findOption(element);
						if (option)
							option.onClick(element);
					  },
	clearCascade	: function (element) {
						// loop through the contextmenu elements (at this level) and unhighlight any cascading options
						var objOptions = this.findOption(element).parent.options;
						for (var x = 0; x < objOptions.length; x++) {
							if (objOptions[x].cascading == true) {
								objOptions[x].firedCascading = false;
								objOptions[x].parent.hide(2);
								var objTR = element.parentElement.children[x];
								Toolbar_mouseout_cascading(objTR);
							}
						}
					  },
	addOption		: function (option) {
						this.initialise();
						option.id = this.getId();
						option.idNumber = this.idCounter;
						this.options[option.idNumber] = option;
					  },
	getId			: function () { return this.idPrefix + ++this.idCounter; },
	findOption		: function(element) {
						// Iterate through the parent elements
						// until we find an element with
						// optionid set
						return this.options[element.children[0].id.replace(this.idPrefix, "")];
					  }
};

/**
 * Creates a context menu option
 * @param parent The context menu
 * @param text The text
 * @param icon The icon
 * @param action The method to be called
 * @param params The parameters to be passed to the action
 * @param flgDisabled Whether the button should be disabled
 * @param tooltip The tooltip
 * @param actionObject The action object
 * @param flgToggle Whether the button on the toolbar is a toggle button
 * @param strToolbarid The corresponding toolbar
 * @param strButtonid The id of the corresponding toolbar button
 */
function ContextMenuOption(parent, text, icon, action, params, 
	CTIType, topContextLabel, parentContextLabel, flgCascading, cascadeLevel, flgDisabled, tooltip, 
	actionObject, flgToggle, strToolbarid, strButtonid) {
	this.text = text;
	this.icon = icon;
	this.action = action;
	this.actionObject = actionObject;
	this.parent = parent;
	this.params = params;
	if (flgDisabled == true)
		this.disabled = true;
	else
		this.disabled = false;			// disabled is false by default - i.e. if it is null or not true.
	this.tooltip = tooltip;
	if (flgToggle == "true")
		this.flgToggle = true;
	else
		this.flgToggle = false;
	this.strToolbarid = strToolbarid;
	this.strButtonid = strButtonid;
	
	this.CTIType = CTIType;
	this.cascading = flgCascading;
	if (topContextLabel == null)
		this.topContextLabel = text;
	else
		this.topContextLabel = topContextLabel;
	this.parentContextLabel = parentContextLabel;
	this.firedCascading = false;
	this.cascadeLevel = cascadeLevel;
	
	ContextMenuOptionHandler.addOption(this);
};

ContextMenuOption.prototype.clearFiredFlag = function () {
	var objOptions = this.parent.options;
	
	for (var x = 0; x < objOptions.length; x++) {
		if (this.id == objOptions[x].id)
			continue;
		objOptions[x].firedCascading = false;
	}
};

ContextMenuOption.prototype.cascadingHighlight = function (obj) {
	var objOptions = this.parent.options;
	var objTRs = obj.parentElement.getElementsByTagName("TR");

	for (var x = 0; x < objOptions.length; x++) {
		if (objOptions[x].cascading)
			Toolbar_mouseout_cascading(objTRs[x]);
	}

	// Change the class so that onmouseout will not remove the highlight
	Toolbar_mouseover_cascading(obj);
};

ContextMenuOption.prototype.generateHTML = function () 
{
	var toggledStr = "";
	var classStr = "";

	if (this.text == "--------")
		return "<tr><td colspan='3'><hr style='margin-left:4px; margin-right:5px'></hr></td></tr>";

	if (this.flgToggle == true) {
		var objToolbar = eval(this.strToolbarid);
		var objButton = objToolbar.getButton(this.strButtonid);
		if (objButton.HTMLElement.toggled == true) {
			toggledStr = " toggled=true";
			classStr = " class='toolbar-toggle-button'";
			classLeftStr = " class='toolbar-toggle-button-left'";
			classMiddleStr = " class='toolbar-toggle-button-middle'";
			classRightStr = " class='toolbar-toggle-button-right'";
		}
		else {
			toggledStr = " toggled=false";
			classStr = " class='toolbar-button'";
			classLeftStr = "";
			classMiddleStr = "";
			classRightStr = "";
		}	
	} 
	else {
		toggledStr = " toggled=false";
		classStr = " class='toolbar-button'";
		classLeftStr = "";
		classMiddleStr = "";
		classRightStr = "";
	}
	
	var retVal = "<tr" + classStr + toggledStr;
	retVal += " onkeypress='if (event.keyCode == 32) this.click();'";
	retVal += " onmouseover='Toolbar_mouseover(this);";
	
	if (this.cascading == true)
		retVal += "window.parent.cmoh.eventOnClick(this);'";
	else {
		retVal += "window.parent.cmoh.clearCascade(this);'";
		if (typeof(this.tooltip) != "undefined" && ! isBlank(this.tooltip))
			retVal += " title='" + this.tooltip + "'";
	}
	retVal += " onmouseout='Toolbar_mouseout(this)'";
	retVal += " onmousedown='window.parent.cmoh.eventOnClick(this);'";
	if (this.disabled)
		retVal += " disabled='true'";
	retVal += ">";
	
	retVal += " <td" + classLeftStr + " unselectable='on' tabIndex='1' nowrap='true' id='" + this.id + "'>";
	retVal += "<img class='toolbar-button-image' align='absmiddle' src='";
	
	if (this.icon != null && this.icon != "") {
		if (this.icon == "New") {
			retVal += "../Sapphire_PNG/New_Blank_Document_16_n_p.png";
		} else if (this.icon == "Open") {
			retVal += "../Sapphire_PNG/Folder_Open_Oblique_16_n_p.png";
		} else if (this.icon == "Ok") {
			retVal += "../Sapphire_PNG/Green_Checkmark_16_n_p.png";
		} else if (this.icon == "Copy") {
			retVal += "../Sapphire_PNG/Copy_16_n_p.png";
		} else if (this.icon == "Cancel") {
			retVal += "../Sapphire_PNG/Red_Delete_16_n_p.png";
		} else if (this.icon == "Delete") {
			retVal += "../Sapphire_PNG/Blue_Delete_16_n_p.png";
		} else if (this.icon == "Remove") {
			retVal += "../Sapphire_PNG/Blue_Delete_16_n_p.png";
		} else if (this.icon == "Refresh") {
			retVal += "../Sapphire_PNG/Refresh_16_n_p.png";
		} else if (this.icon == "Search") {
			retVal += "../Sapphire_PNG/Search_16_n_p.png";
		} else if (this.icon == "Import") {
			retVal += "../Sapphire_PNG/Forward_Task_16_n_p.png";
		} else if (this.icon == "eNotes") {
			retVal += "../Sapphire_PNG/Pen_and_Document_16_n_p.png";
		} else if (this.icon == "InfoPanel") {
			retVal += "../Sapphire_PNG/Info_Bubble_16_n_p.png";
		} else {
			retVal += "../GIF/gif" + this.icon + ".gif";
		}
	}
	else
		retVal += "../GIF/giftreeviewblank.gif";
	retVal += "'/></td>";
	
	retVal += "<td" + classMiddleStr + " unselectable='on' nowrap='true'>";
	retVal += "<label unselectable='on'>" + this.text + "</label>";
	retVal += "</td>";
	
	retVal += "<td" + classRightStr + " unselectable='on' nowrap='true'>";
	if (this.cascading)
		retVal += "<img align='absmiddle' src='../GIF/gifcascadingexpand.gif'/>";
	else
		retVal += "<img align='absmiddle' src='../GIF/giftreeviewblank.gif'/>";
	retVal += "</td>";
	
	retVal += "</tr>";

	return retVal;
};

/**
 * Calls the appropriate method when the context menu option is clicked
 * toggling the state of the toolbar button if it is a toggle button.
 */
ContextMenuOption.prototype.onClick = function () {
	if (this.cascading == true) {
		var cascading = false;
		var CTIType;
		var traderID;
		var contactID;
		var contextType;
		var icon = null;
					
		if (this.firedCascading == true) {
			// onmouseover calls this event for cascading context options and so we dont want to keep executing 
			// the method that populates the sub context menu constantly whilst the mouse is over the option 
			return;
		}

		// switch off fired flag for all other cascading contexts (at this level) otherwise hovering over a 
		// different cascading context that has already fired will just return here and so not display its 
		// sub context menu
		this.clearFiredFlag();
					
		this.cascadingHighlight(arguments[0]);
		
		if (this.params.length == 2)
			contextType = "FORM"; // Form context menu
		else
			contextType = "GRID"; // Grid context menu
				
		switch (this.CTIType) {
			case "TRADER":
			case "CUSTOMER":
			case "SUPPLIER":
			case "SITE":
				cascading = true;
				this.parent.hide(this.cascadeLevel + 1);
				if (contextType == "FORM") {
					traderID = this.params[1].getValue();
					if (this.CTIType == "TRADER") {
						this.CTIType = getCTIObject().getActualCTITypeByContextType("TRADER", "FORM", this.params[1]);
						if (this.CTIType == null)
							return;
					}
				}
				else {
					traderID = this.params[0];
					if (this.CTIType == "TRADER") {
						this.CTIType = getCTIObject().getActualCTITypeByContextType("TRADER", "GRID", this.params[2]);
						if (this.CTIType == null)
							return;
					}
				}
				
				icon = "contact";
					
				CTIType = this.CTIType == "CUSTOMER" ? "CUSTOMERCONTACT" : this.CTIType == "SUPPLIER" ? "SUPPLIERCONTACT" : "SITECONTACT";
				break;
				
			case "CONTACT":
			case "CUSTOMERCONTACT":
			case "SUPPLIERCONTACT":
			case "SITECONTACT":
				if (this.cascadeLevel == 1) {
					if (contextType == "FORM") {
						traderID = this.params[1].objForm.getFieldByRef("traderid").getValue();
						contactID = this.params[1].getValue();
						if (this.CTIType == "CONTACT") {
							this.CTIType = getCTIObject().getActualCTITypeByContextType("CONTACT", "FORM", this.params[1]);
							if (this.CTIType == null)
								return;
						}
					}
					else {
						traderID = this.params[2].getSelectedColumnValue("traderid")[0];
						contactID = this.params[0];
						if (this.CTIType == "CONTACT") {
							this.CTIType = getCTIObject().getActualCTITypeByContextType("CONTACT", "GRID", this.params[2]);
							if (this.CTIType == null)
								return;
						}
					}
				}
				else {
					if (contextType == "FORM")
						traderID = this.params[1].getValue();
					else
						traderID = this.params[2].getSelectedColumnValue(this.params[3])[0];
					contactID = this.params[0];
				}
				
				icon = "calldial";
				
				CTIType = this.CTIType == "CUSTOMERCONTACT" ? "CUSTOMERCONTACTNUMBERS" : this.CTIType == "SUPPLIERCONTACT" ? "SUPPLIERCONTACTNUMBERS" : "SITECONTACTNUMBERS";
				break;
				
			default:
				return eMsgBox("Invalid CTI type for context menu", vbOK, msg_Critical, window);
		}

		var arrValues = getCTIObject().getCTIContextMenuOptionsForType(traderID, contactID, this.CTIType);

		if (arrValues.length != 0) {
			var contextMenu = new ContextMenu(this.cascadeLevel + 1);
			
			for (var x = 0; x < arrValues.length; x++) {
				if (contextType == "FORM")
					contextMenu.addOption(arrValues[x][0], icon, this.action, new Array(arrValues[x][0], this.params[1]), CTIType, this.topContextLabel, this.text, cascading, this.cascadeLevel + 1, false, arrValues[x][1]);
				else
					contextMenu.addOption(arrValues[x][0], icon, this.action, new Array(arrValues[x][0], this.params[1], this.params[2], this.params[3]), CTIType, this.topContextLabel, this.text, cascading, this.cascadeLevel + 1, false, arrValues[x][1]);
			}
			
			var x = window.option.parent.srcElement.offsetLeft + window.option.parent.srcElement.offsetWidth;
			var y = window.option.parent.srcElement.offsetTop + arguments[0].offsetTop;

			contextMenu.show(x, y, this.cascadeLevel + 1);
		}
		
		this.firedCascading = true;
		
		return;
	}
	else
		this.parent.hide();
		
	if (this.actionObject == null)
		this.action(this);
	else
		this.action.call(this.actionObject, this);

	// If this is a toggle button need to update the actual button status
	if (this.flgToggle == true) {
		var objToolbar = eval(this.strToolbarid);
		var objButton = objToolbar.getButton(this.strButtonid);
		objButton.toggle();
	}
};



// Bean parameter types
var DE_FORMPARAM = 0x1;
var DE_METHODPARAM = 0x2;
var DE_VARIABLEPARAM = 0x4;
var DE_VALUEPARAM = 0x8;
var DE_GRIDPARAM = 0x10;

function DataEngine(engineID, objWindow)
{
	this.objWindow				= objWindow;
	if (this.objWindow == null)
		this.objWindow = window;

	this.populateEngine			= DataEngine_populateEngine;
	this.extractXML				= DataEngine_extractXML;
	this.moveNext				= DataEngine_moveNext;
	this.moveLast				= DataEngine_moveLast;
	this.movePrevious			= DataEngine_movePrevious;
	this.moveFirst				= DataEngine_moveFirst;
	this.clearInputParameters	= DataEngine_clearInputParameters;
	this.addInputParameter		= DataEngine_addInputParameter;
	this.addXSLTParam			= DataEngine_addXSLTParam;
	this.calculatePageSize		= DataEngine_calculatePageSize;
	this.caseSensitive			= false;

	this.arrXSLTParamNames		= new Array();
	this.arrXSLTParamValues		= new Array();

	this.arrBeanParams		= new Array();
	this.strFilterXML			= "";
	this.addBeanParameter		= DataEngine_addBeanParameter;
	this.clearBeanParameters	= DataEngine_clearBeanParameters;
	this.beanParametersXML		= DataEngine_beanParametersXML;
	this.createParameterColumnXML	= DataEngine_createParameterColumnXML;
	this.setup      			= DataEngine_setup;
	this.setupForSQL			= DataEngine_setupForSQL;
	this.setupForClass			= DataEngine_setupForClass;
	this.destroy				= DataEngine_destroy;
	
	this.id 					= engineID;
	this.type					= "";
	this.xsltScript				= "";
	this.pageSize				= 0;
	this.currentPage			= 0;
	this.numberOfPages			= 0;
	this.numberOfRows			= 0;
	this.useMaster				= false;
	this.additionalXML			= "";
	this.standardTransform	= true;

	this.showDataEngineErrors	= true;
	this.FAILED					= false;
	
	// SQL section
	this.sqlCommand				= "";
	this.sqlOrderBy				= "";
	this.sqlGroupBy				= "";
	this.sqlCriteria			= "";
	this.sqlOriginalCriteria	= null;
	
	// Object section
	this.objectURI				= "";
	this.objectName				= "";
	this.objectMethod			= "";
	
	// XML section
	this.xmlData				= "";
	this.xmlDOM					= "";
	this.xmlSource				= "";
	
	// Class section
	this.className				= "";
	this.classMethod			= "";
}

function DataEngine_addXSLTParam(strName, strValue)
{
	for (var i = 0; i < this.arrXSLTParamNames.length; i++) {
		if (this.arrXSLTParamNames[i] == strName) {
			this.arrXSLTParamValues[i] = strValue;
			return;
		}
	}
	this.arrXSLTParamNames[this.arrXSLTParamNames.length] = strName;
	this.arrXSLTParamValues[this.arrXSLTParamValues.length] = strValue;
}

function DataEngine_populateEngine() 
{
	this.currentPage = 1;
	return this.extractXML();
}

function DataEngine_extractXML()
{
	var strXML;
	var urlconnection;
	var parameters;
	var xsltDoc;

	this.FAILED = false;
	
	if (this.xsltScript == "") {
		xsltDoc = "";
	}
	else {
		xsltDoc = "http://" + objApplication.Connection.applicationServer + "/efacs/English/XSLT/" + this.xsltScript;
	}
	
	var filter = "<input>" + this.strFilterXML + this.beanParametersXML() + "</input>";
	
	switch (String(this.type)) {
		case "object":
			break;
			
		case "xml":
			break;
		
		case "sql":
			urlconnection = "http://" + objApplication.Connection.applicationServer + "/earl/servlet/dataengine";

			var strXSLTParamXML = "<xslt-params>";
			for (var intCtr = 0; intCtr < this.arrXSLTParamNames.length; intCtr++)
			{
				if (this.arrXSLTParamNames[intCtr] == "baseURL")
					this.arrXSLTParamValues[intCtr] = this.arrXSLTParamValues[intCtr].substring(0, this.arrXSLTParamValues[intCtr].indexOf(".html") + 5);
				
				strXSLTParamXML += "<xslt-param><name>" + this.arrXSLTParamNames[intCtr] + "</name><value>" + this.arrXSLTParamValues[intCtr] + "</value></xslt-param>";
			}
			strXSLTParamXML += "</xslt-params>";

			parameters = "sessionstring=" + replaceForURL(b64Encode(objApplication.Connection.strConnectionString)) + 
						 "&sql=" + replaceForURL(b64Encode(this.sqlCommand)) + 
						 "&boundparameters=" + replaceForURL(b64Encode(filter)) + 
						 "&whereclause=" + replaceForURL(b64Encode(this.sqlCriteria)) + 
						 "&mode=" + replaceForURL(b64Encode(this.type)) + 
						 "&orderby=" + replaceForURL(b64Encode(this.sqlOrderBy)) + 
						 "&casesensitive=" + replaceForURL(b64Encode(this.caseSensitive == true ? "true" : "false")) + 
						 "&groupby=" + replaceForURL(b64Encode(this.sqlGroupBy)) + 
						 "&transformationscript=" + replaceForURL(b64Encode(xsltDoc)) + 
						 "&numberofrows=" + replaceForURL(b64Encode("" + this.pageSize)) + 
						 "&startfromrow=" + replaceForURL(b64Encode("" + ((this.currentPage - 1) * this.pageSize))) + 
						 "&usemaster=" + replaceForURL(b64Encode(this.useMaster == true ? "true" : "false")) + 
						 "&xsltParams=" + replaceForURL(b64Encode(strXSLTParamXML)) +
						 "&localeid=" + replaceForURL(b64Encode(objApplication.User.localeid)) +
						 "&regionalsettings=" + replaceForURL(b64Encode("http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/XML/xmlRegionalSettings.xml")); 

			try {
				strXML = objApplication.EfacsApplet.post(urlconnection, parameters);

				if (strXML.indexOf("<error") != -1)
				{
					this.FAILED = true;
					showEfacsError(strXML, this.objWindow, this.showDataEngineErrors);
				}
				else if (xsltDoc == "")
					this.calculatePageSize(strXML, "<rows>", "</rows>");
			} catch (error) {
				this.FAILED = true;
				showEfacsError(error, this.objWindow, this.showDataEngineErrors);
			}

			break;

		case "class":

			urlconnection = "http://" + objApplication.Connection.applicationServer + "/earl/servlet/dataengine";
			parameters = "sessionstring=" + replaceForURL(b64Encode(objApplication.Connection.strConnectionString)) + 
			   		     "&classname=" + replaceForURL(b64Encode(this.className)) + 
						 "&classmethod=" + replaceForURL(b64Encode(this.classMethod)) + 
						 "&standardTransform=" + replaceForURL(b64Encode(this.standardTransform == true ? "true" : "false")) + 
						 "&boundparameters=" + replaceForURL(b64Encode(filter)) + 
						 "&mode=" + replaceForURL(b64Encode(this.type)) + 
						 "&casesensitive=" + replaceForURL(b64Encode(this.caseSensitive == true ? "true" : "false")) + 
						 "&transformationscript=" + replaceForURL(b64Encode(xsltDoc)) + 
						 "&numberofrows=" + replaceForURL(b64Encode("" + this.pageSize)) + 
						 "&startfromrow=" + replaceForURL(b64Encode("" + ((this.currentPage - 1) * this.pageSize))) + 
						 "&usemaster=" + replaceForURL(b64Encode(this.useMaster == true ? "true" : "false")) +
						 "&localeid=" + replaceForURL(b64Encode(objApplication.User.localeid)) +
						 "&regionalsettings=" + replaceForURL(b64Encode("http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/XML/xmlRegionalSettings.xml")); 
			
			var strXSLTParamXML = "<xslt-params>";
			for (var intCtr = 0; intCtr < this.arrXSLTParamNames.length; intCtr++)
			{
				if (this.arrXSLTParamNames[intCtr] == "baseURL")
					this.arrXSLTParamValues[intCtr] = this.arrXSLTParamValues[intCtr].substring(0, this.arrXSLTParamValues[intCtr].indexOf(".html") + 5);
				
				strXSLTParamXML += "<xslt-param><name>" + this.arrXSLTParamNames[intCtr] + "</name><value>" + this.arrXSLTParamValues[intCtr] + "</value></xslt-param>";
			}
			strXSLTParamXML += "</xslt-params>";

			parameters += "&xsltParams=" + replaceForURL(b64Encode(strXSLTParamXML));
			
			try {
				strXML = objApplication.EfacsApplet.post(urlconnection, parameters);

				if (strXML.indexOf("<error") != -1)
				{
					this.FAILED = true;
					showEfacsError(strXML, this.objWindow, this.showDataEngineErrors);
				}
				else if (xsltDoc == "")
					this.calculatePageSize(strXML, "<rows>", "</rows>");
			} catch (error) {
				this.FAILED = true;
				showEfacsError(error, this.objWindow, this.showDataEngineErrors);
			}

			break;
		
	}

	return strXML; 
}

/** Create the parameters XML for the bean parameters
 * @return the XML for the column filter.
 */
function DataEngine_beanParametersXML()
{
	if (this.arrBeanParams.length == 0)
		return "";

	var strBeanParamXML = "";

	for (var intCtr = 0; intCtr < this.arrBeanParams.length; intCtr++)
	{
		var strValue = "";
		objBeanParam = this.arrBeanParams[intCtr];

		var strDataType = null;
		if (!isBlank(objBeanParam.dataType))
			strDataType = objBeanParam.dataType;

		if (objBeanParam.formID != null)
			strValue = String(objApplication.Forms(objBeanParam.formID).getFieldByRef(objBeanParam.fieldRef).getValue());
		else if (objBeanParam.gridID != null) {
			var objGrid = objApplication.Grids(objBeanParam.gridID);
			if (objGrid.isTreeGrid && objGrid.Tree.loadingNode != null) {
				strValue = objGrid.Tree.loadingNode.getColumnValue(objBeanParam.fieldRef);
			} else {
				var arrValues = objGrid.getSelectedColumnValue(objBeanParam.fieldRef);
				if (arrValues.length == 0) {
					strValue = "";
				} else {
					strValue = String(arrValues[0]);
				}
			}
		} else if (objBeanParam.methodName != null)
			strValue = String(eval(objBeanParam.methodName));
		else if (objBeanParam.variableName != null)
			strValue = String(eval(objBeanParam.variableName));
		else if (objBeanParam.value != null)
			strValue = String(objBeanParam.value);

		strBeanParamXML += this.createParameterColumnXML(strValue, null, objBeanParam.dbColumn, strDataType, null);
	}

	return strBeanParamXML;
}

function DataEngine_moveNext() 
{
	if (this.currentPage < this.numberOfPages) {
		this.currentPage++;
		return this.extractXML();
	}
	else
		return "";
}

function DataEngine_movePrevious() 
{
	if (this.currentPage > 1) {
		this.currentPage--;
		return this.extractXML();
	}
	else
		return "";
}

function DataEngine_moveFirst() 
{
	if (this.currentPage != 1) {
		this.currentPage = 1;
		return this.extractXML();
	}
	else
		return "";
}

function DataEngine_moveLast() 
{
	if (this.currentPage != this.numberOfPages) {
		this.currentPage = this.numberOfPages;
		return this.extractXML();
	}
	else
		return "";
}

function DataEngine_clearInputParameters(strPredefinedInput) 
{
	if (typeof(strPredefinedInput) == "undefined") {	
		this.strFilterXML = "";
	}

	if (strPredefinedInput != null) {
		this.strFilterXML = strPredefinedInput;
	}
}

function DataEngine_calculatePageSize(strXML, startSearch, endSearch)
{
	var startIndex = strXML.indexOf(startSearch) + startSearch.length; 

	if (startIndex == -1) {
		this.numberOfRows = 0;
		this.numberOfPages = 0;
	}
	else {
		this.numberOfRows = strXML.substring(startIndex, strXML.indexOf(endSearch, startIndex));
		
		if (this.numberOfRows == 0) {
			this.numberOfPages = 0;
			this.currentPage = 0;
		}
		else {
			this.numberOfPages = parseInt(parseInt(this.numberOfRows) / parseInt(this.pageSize)) + 
								(parseInt(parseInt(this.numberOfRows) % parseInt(this.pageSize)) > 0 ? 1 : 0);
		}
	}
}

function DataEngine_addInputParameter(ID, value, table, column, type, IsDateFormat)
{
	this.strFilterXML += this.createParameterColumnXML(value, table, column, type, IsDateFormat);

	return this.strFilterXML;
}

/** Create string XML node for a column filter.
 * @param strValue The value to filter by
 * @param strTable The table to filter on.
 * @param strColumn The column to filter on.
 * @param IsDateFormat If the this is a date formatted column or not.
 */
function DataEngine_createParameterColumnXML(strValue, strTable, strColumn, strType, IsDateFormat) {
	return "<column"
			+ (strTable == null ? "" : " table=\"" + strTable + "\"")
			+ (strType == null ? "" : " type=\"" + strType + "\"")
			+ (strColumn == null ? "" : " ref=\"" + strColumn + "\"")
			+ (IsDateFormat == null ? "" : " isdateformat=\"" + IsDateFormat + "\"")
			+ ">" + escapeXML(strValue) + "</column>";
}

function DataEngine_addBeanParameter(flgParamType)
{
	var objBeanParam = new DEBeanParameter();
	
	if (flgParamType & DE_FORMPARAM)
	{
		objBeanParam.formID = arguments[1];
		objBeanParam.fieldRef = arguments[2];
		objBeanParam.dataType = arguments[3];
		objBeanParam.dbColumn = arguments[4];
	}
	else if (flgParamType & DE_METHODPARAM)
	{
		objBeanParam.methodName = arguments[1];
		objBeanParam.dataType = arguments[2];
		objBeanParam.dbColumn = arguments[3];
	}
	else if (flgParamType & DE_VARIABLEPARAM)
	{
		objBeanParam.variableName = arguments[1];
		objBeanParam.dataType = arguments[2];
		objBeanParam.dbColumn = arguments[3];
	}
	else if (flgParamType & DE_VALUEPARAM)
	{
		objBeanParam.value = arguments[1];
		objBeanParam.dataType = arguments[2];
		objBeanParam.dbColumn = arguments[3];
	}
	else if (flgParamType & DE_GRIDPARAM)
	{
		objBeanParam.gridID = arguments[1];
		objBeanParam.fieldRef = arguments[2];
		objBeanParam.dataType = arguments[3];
		objBeanParam.dbColumn = arguments[4];
	}

	if (isBlank(objBeanParam.dataType))
		objBeanParam.dataType = "xsd:string";

	this.arrBeanParams[this.arrBeanParams.length] = objBeanParam;
}

function DataEngine_clearBeanParameters() {
	this.arrBeanParams = new Array();
}

// Constructor for BeanParameter
function DEBeanParameter()
{
	this.gridID = null;
	this.formID = null;
	this.fieldRef = null;
	this.methodName = null;
	this.variableName = null;
	this.value = null;
	this.dataType = null;
	this.dbColumn = null;
	this.destroy = DEBeanParameter_destroy;
}

/**
 * Clear references for bean parameters
 */
function DEBeanParameter_destroy() {
	this.gridID = null;
	this.formID = null;
	this.fieldRef = null;
	this.methodName = null;
	this.variableName = null;
	this.value = null;
	this.dataType = null;
	this.dbColumn = null;
}

/** Setup the data engine
 * @param blnUseMaster Use master DB?
 * @param strType The type - should be SQL
 * @param strXSLT The name of the XSLT script or blank
 */
function DataEngine_setup(blnUseMaster, strType, strXSLT) {
	this.useMaster = blnUseMaster;
	this.type = strType;
	this.xsltScript = strXSLT;
}
/** Setup for SQL loading
 * @param blnUseMaster Use master DB?
 * @param strType The type - should be SQL
 * @param strXSLT The name of the XSLT script or blank
 * @param strSqlCommand The command
 * @param strSqlCriteria The criteria
 * @param strSqlGroupBy The group by
 * @param strSqlOrderBy The order by
 */
function DataEngine_setupForSQL(blnUseMaster, strType, strXSLT, strSqlCommand, strSqlCriteria, strSqlGroupBy, strSqlOrderBy) {
	this.setup(blnUseMaster, strType, strXSLT);
	this.sqlCommand = strSqlCommand;
	this.sqlCriteria = strSqlCriteria;
	this.sqlGroupBy = strSqlGroupBy;
	this.sqlOrderBy = strSqlOrderBy;
}
/** Setup for SQL loading
 * @param blnUseMaster Use master DB?
 * @param strType The type - should be class
 * @param strXSLT The name of the XSLT script or blank
 * @param strClassName The data source class
 * @param strClassMethod The method on the class
 */
function DataEngine_setupForClass(blnUseMaster, strType, strXSLT, strClassName, strClassMethod) {
	this.setup(blnUseMaster, strType, strXSLT);
	this.className = strClassName;
	this.classMethod = strClassMethod;
}

/**
 * Clear references for the data engine object
 */
function DataEngine_destroy() {

	try {
		if (this.objWindow != null && this.objWindow.document != null && this.objWindow.document.body != null) {
			this.objWindow.document.body.onclick = null;
			this.objWindow.document.body.onfocus = null;
			this.objWindow.document.body.onblur = null;
			this.objWindow.document.body.onmousedown = null;
			this.objWindow.document.body.onmouseup = null;
			this.objWindow.document.body.onmouseover = null;
			this.objWindow.document.body.onkeypress = null;
			this.objWindow.document.body.onkeydown = null;
			this.objWindow.document.body.onkeyup = null;
		}
		this.objWindow = null;
	} catch (error) {
	}
}


/**
 * Main constructor for "Debug" object
 *
 * @param objWindow Reference to the window object we are debugging.
 */
function Debug(objWindow)
{
	// Properties
	this.doDebug			= false;
	this.objWindow			= objWindow;
	this.startTime			= null;
	this.lastTime			= null;
	this.fileName			= null;
	this.fso				= null;
	this.textStream			= null;
	this.openElements			= new Array();  // Array of open element names so we can close them
	this.currentElement		= -1;  // index into openElements
	
	// Methods
	this.initialise			= Debug_inititialise;
	this.writeMessage			= Debug_writeMessage;
	this.writeTime			= Debug_writeTime;
	this.writeMessageArray		= Debug_writeMessageArray;
	this.startWindow			= Debug_startWindow;
	this.startElement			= Debug_startElement;
	this.writeAttributes		= Debug_writeAttributes;
	this.endElement			= Debug_endElement;
	this.writeText			= Debug_writeText;
	this.viewDebug			= Debug_viewDebug;
}

/**
 * Initialise Debug class. Determines whether debugging is active.
 * Checks debugpath exists - creates it if required.
 * Attempts to load existing debug for this app - creates a new DOM
 * if this app hasn't been debugged before.
 */
function Debug_inititialise()
{
	var strDebugPath;
	var strTargetName;

	if (ParseStringFromURL("debugmode", this.objWindow.document.URL) == "true") {
		this.doDebug = true;
		strDebugPath = unescape(ParseStringFromURL("debugpath", this.objWindow.document.URL));
		strTargetName = this.objWindow.document.URL.substring(this.objWindow.document.URL.lastIndexOf("/") + 1, this.objWindow.document.URL.indexOf("?") - 5)
	}
	else {
		if (this.objWindow.opener != null) {
			if (ParseStringFromURL("debugmode", this.objWindow.opener.document.URL) == "true") {
				this.doDebug = true;
				strDebugPath = unescape(ParseStringFromURL("debugpath", this.objWindow.opener.document.URL));
				strTargetName = this.objWindow.document.URL.substring(this.objWindow.document.URL.lastIndexOf("/") + 1, this.objWindow.document.URL.indexOf("?") - 5)
			}
			else {
				return;
			}
		}
		else {
			return;
		}
	}

	var objEfacsCalendar=objApplication.getCalendarParser();
	this.startTime=objEfacsCalendar.getDateTimeInMilliseconds();
	this.lastTime=this.startTime;

	this.fso = new ActiveXObject("Scripting.FileSystemObject");
	if (!this.fso.FolderExists(strDebugPath))
		this.fso.CreateFolder(strDebugPath);

	this.fileName = strDebugPath + "\\" + objApplication.description + "_" + strTargetName + "_" + this.startTime + " Debug.xml";

	this.textStream = this.fso.CreateTextFile(this.fileName);

	this.startElement("debug");

	this.startElement("application", "server=" + objApplication.Connection.applicationServer,
									 "company=" + objApplication.User.companyName,
									 "language=" + objApplication.User.languageName);
}

/**
 * Resets startTime and lastTime for a new window opening.
 */
function Debug_startWindow(objWindow)
{
	if (this.doDebug == false)
		return;

	var objEfacsCalendar=objApplication.getCalendarParser();

	this.startTime=objEfacsCalendar.getDateTimeInMilliseconds();
	this.lastTime=this.startTime;

	this.startElement("window", 
			"name=" + objApplication.getWindowFileName(objWindow.document.URL),
			"date=" + objEfacsCalendar.getDateTimeInLocaleFormat());
}

/**
 * Writes a plain message with optional attributes to the debug DOM.
 * 
 * @param arguments Variable amount of over loaded arguments containing the 
 *        message to write to the debug DOM including any attributes to be set.
 */
function Debug_writeMessage()
{
	if (this.doDebug == false)
		return;

	var arrParameters = new Array();
	for (var i = 0; i < arguments.length; i++) {
		arrParameters[i] = arguments[i];
	}
	this.writeMessageArray(arrParameters);
}

/**
 * Writes a message with optional attributes to the debug DOM and stamps it with currentTime - lastTime.
 * 
 * @param arguments Variable amount of over loaded arguments containing the 
 *        message to write to the debug DOM including any attributes to be set.
 */
function Debug_writeTime()
{
	if (this.doDebug == false)
		return;

	var objEfacsCalendar=objApplication.getCalendarParser();

	var arrArgs = new Array();
	arrArgs[0] = arguments[0];
	arrArgs[1] = "time=" + leftPadWithChar(objEfacsCalendar.getDateTimeInMilliseconds() - this.lastTime, 4, "0");

	for (var intCtr = 1; intCtr < arguments.length; intCtr++)
		arrArgs[intCtr + 1] = arguments[intCtr];
		
	this.writeMessageArray(arrArgs);

	this.lastTime=objEfacsCalendar.setCurrentDateTime().getTime();
}

/**
 * Writes a plain message with optional attributes to the debug DOM.
 * 
 * @param arrParameters The message to write to the debug DOM including any attributes to be set.
 */
function Debug_writeMessageArray(arrParameters)
{
	if (this.doDebug == false || this.textStream == null)
		return;

	// Call startElement with the attributes
	this.textStream.Write("<message");

	// Write all parameters after 1st as attributes
	this.writeAttributes(arrParameters.slice(1));

	this.textStream.Write(">");	

	// Write 1st parameter as the message text
	this.writeText(arrParameters[0]);

	// End the element
	this.textStream.WriteLine("</message>");
}

/**
 * Starts a new child node in the debug DOM.
 * 
 * @param strElement The name of the child node to create on the DOM.
 */
function Debug_startElement(strElement)
{
	if (this.doDebug == false)
		return;

	// Remember the current element for use in endElement
	this.currentElement++;
	this.openElements[this.currentElement] = strElement;

	this.textStream.Write("<" + strElement);
	
	// first parameter is the element name slice the rest for arguments
	var arrParameters = new Array();
	for (var i = 1; i < arguments.length; i++) {
		arrParameters[i - 1] = arguments[i];
	}
	this.writeAttributes(arrParameters);

	this.textStream.WriteLine(">");
}

/**
 * Write a set of attributes
 * @param arrAttributes the attributes
 */
function Debug_writeAttributes(arrAttributes) {
	// If any extra arguments passed then set them as attributes.
	for (var intCtr = 0; intCtr < arrAttributes.length; intCtr++)
	{
		var arrAttribute = arrAttributes[intCtr].split("=");
		this.textStream.Write(" " + arrAttribute[0]+ "=\"" + arrAttribute[1] + "\"");
	}
}

/**
 * Ends a child node in the debug DOM.
 */
function Debug_endElement()
{
	if (this.doDebug == false)
		return;

	this.textStream.WriteLine("</" + this.openElements[this.currentElement] + ">");
	this.currentElement--;
}

/**
 * Write some text into the current element
 * @param strText The text
 */
function Debug_writeText(strText)
{
	if (this.doDebug == false)
		return;

	this.textStream.Write(strText);
}

/**
 * Saves the debug DOM to the debug path and opens the debug window
 * to the user.
 */
function Debug_viewDebug()
{
	if (this.doDebug == false)
		return;

	// End all elements
	while (this.currentElement >= 0) {
		this.endElement();
	}
	// Clear up
	this.textStream.Close();
	this.textStream = null;
	this.openElements = new Array();

	// to automatically view do this
	// this.objWindow.open(this.fileName, "debug");
}




function Dict() 
{
	this.Lookups = new Array();

	// Set up class members once only...
 	if (typeof(_dict_prototype_called) == 'undefined') 
	{
		_dict_prototype_called   = true;
		Dict.prototype.add       = add;
		Dict.prototype.getString = getString;
	}

	function add(p_strID, p_strString) 
	{
		this.Lookups[this.Lookups.length] = new LookupString(p_strID, p_strString);
	}

	function getString(p_strID) 
	{
		for (var n = 0; n < this.Lookups.length; n++)
		{
			if (this.Lookups[n].strID == p_strID)
				return this.Lookups[n].strString;
		}
		
		return p_strID;
	}

	// Constructor for simple 2 string object...
	function LookupString(p_strID, p_strString) 
	{
		this.strID     = p_strID;
		this.strString = p_strString;
	}
}


/**
 * Constructor for the Document Manager object.
 * This is used for dynamic document management
 * @param id The id for this manager
 * @param tabDialog The ID of the tabbed dialog to which the document management tab is being added
 */			
function DocumentManager(id, tabDialog)
{
	this.id	= id;
	this.tabbedDialogID = tabDialog;
	this.parentEditWindowManager = null;
	this.tablename 		= null; 	// The parent table for which documents are being saved
	this.documentKeys 	= null; 	// Stored on a load and used for the save
	
	this.loadDocuments 		= dm_loadDocuments;
	this.newDocument 		= dm_newDocument;
	this.openDocument 		= dm_openDocument;
	this.showImage 			= dm_showImage;
	this.removeReference 	= dm_removeReference;
	this.togglePreview 		= dm_togglePreview;
	this.clickPreview		= dm_clickPreview;
	this.popOutWindow		= dm_popOutWindow;
	this.checkin			= dm_checkin;
	this.checkout			= dm_checkout;
	this.showHistory		= dm_showHistory;
	this.hasPermission 		= dm_hasPermission;
	this.galleryChange		= dm_galleryChange;
	this.destroy			= dm_destroy;
}

/**
 * Loads all the documents based on the key information for the record
 * @param AppWindow The application window object
 * @param flgNoPreviewToggle Whether the status of the preview panel should be toggled
 */
function dm_loadDocuments(AppWindow, flgNoPreviewToggle)
{
	if (this.parentEditWindowManager == null)
		this.parentEditWindowManager = eval(this.tabbedDialogID).EditWindowManager;
		
	if (this.parentEditWindowManager == null)
		return; //Not managed by an edit window manager
		
	var objEditWindow = this.parentEditWindowManager.getEditWindow(AppWindow);

	// Load documents for specified primary key.
	var arrKeys = new Array();
	var arrValues = new Array();
	var arrDataTypes = new Array();
	
	for (var i = 0; i < 6; i++)
	{
		arrKeys[i] = "";
		arrValues[i] = "";
		arrDataTypes[i] = "";
	}

	for (var n = 0, fieldsLen = objEditWindow.Form.fields.length; n < fieldsLen; n++) 
	{
		var objField = objEditWindow.Form.fields[n];
		if (objField.HTMLElement.isprimary == "true" && !isBlank(objField.HTMLElement.primarykeyno) && objField.HTMLElement.schemaField == "true"){

			if (isBlank(this.tablename))
				this.tablename = objField.HTMLElement.strTable;
		
			arrKeys[objField.HTMLElement.primarykeyno-1] = objField.strRef;
			arrValues[objField.HTMLElement.primarykeyno-1] = objField.getValue();
			arrDataTypes[objField.HTMLElement.primarykeyno-1] = objField.strDataType;
		}	
	}

	var strXML = "<keys>";
	for (var i = 0; i < 6; i++)
	{
		if (!isBlank(arrKeys[i]))
			strXML += "<key pos='" + i + "' ref='" + arrKeys[i] + "' value='" + arrValues[i] + "' datatype='" + arrDataTypes[i] + "'/>";
		else
			break;
	} 
	strXML += "</keys>";

	this.documentKeys = strXML;	
	var objQuery = objEditWindow.Form.tabbedDialog.documentQuery;
	objQuery.dataEngine.clearInputParameters();	
	objQuery.dataEngine.addInputParameter("PM0", this.tablename, null, null, "xsd:string");
	objQuery.dataEngine.addInputParameter("PM1" , strXML, null, null, "xsd:string");

	objQuery.search(false);
	var objImageContainer = eval("ccdocImage" + this.tabbedDialogID);
	var objTextEditorContainer = eval("ccdocEnotes" + this.tabbedDialogID);
	if ((objImageContainer.isVisible || objTextEditorContainer.isVisible) && !flgNoPreviewToggle)
		this.togglePreview();
	this.showImage(true);
	localResize();
}

/**
 * Allows a new document to be added
 * @param AppWindow The application window object
 */
function dm_newDocument(AppWindow)
{
	var objImageContainer = eval("ccdocImage" + this.tabbedDialogID);
	var objTextEditorContainer = eval("ccdocEnotes" + this.tabbedDialogID);

	if(objImageContainer.isVisible || objTextEditorContainer.isVisible)
		this.clickPreview();

	var objEditWindow = this.parentEditWindowManager.getEditWindow(AppWindow);
	var objEWM = objEditWindow.Form.tabbedDialog.documentEWM;		

	var strURL = "&selTabID=" + objEditWindow.Form.tabbedDialog.id;
	strURL += "&docsMode=AutoDocs";
    objEWM.openChildWindow("add", window, "", strURL);
}

/**
 * Opens the specified document 
 * @param AppWindow The application window object
 */
function dm_openDocument(AppWindow)
{
	var objImageContainer = eval("ccdocImage" + this.tabbedDialogID);
	var objTextEditorContainer = eval("ccdocEnotes" + this.tabbedDialogID);

	if(objImageContainer.isVisible || objTextEditorContainer.isVisible)
		this.clickPreview();

	if (!this.hasPermission("read"))
	{
		eMsgBox(fl("NOACCESS"), vbOKOnly, msg_Information, window);
		return;
	}

	var objEditWindow = this.parentEditWindowManager.getEditWindow(AppWindow);
	var objGrid = objEditWindow.Form.tabbedDialog.documentQuery.Grid;
	var objEWM = objEditWindow.Form.tabbedDialog.documentEWM;		
	
	var strURL = "&selTabID=" + objEditWindow.Form.tabbedDialog.id;
	strURL += "&docsMode=AutoDocs";
	objEWM.openChildWindow("update", window, objGrid.getSelectedColumnValue("uniqueid")[0], strURL);
}

/**
 * Populates the preview container with the document or enotes
 * @param flgClear If true clears the current preview window
 */
function dm_showImage(flgClear)
{
	var objGrid = eval(this.tabbedDialogID).documentQuery.Grid;

	var flgDisabled;
	if (objGrid.getSelectedColumnValue("uniqueid").length != 0)
		flgDisabled = false;
	else
		flgDisabled = true;
				
	document.getElementById("tlb" + this.tabbedDialogID + "_btnDocumentOpen").disabled = flgDisabled;
	document.getElementById("tlb" + this.tabbedDialogID + "_btnDocumentRefRemove").disabled = flgDisabled;
	
	if (objGrid.getSelectedColumnValue("documentformat")[0] != "eNotes")
	{
		document.getElementById("tlb" + this.tabbedDialogID + "_btnDocumentCheckin").disabled = flgDisabled;
		document.getElementById("tlb" + this.tabbedDialogID + "_btnDocumentCheckout").disabled = flgDisabled;
		document.getElementById("tlb" + this.tabbedDialogID + "_btnDocumentHistory").disabled = flgDisabled;
	}
	else
	{
		document.getElementById("tlb" + this.tabbedDialogID + "_btnDocumentCheckin").disabled = true;
		document.getElementById("tlb" + this.tabbedDialogID + "_btnDocumentCheckout").disabled = true;
		document.getElementById("tlb" + this.tabbedDialogID + "_btnDocumentHistory").disabled = true;
	}

	var objImageContainer = eval("ccdocImage" + this.tabbedDialogID);
	var objTextEditorContainer = eval("ccdocEnotes" + this.tabbedDialogID);

	window.document.getElementById(objImageContainer.id + "imgPopOut").title = fl("POPOUTDOC");
	window.document.getElementById(objTextEditorContainer.id + "imgPopOut").title = fl("POPOUTDOC");

	if (!objImageContainer.isVisible && !objTextEditorContainer.isVisible)
		return;

	if (!flgClear && !this.hasPermission("read"))
	{
		eMsgBox(fl("NOACCESS"), vbOKOnly, msg_Information, window);
		flgDisabled = true;
	}

	if (!flgDisabled) {
		document.getElementById("ccdocImageView" + this.tabbedDialogID).src = "";
		
		if (objGrid.getSelectedColumnValue("documentformat")[0] != "eNotes") 
		{
			objImageContainer.show();
			objTextEditorContainer.hide();

			var div = eval("divDocServletImageView" + this.tabbedDialogID)

			div.innerHTML = "<form id=\"frmDocServletImageView\" name=\"frmDocServletImageView\" "+
										"action=\"http://" + objApplication.Connection.applicationServer + "/efacs/servlet/DocumentServlet\" " +
										"target=\"ccdocImageView" + this.tabbedDialogID + "\" method=\"POST\">" +
											"<input type=\"hidden\" name=\"sessionstring\" id=\"sessionstring\" value=\"" + objApplication.Connection.strConnectionString + "\" />" +
											"<input type=\"hidden\" name=\"documentid\" id=\"documentid\" value=\"" + objGrid.getSelectedColumnValue("documentid")[0] + "\" />" +
											"<input type=\"hidden\" name=\"mimetype\" id=\"mimetype\" value=\"" + objGrid.getSelectedColumnValue("mimetype")[0] + "\" />" +
										"</form>";
			
			frmDocServletImageView.submit();
		}
		else
		{
			objImageContainer.hide();
			var objTextEditor = eval("txtEditorView" + this.tabbedDialogID);

			if (objTextEditor.flgLoaded == false)
			{ 
				objTextEditor.initialise();
				objTextEditor.hideEditModeToolbar();

				// Get rid of the extra black line
				var strElementName = "txtEditorView" + this.tabbedDialogID + "cmbTextType";
				var objElement = eval("txtEditorView" + this.tabbedDialogID + ".objWindow.document.getElementById(\"" + strElementName + "\")");
				objElement.parentNode.parentNode.parentNode.style.display = "none";
			}

		    var objRPCObject = new RPCObject("DocumentRegister");
		    objRPCObject.execute("Load", objApplication.Connection.strConnectionString, objGrid.getSelectedColumnValue("documentid")[0]);
	    	if (objRPCObject.FAILED)
				return;
			var objXML = objRPCObject.getReturnedXMLDom();
			objTextEditor.setNotesText(b64Decode(objXML.selectSingleNode("/documentregisters/documentregister/content/value").getText()));
			objTextEditorContainer.show();
		}
	} 
	else
	{
		// Nothing selected so ensure preview containers are blank.
		if (objImageContainer.objHTMLElement.style.display == "inline") {
			objTextEditorContainer.objHTMLElement.style.display = "none";
			document.getElementById("ccdocImageView" + this.tabbedDialogID).src = "../HTML/htmBlankDocument.htm";
		}
		if (objTextEditorContainer.objHTMLElement.style.display == "inline")
		{
			objImageContainer.objHTMLElement.style.display = "none";
			var objTextEditor = eval("txtEditorView" + this.tabbedDialogID);
			if (objTextEditor != null)
			{
				try
				{
					objTextEditor.setNotesText("");
				} 
				catch (error)
				{
				}
			}
		}
	}
}

/**
 * Removes a document reference (NB this does not remove
 * the underlying document.)
 * @param AppWindow The application window object
 */	
function dm_removeReference(AppWindow)
{
	if (eMsgBox(fl("REMOVESELECTEDITEMS"), vbYesNo, msg_Exclamation, AppWindow) == vbYes)
	{
		var objEditWindow = this.parentEditWindowManager.getEditWindow(AppWindow);
		var objGrid = objEditWindow.Form.tabbedDialog.documentQuery.Grid;
		var objEWM = objEditWindow.Form.tabbedDialog.documentEWM;		
	
		objEWM.removeOpenWindows(objGrid.getSelectedColumnValue("uniqueid"))
	
	    var objRPCObject = new RPCObject("DocumentRegister");
	    var flgSuccess = objRPCObject.execute("removeReference", objApplication.Connection.strConnectionString, this.tablename, objGrid.getSelectedColumnValue("documentid")[0]);
	
		if (objRPCObject.FAILED)
			return;
	    
	    // If the reference has been successfully removed, refresh the grid.
	    if (flgSuccess == "true")
			this.loadDocuments(AppWindow, true);
	}
}

/**
 * Toggle the preview panels
 */
function dm_togglePreview() {

	var objImageContainer = eval("ccdocImage" + this.tabbedDialogID);
	var objTextEditorContainer = eval("ccdocEnotes" + this.tabbedDialogID);
	var objToolbar = eval("tlb" + this.tabbedDialogID);

	if(objImageContainer.isVisible || objTextEditorContainer.isVisible)
	{
		objImageContainer.hide();
		objTextEditorContainer.hide();
	} 
	else
	{
		var objGrid = eval(this.tabbedDialogID).documentQuery.Grid;
		
		if (isBlank(objGrid.getSelectedColumnValue("uniqueid")[0])) {
			objImageContainer.show();
			objTextEditorContainer.show();
			this.showImage(true);
			return;
		}

		if (!this.hasPermission("read"))
		{
			eMsgBox(fl("NOACCESS"), vbOKOnly, msg_Information, window);
			return;
		}

		objImageContainer.show();
		objTextEditorContainer.show();
		this.showImage();
	}
}

/**
 * Gives the same behaviour as if the preview button has been clicked.
 */
function dm_clickPreview() {
	var objToolbar = eval("tlb" + this.tabbedDialogID);
	var objButton = objToolbar.getButton("tlb" + this.tabbedDialogID + "_btnPreview");
	objButton.toggle();
	this.togglePreview();
}

/**
 * Opens a document in a new window.
 */
function dm_popOutWindow()
{
	var objGrid = eval(this.tabbedDialogID).documentQuery.Grid;
	if (isBlank(objGrid.getSelectedColumnValue("documentid")[0]))
		return;
	
	if (!this.hasPermission("read"))
	{
		eMsgBox(fl("NOACCESS"), vbOKOnly, msg_Information, window);
		return;
	}
	
	var strURL = "../Applications_HTML/appDocumentView.html";
	strURL += "?docID=" + replaceForURL(b64Encode(objGrid.getSelectedColumnValue("documentid")[0]));
	strURL += "&mimeType=" + replaceForURL(b64Encode(objGrid.getSelectedColumnValue("mimetype")[0]));
	strURL += "&documentFormat=" + replaceForURL(b64Encode(objGrid.getSelectedColumnValue("documentformat")[0]));
    objApplication.openChildWindow(window, strURL);
}

/**
 * Allows a new version of the document to be checked in
 */
function dm_checkin()
{
	if (!this.hasPermission("modify"))
	{
		eMsgBox(fl("NOMODIFY"), vbOKOnly, msg_Information, window);
		return;
	}

	var objGrid = eval(this.tabbedDialogID).documentQuery.Grid;
	var strURL = "../Applications_HTML/appCheckInDocument.html?documentid=";
	strURL += replaceForURL(b64Encode(objGrid.getSelectedColumnValue("documentid")[0]));
	strURL += "&filename=" + replaceForURL(b64Encode(objGrid.getSelectedColumnValue("filename")[0]));
	objApplication.openChildWindow(window, strURL);
}

/**
 * Allows the latest version of the document to be checked out.
 */
function dm_checkout()
{
	if (!this.hasPermission("read"))
	{
		eMsgBox(fl("NOACCESS"), vbOKOnly, msg_Information, window);
		return;
	}

	var objGrid = eval(this.tabbedDialogID).documentQuery.Grid;	
	var strURL = "../Applications_HTML/appCheckOutDocument.html?documentid=";
	strURL += replaceForURL(b64Encode(objGrid.getSelectedColumnValue("documentid")[0]));
	strURL += "&filename=" + replaceForURL(b64Encode(objGrid.getSelectedColumnValue("filename")[0]));
	objApplication.openChildWindow(window, strURL);
}

/**
 * Allows a user to see the document history
 */
function dm_showHistory()
{
	var objImageContainer = eval("ccdocImage" + this.tabbedDialogID);
	var objTextEditorContainer = eval("ccdocEnotes" + this.tabbedDialogID);

	if(objImageContainer.isVisible || objTextEditorContainer.isVisible)
		this.clickPreview()
	
	if (!this.hasPermission("read"))
	{
		eMsgBox(fl("NOACCESS"), vbOKOnly, msg_Information, window);
		return;
	}

	var objGrid = eval(this.tabbedDialogID).documentQuery.Grid;

	var strURL = "../Applications_HTML/appDocumentHistory.html?documentid=";
	strURL += replaceForURL(b64Encode(objGrid.getSelectedColumnValue("documentid")[0]));
	objApplication.openChildWindow(window, strURL);
}


/**
 * Checks whether the user has access to the cabinet in which the document is stored.
 * @param strPermissionType The type of permission required
 * @return a boolean indicating whether the user has permissions or not.
 */
function dm_hasPermission(strPermissionType)
{
	if (isBlank(strPermissionType))
		return false;

	var objGrid = eval(this.tabbedDialogID).documentQuery.Grid;

	if (strPermissionType == "read")
		return objGrid.getSelectedColumnValue("readdocs")[0] == cb_CHECKED;
	if (strPermissionType == "add")
		return objGrid.getSelectedColumnValue("adddocs")[0] == cb_CHECKED;
	if (strPermissionType == "modify")
		return objGrid.getSelectedColumnValue("modifydocs")[0] == cb_CHECKED;
	if (strPermissionType == "remove")
		return objGrid.getSelectedColumnValue("removedocs")[0] == cb_CHECKED;

}

/**
 * Updates the status of the <tablename>_docs isingallery flag for
 * the selected document.
 * @param strUniqueID The unique id of the row in the grid.
 */
function dm_galleryChange(strUniqueID)
{
	var objGrid = eval(this.tabbedDialogID).documentQuery.Grid;
	if (objGrid.getSelectedColumnValue("documentformat")[0] == "eNotes") {

		var intRowIndex = objGrid.getRowIndex(objGrid.getSelectedColumnValue("uniqueid")[0]);
		var intCellIndex = objGrid.getColumnCellIndex("isingallery");
		objGrid.HTMLtable.tBodies[0].rows[intRowIndex].cells[intCellIndex].style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTickedDisabled.gif)";
		return;
	}
	
	var flgInGallery = false;
	if (objGrid.getSelectedColumnValue("isingallery")[0] == cb_CHECKED)
		flgInGallery = true;

    var objRPCObject = new RPCObject("DocumentRegister");
    objRPCObject.execute("updateGallery", objApplication.Connection.strConnectionString, this.tablename, objGrid.getSelectedColumnValue("documentid")[0], flgInGallery);
}

/**
 * Clear references for the document manager object
 */
function dm_destroy() {
	try {
		this.id	= null;
		this.tabbedDialogID = null;
		this.parentEditWindowManager = null;
		this.tablename 		= null;
		this.documentKeys 	= null;
	} catch (error) {
	}
}




// Constructor
function Earl(objWindow, id)
{
// properties
	this.objWindow			= objWindow;
	this.id					= id;
	this.targetForm			= null;
	this.report				= "";
	this.sessionString		= "";
	this.applicationServer	= "";
	this.orderBy			= "";
	this.appID				= "";
	this.mode				= "";
	this.layout				= "A4 (Landscape)";
	this.parameterList		= "";
	this.captionList		= "";
	this.parameterIndex		= 0;
	this.viaURL				= true;
	this.title				= "";
	this.target				= null;
	this.instanceid			= "";
	this.step				= 0;
	this.hasHeaderFooter		= true;
	
// methods
	this.addParameter		= Earl_addParameter;
	this.addCaption			= Earl_addCaption;
	this.clearParameterList	= Earl_clearParameterList;
	this.run				= Earl_run;
	this.mail				= Earl_mail;
	this.sendMail			= Earl_sendMail;
	this.fax                = Earl_fax;
	this.sendFax            = Earl_sendFax;
	this.getParameters		= Earl_getParameters;
	this.print				= Earl_print;
	this.initialise			= Earl_initialise;
	this.addTaskInformation = Earl_addTaskInformation;
	this.removeHeaderFooter = Earl_removeHeaderFooter;
}

function Earl_clearParameterList()
{
	this.parameterIndex	= 0;
		
	this.parameterList = "";
	this.captionList = "";

	this.objWindow.document.getElementById("fp0").value = "";
	this.objWindow.document.getElementById("fp1").value = "";
	this.objWindow.document.getElementById("fp2").value = "";
	this.objWindow.document.getElementById("fp3").value = "";
	this.objWindow.document.getElementById("fp4").value = "";
	this.objWindow.document.getElementById("fp5").value = "";
	this.objWindow.document.getElementById("fp6").value = "";
	this.objWindow.document.getElementById("fp7").value = "";
	this.objWindow.document.getElementById("fp8").value = "";
	this.objWindow.document.getElementById("fp9").value = "";
	this.objWindow.document.getElementById("fp10").value = "";
	this.objWindow.document.getElementById("fp11").value = "";

	this.objWindow.document.getElementById("fpc0").value = "";
	this.objWindow.document.getElementById("fpc1").value = "";
	this.objWindow.document.getElementById("fpc2").value = "";
	this.objWindow.document.getElementById("fpc3").value = "";
	this.objWindow.document.getElementById("fpc4").value = "";
	this.objWindow.document.getElementById("fpc5").value = "";
	this.objWindow.document.getElementById("fpc6").value = "";
	this.objWindow.document.getElementById("fpc7").value = "";
	this.objWindow.document.getElementById("fpc8").value = "";
	this.objWindow.document.getElementById("fpc9").value = "";
	this.objWindow.document.getElementById("fpc10").value = "";
	this.objWindow.document.getElementById("fpc11").value = "";
}

function Earl_addCaption(str_value) 
{
	if (this.viaURL == true) {
		this.captionList += "&fpc" + this.parameterIndex + "=" + replaceForURL(b64Encode(trimParameter(str_value)));
	}

	this.objWindow.document.getElementById("fpc" + this.parameterIndex).value = replaceForURL(b64Encode(trimParameter(str_value)));
}

function Earl_addParameter(str_value) 
{
	if (this.viaURL == true) {
		this.parameterList += "&fp" + this.parameterIndex + "=" + replaceForURL(b64Encode(trimParameter(str_value)));
	}

	this.objWindow.document.getElementById("fp" + this.parameterIndex).value = replaceForURL(b64Encode(trimParameter(str_value)));
	this.parameterIndex = this.parameterIndex + 1;
}

/**
 * Allows direct server printing, no visual interface is required.
 * 
 * @param strPrinter Printer ID from the efacsmaster.printers table.
 */
 function Earl_getParameters() {
	var strParameters;

	strParameters = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><incoming>";

	for (var items = 0; items < this.parameterIndex; items++) {
		strParameters = strParameters + "<param>";
		strParameters = strParameters + "<value>";

		if (this.objWindow.document.getElementById("fp" + items).value != "") {
			strParameters = strParameters + b64Decode(undoReplaceForURL(this.objWindow.document.getElementById("fp" + items).value));
		}

		strParameters = strParameters + "</value>"
		strParameters = strParameters + "<caption>";

		if (this.objWindow.document.getElementById("fpc" + items).value != "") {
			strParameters = strParameters + b64Decode(undoReplaceForURL(this.objWindow.document.getElementById("fpc" + items).value));
		}

		strParameters = strParameters + "</caption>"
		strParameters = strParameters + "</param>";
	}

	strParameters = strParameters + "<ordering>" + this.orderBy + "</ordering><layout>" + this.layout + "</layout></incoming>";

	return strParameters;
}

/**
 * Allows direct server printing, no visual interface is required.
 * 
 * @param strPrinter Printer ID from the efacsmaster.printers table.
 */
 function Earl_print(strPrinter) {
	var objSOAP;
	var strParameters;

	objSOAP = new RPCObject("Earl");
	
	strParameters = this.getParameters();

	objSOAP.execute("print", this.objWindow.objApplication.Connection.strConnectionString, this.report, strParameters, objApplication.Connection.applicationServer, true, 0, this.title, objApplication.User.localeid, objApplication.Connection.databaseName, objApplication.Connection.applicationServer, objApplication.User.companyName, objApplication.User.languageDirectory, strPrinter);
}

/**
 * Allows direct server printing, no visual interface is required.
 * 
 * @param strPrinter Printer ID from the efacsmaster.printers table.
 */
 function Earl_mail() {
	this.initialise();
	this.objWindow.objApplication.openChildWindow(window, "../Applications_HTML/appEarlMail.html");
}

/**
 * Send mail
 * 
 * @param to To.
 * @param subject Subject.
 * @param body Body.
 * @param attach Attach.
 * @param docManagement Document management details.
 */
 function Earl_sendMail(to, subject, body, attach, docManagement) {
	var objSOAP;
	var strParameters;
	var strDocManagement = docManagement;

	objSOAP = new RPCObject("Earl");

	strParameters = this.getParameters();
 
	if (isBlank(docManagement))
		strDocManagement = "";

	objSOAP.handleRPCError = false;
	try {
		objSOAP.execute("mail", objApplication.Connection.strConnectionString, this.report, strParameters, objApplication.Connection.applicationServer, this.title, objApplication.User.localeid, objApplication.Connection.databaseName, objApplication.Connection.applicationServer, objApplication.User.companyName, objApplication.User.languageDirectory, to, objApplication.User.userID, subject, body, attach, strDocManagement);
	} catch(error) {
		if (error.message.indexOf('column [smtpserver] has null value') != -1) {
			eMsgBox("You do not have an email server configured. Please contact your system administrator.", vbOK, msg_Critical, window);
		} else if (error.message.indexOf('column [emailaddress] has null value') != -1) {
			eMsgBox("You do not have an email account configured. Please contact your system administrator.", vbOK, msg_Critical, window);
		} else {
			if(error.message.indexOf("1001") != -1)
				eMsgBox(fl("EMAILCONFIG_BADUSERORPASSWORD"), vbOK, msg_Critical, window); 
			else if(error.message.indexOf("1002") != -1)		
				eMsgBox(fl("EMAILCONFIG_ERROR"), vbOK, msg_Critical, window);
			else			
				showEfacsError(error, this.objWindow, true)
		}
		return false;
	}
	
	return true;
}

/**
 * Display the fax form to the user and send the fax to the fax service
 */
 function Earl_fax() {
	var objRPC;
	var objXML;
	
	objRPC = new RPCObject("company");
	objRPC.handleRPCError = false;
	try {
		objRPC.execute("load", objApplication.Connection.strConnectionString, objApplication.User.company);
		objXML = objRPC.getReturnedXMLDom();                        
		var strFaxURL;
		strFaxURL = objXML.selectSingleNode("//companies/company/faxurl/value").getText();
		if (strFaxURL == null) {
	        eMsgBox("No fax server configured for company", vbOK, msg_Critical);

			return false;
		}
	}catch(error) {	
	    eMsgBox("Error checking fax property for company", vbOK, msg_Critical);
		return false;
	
	}
	
	this.objWindow.objApplication.openChildWindow(window, "../Applications_HTML/appEarlFax.html");
}
/** Call to EARL to send a fax 
 * @param to To
 * @param company Company
 * @param fax Fax number
 * @param from From
 * @param subject Subject
 * @param body Body content
 * @param docManagement Document details
 * @return true on success, otherwise false
 */
 
function Earl_sendFax(to, company, fax, from, subject, body, docManagement) {
	var objRPC;
	var strParameters;
	objRPC = new RPCObject("Earl");
	strParameters = this.getParameters();
	objRPC.handleRPCError = false;
	
	var strISODate=objApplication.getCalendarParser().getDateTimeInISO();

	var strDocManagement = docManagement;
	if(isBlank(strDocManagement))
		strDocManagement = "";
	
	try {
		objRPC.execute("sendFax", objApplication.Connection.strConnectionString, this.report, strParameters, objApplication.Connection.applicationServer, this.title, 
			objApplication.User.localeid, objApplication.Connection.databaseName, objApplication.Connection.applicationServer, objApplication.User.companyName, 
			objApplication.User.languageDirectory, to, company, fax, from, strISODate, subject, body, strDocManagement);
	} catch(error) {
			showEfacsError(error, this.objWindow, true)
		return false;
	}
	return true;
}



function Earl_initialise()
{
	this.targetForm.SessionString.value = replaceForURL(b64Encode(this.sessionString));
	this.targetForm.ApplicationServer.value = replaceForURL(b64Encode(this.applicationServer));
	this.targetForm.mode.value = replaceForURL(b64Encode(this.mode));
	this.targetForm.report.value = this.report;
	
	if (this.orderBy != "") {
		this.targetForm.orderBy.value = replaceForURL(b64Encode(this.orderBy));
	}

	if (this.layout != "") {
		this.targetForm.layout.value = replaceForURL(b64Encode(this.layout));
	}

	if (this.mode == "HTML")
		this.targetForm.tohtml.value = replaceForURL(b64Encode("true"));
	else
		this.targetForm.tohtml.value = replaceForURL(b64Encode("false"));

	this.targetForm.reportTitle.value = replaceForURL(b64Encode(this.title));
}

function Earl_run() 
{
	var addr = "";

	if (m_objFunctionalTest != null && (m_objFunctionalTest.isFunctionalTestRecording() == true || m_objFunctionalTest.isFunctionalTestPlaying() == true))
		this.mode = "HTML";

	this.initialise();
	
	if (this.viaURL == true) {
		addr = "../Applications_HTML/appEarlRun.html";
		addr += "?report=" + this.report;
		addr += "&viaURL=true";
		addr += "&reportTitle=" + replaceForURL(b64Encode(this.title));

		if (this.layout != "") {
			addr += "&layout=" + replaceForURL(b64Encode(this.layout));
		}

		if (this.orderBy != "") {
			addr += "&orderBy=" + replaceForURL(b64Encode(this.orderBy));
		}

		if (this.mode == "HTML")
			addr += "&tohtml=" + replaceForURL(b64Encode("true"));
		else
			addr += "&tohtml=" + replaceForURL(b64Encode("false"));

		addr += this.parameterList;
		addr += this.captionList;
		
		if (this.instanceid != "") 
			addr += "&instanceid=" + replaceForURL(b64Encode(this.instanceid)) + "&step=" + this.step;
		
		if (!this.hasHeaderFooter) 
			addr += "&removeheaderfooter=" + replaceForURL(b64Encode("true"));
		
		if (this.target != null) {
			this.objWindow.document.getElementById(this.target).src = addr;
		}
		else {
			this.objWindow.objApplication.openChildWindow(this.objWindow, addr);
		}
	}
	else {
		addr = "../Applications_HTML/appEarlRun.html?viaURL=false";

		if (this.orderBy != "") {
			this.targetForm.orderBy.value = replaceForURL(b64Encode(this.orderBy));
		}

		if (this.layout != "") {
			this.targetForm.layout.value = replaceForURL(b64Encode(this.layout));
		}

		if (this.mode == "HTML")
			this.targetForm.tohtml.value = replaceForURL(b64Encode("true"));
		else
			this.targetForm.tohtml.value = replaceForURL(b64Encode("false"));

		this.targetForm.reportTitle.value = replaceForURL(b64Encode(this.title));

		if (this.target != null) {
			this.targetForm.target = this.target;
			this.targetForm.method = "POST";
			this.targetForm.action = addr;
			this.targetForm.submit();
		}
		else {
			this.objWindow.objApplication.openChildWindow(this.objWindow, addr);
		}
	} 
}

function trimParameter(param) {
	if (param.length > 0) {
		while (param.charAt(0) == ' ') {
			param = param.substring(1, param.length);
		}
	}
	if (param.length > 0) {
		while (param.charAt(param.length - 1) == ' ') {
			param = param.substring(0, param.length - 1);
		}
	}
	return param;
}
/** add workflow task key information 
 * @param instanceid Workflow instance ID
 * @param step Current workflow step
 */
function Earl_addTaskInformation(instanceid, step) {
	this.instanceid	= instanceid;
	this.step = step;
}
/** Remove the reports Header and Footer.
 */
function Earl_removeHeaderFooter() {
	this.hasHeaderFooter = false;
}


	


// Constructor
function Earl2(objWindow, id)
{
// properties
	this.objWindow			= objWindow;
	this.id					= id;
	this.targetForm			= null;
	this.report				= "";
	this.sessionString		= "";
	this.applicationServer	= "";
	this.orderBy			= "";
	this.appID				= "";
	this.mode				= "";
	this.layout				= "A4 (Landscape)";
	this.parameterList		= "";
	this.captionList		= "";
	this.parameterIndex		= 0;
	this.trim               = 0;
	this.viaURL				= true;
	this.title				= "";
	this.target				= null;
	this.instanceid			= "";
	this.step				= 0;
	this.copies				= 1;
	this.priority			= 10;
	this.multiCompany		= false;
	
// methods
	this.addParameter		= Earl2_addParameter;
	this.addCaption			= Earl2_addCaption;
	this.clearParameterList	= Earl2_clearParameterList;
	this.run				= Earl2_run;
	this.mail				= Earl2_mail;
	this.sendMail			= Earl2_sendMail;
	this.fax                = Earl2_fax;
	this.sendFax            = Earl2_sendFax;
	this.getParameters		= Earl2_getParameters;
	this.print				= Earl2_print;
	this.initialise			= Earl2_initialise;
	this.addTaskInformation = Earl2_addTaskInformation;
	this.removeHeaderFooter = Earl2_removeHeaderFooter;
	this.setMultiCompany	= Earl2_setMultiCompany;
}

function Earl2_clearParameterList()
{
	this.parameterIndex	= 0;
		
	this.parameterList = "";
	this.captionList = "";

	this.objWindow.document.getElementById("fp0").value = "";
	this.objWindow.document.getElementById("fp1").value = "";
	this.objWindow.document.getElementById("fp2").value = "";
	this.objWindow.document.getElementById("fp3").value = "";
	this.objWindow.document.getElementById("fp4").value = "";
	this.objWindow.document.getElementById("fp5").value = "";
	this.objWindow.document.getElementById("fp6").value = "";
	this.objWindow.document.getElementById("fp7").value = "";
	this.objWindow.document.getElementById("fp8").value = "";
	this.objWindow.document.getElementById("fp9").value = "";
	this.objWindow.document.getElementById("fp10").value = "";
	this.objWindow.document.getElementById("fp11").value = "";
	this.objWindow.document.getElementById("fp12").value = "";
	this.objWindow.document.getElementById("fp13").value = "";
	this.objWindow.document.getElementById("fp14").value = "";
	this.objWindow.document.getElementById("fp15").value = "";
	this.objWindow.document.getElementById("fp16").value = "";
	this.objWindow.document.getElementById("fp17").value = "";
	this.objWindow.document.getElementById("fp18").value = "";
	this.objWindow.document.getElementById("fp19").value = "";

	this.objWindow.document.getElementById("fpc0").value = "";
	this.objWindow.document.getElementById("fpc1").value = "";
	this.objWindow.document.getElementById("fpc2").value = "";
	this.objWindow.document.getElementById("fpc3").value = "";
	this.objWindow.document.getElementById("fpc4").value = "";
	this.objWindow.document.getElementById("fpc5").value = "";
	this.objWindow.document.getElementById("fpc6").value = "";
	this.objWindow.document.getElementById("fpc7").value = "";
	this.objWindow.document.getElementById("fpc8").value = "";
	this.objWindow.document.getElementById("fpc9").value = "";
	this.objWindow.document.getElementById("fpc10").value = "";
	this.objWindow.document.getElementById("fpc11").value = "";
	this.objWindow.document.getElementById("fpc12").value = "";
	this.objWindow.document.getElementById("fpc13").value = "";
	this.objWindow.document.getElementById("fpc14").value = "";
	this.objWindow.document.getElementById("fpc15").value = "";
	this.objWindow.document.getElementById("fpc16").value = "";
	this.objWindow.document.getElementById("fpc17").value = "";
	this.objWindow.document.getElementById("fpc18").value = "";
	this.objWindow.document.getElementById("fpc19").value = "";
}

function Earl2_addCaption(str_value) 
{
	if (this.viaURL == true) {
		this.captionList += "&fpc" + this.parameterIndex + "=" + replaceForURL(b64Encode(trimParameter(str_value)));
		
	}

	this.objWindow.document.getElementById("fpc" + this.parameterIndex).value = trimParameter(str_value);
}

function Earl2_addParameter(str_value) 
{
	if (this.viaURL == true) {
		this.parameterList += "&fp" + this.parameterIndex + "=" + replaceForURL(b64Encode(trimParameter(str_value)));
	}

	this.objWindow.document.getElementById("fp" + this.parameterIndex).value = trimParameter(str_value);
	this.parameterIndex = this.parameterIndex + 1;
}

/**
 * Allows direct server printing, no visual interface is required.
 * 
 * @param strPrinter Printer ID from the efacsmaster.printers table.
 */
 function Earl2_getParameters() {
	var strParameters;

	strParameters = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><incoming>";

	for (var items = 0; items < this.parameterIndex; items++) {
		strParameters = strParameters + "<param>";
		strParameters = strParameters + "<value>";

		if (this.objWindow.document.getElementById("fp" + items).value != "") {
			strParameters = strParameters + escapeXML(this.objWindow.document.getElementById("fp" + items).value);
		}

		strParameters = strParameters + "</value>"
		strParameters = strParameters + "<caption>";

		if (this.objWindow.document.getElementById("fpc" + items).value != "") {
			strParameters = strParameters + escapeXML(this.objWindow.document.getElementById("fpc" + items).value);
		}

		strParameters = strParameters + "</caption>"
		strParameters = strParameters + "</param>";
	}

	strParameters = strParameters + "<ordering>" + this.orderBy + "</ordering><layout>" + this.layout + "</layout></incoming>";

	return strParameters;
}

/**
 * Allows direct server printing, no visual interface is required.
 * 
 * @param strPrinter Printer ID from the efacsmaster.printers table.
 */
 function Earl2_print(strPrinter) {
	var objSOAP;
	var strParameters;

	objSOAP = new RPCObject("Earl");
	
	strParameters = this.getParameters();
	
	var retVal = objSOAP.execute("print2", this.objWindow.objApplication.Connection.strConnectionString, this.report, strParameters, objApplication.Connection.applicationServer, true, this.title, objApplication.User.localeid, objApplication.Connection.databaseName, objApplication.Connection.applicationServer, objApplication.User.companyName, objApplication.User.languageDirectory, strPrinter, this.copies, this.priority);
	
	if(retVal == -1) {
		eMsgBox("This job failed because the print server is invalid or came offline. Please contact your system administrator.", vbOK, msg_Critical, window);
		
		return 0;
	} else if(retVal == -2)  {
		eMsgBox("Incorrect parameters were passed to the print server. Please contact your system administrator.", vbOK, msg_Critical, window);
		
		return 0;
	} else if(retVal == -3) {
		eMsgBox("The report generated is corrupt and could not be printed. Please contact your system administrator.", vbOK, msg_Critical, window);
		
		return 0;
	} else {
		return retVal;
	}
}

/**
 * Allows direct server printing, no visual interface is required.
 * 
 * @param strPrinter Printer ID from the efacsmaster.printers table.
 */
function Earl2_mail() {
	this.initialise();
	this.objWindow.objApplication.openChildWindow(window, "../Applications_HTML/appEarl2Mail.html");
}

/**
 * Send mail
 * 
 * @param to To.
 * @param subject Subject.
 * @param body Body.
 * @param attach Attach.
 * @param docManagement Document management details.
 */
 function Earl2_sendMail(to, subject, body, attach, docManagement) {
	var objSOAP;
	var strParameters;
	var strDocManagement = docManagement;

	objSOAP = new RPCObject("Earl");

	strParameters = this.getParameters();
	
	if (isBlank(docManagement))
		strDocManagement = "";

	objSOAP.handleRPCError = false;
	
	try {
		var mailSent = objSOAP.execute("mail2", objApplication.Connection.strConnectionString, this.report, strParameters, objApplication.Connection.applicationServer, this.title, objApplication.User.localeid, objApplication.Connection.databaseName, objApplication.Connection.applicationServer, objApplication.User.companyName, objApplication.User.languageDirectory, to, "", objApplication.User.userID, subject, body, attach, strDocManagement, this.orderBy, this.layout, this.priority, this.multiCompany);
	} catch(error) {
		if (error.message.indexOf('column [smtpserver] has null value') != -1) {
			eMsgBox("You do not have an email server configured. Please contact your system administrator.", vbOK, msg_Critical, window);
		} else if (error.message.indexOf('column [emailaddress] has null value') != -1) {
			eMsgBox("You do not have an email account configured. Please contact your system administrator.", vbOK, msg_Critical, window);
		} else {
			if(error.message.indexOf("1001") != -1)
				eMsgBox(fl("EMAILCONFIG_BADUSERORPASSWORD"), vbOK, msg_Critical, window); 
			else if(error.message.indexOf("1002") != -1)		
				eMsgBox(fl("EMAILCONFIG_ERROR"), vbOK, msg_Critical, window);
			else			
				showEfacsError(error, this.objWindow, true)
		}
		return false;
	}
	
	return mailSent;
}

/**
 * Display the fax form to the user and send the fax to the fax service
 */
function Earl2_fax() {
	this.initialise();
	this.objWindow.objApplication.openChildWindow(window, "../Applications_HTML/appEarlFax2.html");
}
/** Call to EARL to send a fax 
 * @param to To
 * @param company Company
 * @param fax Fax number
 * @param from From
 * @param subject Subject
 * @param body Body content
 * @param docManagement Document management details
 * @return true on success, otherwise false
 */
 
function Earl2_sendFax(to, company, fax, from, subject, body, docManagement) {
	var objRPC;
	var strParameters;
	var strDocManagement = docManagement;
	
	objRPC = new RPCObject("Earl");
	objRPC.handleRPCError = false;
	
	strParameters = this.getParameters();
	
	if (isBlank(docManagement))
		strDocManagement = "";
	
	try {
		var strISODate=objApplication.getCalendarParser().getDateTimeInISO();
		
		var faxSent = objRPC.execute("fax2", objApplication.Connection.strConnectionString, this.report, strParameters, objApplication.Connection.applicationServer, this.title, 
			objApplication.User.localeid, objApplication.Connection.databaseName, objApplication.Connection.applicationServer, objApplication.User.companyName, 
			objApplication.User.languageDirectory, to, company, fax, from, strISODate, subject, body, strDocManagement, this.orderBy, this.layout, this.priority, this.multiCompany);
	} catch(error) {
		showEfacsError(error, this.objWindow, true)
		return false; 
	}
	
	return faxSent;
}



function Earl2_initialise()
{
	this.targetForm.SessionString.value = this.sessionString;
	this.targetForm.ApplicationServer.value = this.applicationServer;
	this.targetForm.mode.value = this.mode;
	this.targetForm.report.value = this.report;
	this.targetForm.priority.value = this.priority;
	
	if (this.orderBy != "") {
		this.targetForm.orderBy.value = this.orderBy;
	}

	if (this.layout != "") {
		this.targetForm.layout.value = this.layout;
	}

	if (this.mode == "HTML")
		this.targetForm.tohtml.value = "true";
	else
		this.targetForm.tohtml.value = "false";

	this.targetForm.reportTitle.value = this.title;
}

function Earl2_run() 
{
	var addr = "";

	if (m_objFunctionalTest != null && (m_objFunctionalTest.isFunctionalTestRecording() == true || m_objFunctionalTest.isFunctionalTestPlaying() == true))
		this.mode = "HTML";

	this.initialise();
	
	if (this.viaURL == true) {
		addr = "../Applications_HTML/appEarlRun2.html";
		addr += "?report=" + this.report;
		addr += "&viaURL=true";
		addr += "&reportTitle=" + replaceForURL(b64Encode(this.title));

		if (this.layout != "") {
			addr += "&layout=" + this.layout;
		}

		if (this.orderBy != "") {
			addr += "&orderBy=" + this.orderBy;
		}

		if (this.mode == "HTML")
			addr += "&tohtml=" + "true";
		else
			addr += "&tohtml=" + "false";

		addr += this.parameterList;
		addr += this.captionList;
		
		if (this.instanceid != "") 
			addr += "&instanceid=" + replaceForURL(b64Encode(this.instanceid)) + "&step=" + this.step;
		
		addr += "&trim=" + this.trim;
		addr += "&priority=" + this.priority;

		if (this.multiCompany)
			addr += "&multicompany=true";
		
		if (this.target != null) {
			this.objWindow.document.getElementById(this.target).src = addr;
		}
		else {
			this.objWindow.objApplication.openChildWindow(this.objWindow, addr);
		}
	}
	else {
		addr = "../Applications_HTML/appEarlRun2.html?viaURL=false";

		if (this.orderBy != "") {
			this.targetForm.orderBy.value = this.orderBy;
		}

		if (this.layout != "") {
			this.targetForm.layout.value = this.layout;
		}

		if (this.mode == "HTML")
			this.targetForm.tohtml.value = "true";
		else
			this.targetForm.tohtml.value = "false";

		this.targetForm.reportTitle.value = this.title;
		
		this.targetForm.trim.value = this.trim;

		if (this.multiCompany)
			this.targetForm.multicompany.value = "true";
		else
			this.targetForm.multicompany.value = "false";

		if (this.target != null) {
			this.targetForm.target = this.target;
			this.targetForm.method = "POST";
			this.targetForm.action = addr;
			this.targetForm.submit();
		}
		else {
			this.objWindow.objApplication.openChildWindow(this.objWindow, addr);
		}
	} 
}

function trimParameter(param) {
	if (param.length > 0) {
		while (param.charAt(0) == ' ') {
			param = param.substring(1, param.length);
		}
	}
	if (param.length > 0) {
		while (param.charAt(param.length - 1) == ' ') {
			param = param.substring(0, param.length - 1);
		}
	}
	return param;
}
/** add workflow task key information 
 * @param instanceid Workflow instance ID
 * @param step Current workflow step
 */
function Earl2_addTaskInformation(instanceid, step) {
	this.instanceid	= instanceid;
	this.step = step;
}
/** Remove the reports Header and Footer.
 */
function Earl2_removeHeaderFooter() {
	this.trim = 1;
}

/**
 * Sets report to run in multi company mode
 */
function Earl2_setMultiCompany()
{
	this.multiCompany = true;
}


	
// JScript source code
// Javascript functions used by earl front end


function shorten(strToShorten) {
	var stringy, len;

	stringy = strToShorten.toString();
	if (!(stringy == "" || stringy == null)) {
		len = stringy.length;

		while (stringy.charAt(len-1) == " "  || stringy.charAt(len-1) == "\t" || stringy.charAt(len-1) == "\n") {
			stringy = stringy.slice(0, len - 1);
			len = stringy.length;
			//alert (len);
		}
		len = stringy.length;
		while(stringy.charAt(0) == " "  || stringy.charAt(0) == "\t" || stringy.charAt(0) == "\n") {
			stringy = stringy.slice(1, len);
		}
	}
	return stringy;
}

function shorten2(strToShorten) {
	var stringy, len;

	stringy = strToShorten.toString();
	if (!(stringy == "" || stringy == null)) {
		len = stringy.length;

		while (stringy.charAt(len-1) == " "  || stringy.charAt(len-1) == "\t" || stringy.charAt(len-1) == "\n") {
			stringy = stringy.slice(0, len - 1);
			len = stringy.length;
			//alert (len);
		}
		len = stringy.length;
		while(stringy.charAt(0) == " "  || stringy.charAt(0) == "\t" || stringy.charAt(0) == "\n") {
			stringy = stringy.slice(1, len);
		}
		stringy = stringy.replace("/n", " ");
		stringy = stringy.replace("/t", " ");
	}
	return stringy;
}

function dateValidation(dateVal) {
	var leapyear = false;
    var flginvalid = false;
    var month;
	var sep1;
	var day;
	var sep2;
	var year; 
    var d = dateVal.value;     
	d = shorten2(d);
	month = d.substring(3,5);  
	sep1 = d.substring(2,3);
	day = d.substring(0,2);  
	sep2 = d.substring(5,6);
	year = d.substring(6,10);  
	
	if (d == "")
		return true;
	
    if (d != "") {
//alert("day = " + day + ", month = " + month + ", year = " + year + ", sep1 = " + sep1 + ", sep2 = " + sep2);

            if ((month < 1) || (month > 12)) {
                    flginvalid = true;
            }

            if (sep1 != "/" && sep1 != "-") {
                    flginvalid = true;
            }

            if (sep2 != "/" && sep2 != "-") {
                    flginvalid = true;
            }
            //30 day months - 4, 6, 9 & 11
            if ((month == 4 || month == 6 || month == 9 || month == 11) && day > 30) {
                    flginvalid = true;
            }
            //31 day months - 1, 3, 5, 7, 8, 10, 12
            if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 ||
                    month == 10 || month == 12) && day > 31) {
                    flginvalid = true;
            }

            if (!(year % 4) && (year % 100) ) {
                    leapyear = true;
            }

            if (((month == 2) && (day > 29)) && (leapyear)) {
                    flginvalid = true;
            }
            if (((month == 2) && (day > 28)) && (!leapyear)) {
                    flginvalid = true;
            }
    }
    if (flginvalid == true) {
    alert("You have entered an invalid date. Please enter a valid date in the format dd/mm/yyyy");
    return false
    }
    var id = dateVal.id;
    id = id.substring(0, id.length-1);
    //debug - element id
    //alert(id);
    var i;
    for (i=0; i<inputform.elements.length; i++) {
            if (inputform.elements[i].id == id) {
                    inputform.elements[i].value = dateConvert(d);
                    //debug - date set
                    //alert("date set to: " + form.elements[i].value);
            }
    } 
    return true;
}

function dateConvert(date) {
    var month = date.substring(3,5);  
    var day = date.substring(0,2);  
    var year = date.substring(6,10); 
    //alert("date is now " + year + "-" + month + "-" + day + " 00:00:00.0");
    return year + "-" + month + "-" + day + " 00:00:00";
}

	

var EWM_FIRST = 0x1;
var EWM_LAST = 0x2;
var EWM_NEXT = 0x4;
var EWM_PREVIOUS = 0x8;

// Bean parameter types
var EWM_FORMPARAM = 0x1;
var EWM_METHODPARAM = 0x2;
var EWM_VARIABLEPARAM = 0x4;
var EWM_VALUEPARAM = 0x8;
var EWM_GRIDCOLPARAM = 0x10;

// Main constructor for EditWindowManager object.
function EditWindowManager(strEditWindowManagerID, strApplicationName, strGridId, AppWindow)
{
	this.id						= strEditWindowManagerID;
	this.applicationName		= strApplicationName;
	this.gridId					= strGridId;
	this.AppWindow				= AppWindow;
	
	this.setupChildWindow		= ewm_setupChildWindow;
	this.XPath					= null;
	this.openChildWindow		= ewm_openChildWindow;
	this.addNewEditWindow		= ewm_addNewEditWindow;
	this.getEditWindow			= ewm_getEditWindow;						// Associated record collection edit form object.
	this.arrEditWindows			= new Array();

	this.strClassName			= null;
	this.strLoadMethod			= null;
	this.strSaveMethod			= null;

	this.DataEngine				= null;
	this.Grid					= null;
	this.setupWithDataEngine	= ewm_setupWithDataEngine;
	this.loadRecord				= ewm_loadRecord;
	this.arrPrimaryKeyFields	= new Array();
	this.addPrimaryKeyField		= ewm_addPrimaryKeyField;
	this.arrBeanParams			= new Array();
	this.addBeanParameter		= ewm_addBeanParameter;
	
	this.populateFormDataMethod = null;
	this.primaryKeyClassName	= null;
	this.primaryKeyClassMethod	= null;

	this.resyncForm				= ewm_resyncForm;
	this.setCaption				= ewm_setCaption;
	this.checkWindowAlreadyOpen	= ewm_checkWindowAlreadyOpen;
	this.removeEditWindow		= ewm_removeEditWindow;
	this.removeRecords			= ewm_removeRecords;
	this.removeOpenWindows		= ewm_removeOpenWindows;
	this.setFormEditMode		= ewm_setFormEditMode;
		
	this.prepareDataChanges		= ewm_prepareDataChanges;
	this.applyDataChanges		= ewm_applyDataChanges;
	this.newRecord				= ewm_newRecord;
	this.flgRemoveEditWindow	= true;

	this.firstRecord			= ewm_firstRecord;				// Record object navigation methods.
	this.nextRecord				= ewm_nextRecord;
	this.previousRecord			= ewm_previousRecord;
	this.lastRecord				= ewm_lastRecord;
	this.selectRecordById		= ewm_selectRecordById;

	this.setToolBarButtonStates	= ewm_setToolBarButtonStates;
	this.doRefresh				= true;
	this.closeAll				= ewm_closeAll;
	this.moveToRecord			= ewm_moveToRecord;
	this.updateGrid				= ewm_updateGrid;
	this.initialiseGrid			= ewm_initialiseGrid;
	this.setUpdateMode			= ewm_setUpdateMode;
	this.windowsOpened			= 0;							// The number of child windows actually opened.  arrEditWindows does not get added to until setupChildWindow.
	this.executeChildWindowFunction = ewm_executeChildWindowFunction;
	this.addFormReference		= ewm_addFormReference;
	this.loadChildWindowForms	= ewm_loadChildWindowForms;
	this.autoSetupChildWindow	= ewm_autoSetupChildWindow;
	this.getPrimaryKeyURLParameters = ewm_getPrimaryKeyURLParameters;
	this.saveAndClose			= ewm_saveAndClose;
	this.performSave			= ewm_performSave;
	this.onBeforeUnload			= ewm_onBeforeUnload;
	this.validateForms			= ewm_validateForms;
	this.getPrimaryKeyValueList	= ewm_getPrimaryKeyValueList;
	this.autoSetupComplete		= ewm_autoSetupComplete;	
	this.setCustomEntityName    = ewm_setCustomEntityName;
	this.showDocumentTab		= ewm_showDocumentTab;
	
	//Private method - should only be called internally.
	this.updateENotes			= ewm_updateENotes;
	this.useNotes				= ewm_useNotes;
	this.loadNotes				= ewm_loadNotes;

	this.documentGrid			= null; 
	
	this.strCustomEntityName    = null;
	this.destroy				= ewm_destroy;
}


function ewm_setFormEditMode(strMode, AppWindow)
{
	// Send the edit mode to the form.
	this.getEditWindow(AppWindow).Form.setEditMode(strMode);
}

function ewm_setupChildWindow(strXPath, objForm, AppWindow)
{
	objApplication.Debug.writeTime("SETUP CHILD WINDOW BEGIN - " + objForm.id, "file-name=ssEditWindowManager.js");

	// XPath must begine with slash.
	if (strXPath.substring(0, 1) == "/")
		this.XPath = strXPath;
	else
		this.XPath = "/" + strXPath;
		
	var objEditWindow = this.addNewEditWindow(objForm, AppWindow);

	objApplication.Debug.writeTime("SETUP CHILD WINDOW - Added new edit window", "file-name=ssEditWindowManager.js");

	if (this.strCustomEntityName != null) 
		objForm.setCustomEntityName(this.strCustomEntityName);
	
	var lngUniqueID;
	if (objEditWindow.editMode != "add")
	{
		lngUniqueID = ParseStringFromURL("uniqueid", AppWindow.document.URL);
		lngUniqueID = b64Decode(undoReplaceForURL(lngUniqueID));
	}
	
	// Attempt to get a reference to the tabbed dialog for eNotes and Documents.
	// Will only be null already for non-standard apps that pass key details
	// forms to setupChildWindow.
	if (objForm.tabbedDialog == null) 
	{
		var objButtons = AppWindow.document.getElementsByName("tabdocbutton");
		if (objButtons.length == 0)
			objButtons = AppWindow.document.getElementsByName("tabenotesbutton");
		
		if (objButtons.length > 0)
			objForm.tabbedDialog = AppWindow[objButtons.item(0).id.replace("tabdoc", "").replace("tabtxt", "")];
	}
	
	objApplication.Debug.writeTime("SETUP CHILD WINDOW - Got tabbed dialog reference", "file-name=ssEditWindowManager.js");

	// are Notes enabled for this schema 
	if (objForm.tabbedDialog != null) {
		objForm.tabbedDialog.EditWindowManager = this;
		
		if (!this.useNotes(objForm.schemaName))
			objForm.tabbedDialog.getTab(objForm.tabbedDialog.strTextTab).hide();
		else if (objForm.tabbedDialog.TextEditor != null)	
			objForm.tabbedDialog.TextEditor.emediaID = String(objForm.schemaName).toLowerCase();
	}

	objApplication.Debug.writeTime("SETUP CHILD WINDOW - Got text editor reference", "file-name=ssEditWindowManager.js");

	this.AppWindow.AppTranslator_setupEditWindowManagerForms(AppWindow);
	this.resyncForm(AppWindow, lngUniqueID);

	objApplication.Debug.writeTime("SETUP CHILD WINDOW - Resynced form", "file-name=ssEditWindowManager.js");

	if (typeof(AppWindow.window_onloadrecord) != "undefined")
		AppWindow.window_onloadrecord();
	objApplication.Debug.writeTime("SETUP CHILD WINDOW - Called applications own window_onloadrecord()", "file-name=ssEditWindowManager.js");

	// Need to check for critical error - resyncForm may have failed with system parameter requests.
	if (objApplication.hadCriticalError == true)
		return;

	this.setToolBarButtonStates(AppWindow);

	objEditWindow.syncFormEditModes();

	objApplication.performADAPTScript(ADAPT_ONAPPLICATIONLOADRECORD, AppWindow);

	objApplication.Debug.writeTime("SETUP CHILD WINDOW DONE - " + objForm.id, "file-name=ssEditWindowManager.js");
}

function ewm_addNewEditWindow(objForm, AppWindow)
{
	var intNewArrNum = this.arrEditWindows.length;
	var objEditWindow = new ewm_EditWindow(objForm, ParseStringFromURL("mode", AppWindow.document.URL), AppWindow);
	this.arrEditWindows[intNewArrNum] = objEditWindow;
	return objEditWindow;
}

function ewm_getEditWindow(AppWindow)
{
	for (var intCtr = 0, intLen = this.arrEditWindows.length; intCtr < intLen; intCtr++)
	{
		var objEditWindow = this.arrEditWindows[intCtr];
		if (objEditWindow.AppWindow == AppWindow)
			return objEditWindow;
	}
}

// Returns changed xml which can be used in RPC Save call from the application edit window.
function ewm_prepareDataChanges(AppWindow)
{
	var objEditWindow = this.getEditWindow(AppWindow);
	var objForm = objEditWindow.Form;

	var objNode = objForm.DOM.cloneNode();
	
	// MCB REVIEW - Only needed for apps that use DOM.setText instead of Form.setValue
	var objFieldNodes = objNode.selectNodes("//value[@xsi:nil = 'true' and text() != '']");
	for (var objFieldNode = objFieldNodes.nextNode(); objFieldNode != null; objFieldNode = objFieldNodes.nextNode())
	{
		objFieldNode.removeAttribute("xsi:nil");
	}

	if (objEditWindow.editMode == "add")
	{
		objNode.setAttribute("isnew", "true");
		objNode.removeAttribute("uniqueid");
	}

	var strSchemaID = objNode.nodeName();

	var strXML = "<" + objApplication.Schema.getSchemaCollectionName(strSchemaID) + " xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>";
	if (objEditWindow.dataprocessXML != null)
		strXML+= objEditWindow.dataprocessXML;
	strXML += objNode.xml();
	strXML += "</" + objApplication.Schema.getSchemaCollectionName(strSchemaID) + ">";

	objForm.flgPreparedDataChanges = true;

	return strXML;
}

/**
 * Commits saved data to memory and marks the data as no longer dirty.
 *
 * @param AppWindow The window object reference.
 * @param flgNoGridUpdate Determines whether to update any associated grid with newly saved data.
 * @param flgIgnoreMissingColumns If true then will not warn if a grid column reference cannot be found on the form.
 * @param objReturnXML Contains the returned XML DOM from the RPC call.
 * @return The none-dirty xml data.
 */
function ewm_applyDataChanges(AppWindow, flgNoGridUpdate, flgIgnoreMissingColumns, objReturnXML)
{
	var objEditWindow = this.getEditWindow(AppWindow);
	var objForm = objEditWindow.Form;

	objForm.flgPreparedDataChanges = false;

	var objNode = objForm.DOM.documentElement();
	var strSchemaID = objNode.nodeName();

	var strXML = "<" + objApplication.Schema.getSchemaCollectionName(strSchemaID) + " xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>";
	if (objNode.parentNode().selectSingleNode("dataprocess") != null)
		strXML += objNode.parentNode().selectSingleNode("dataprocess").xml();
	strXML += objNode.xml();
	strXML += "</" + objApplication.Schema.getSchemaCollectionName(strSchemaID) + ">";

	if (flgNoGridUpdate != true)
		this.updateGrid(AppWindow, flgIgnoreMissingColumns);

	// This nodes changes have now been applied back into the application data - so set as no longer dirty.
	objApplication.Data.setAsNotDirty(objNode, objReturnXML);

	objForm.editMode = "update";
	objEditWindow.editMode = "update";
	objEditWindow.syncFormEditModes();

	if (objEditWindow.Form.tabbedDialog != null && objEditWindow.Form.tabbedDialog.TextEditor != null && 
	    objEditWindow.Form.tabbedDialog.TextEditor.isNotesDirty())
	{
		objEditWindow.Form.tabbedDialog.TextEditor.performOperation(AppWindow, 'save');
	}

	return strXML;
}

/**
 * Initialises the grid if it has not yet been set up
 * and we have a relevant grid id.
 */
function ewm_initialiseGrid()
{
	if (this.Grid == null && !isBlank(this.gridId))
	{	
		this.Grid = objApplication.Grids(this.gridId);
		this.Grid.setup();
	}
}

/**
 * Updates the row data in the associated grid (if there is one).
 *
 * @param AppWindow The window object reference.
 * @param flgIgnoreMissingColumns If true then will not warn if a grid column reference cannot be found on the form.
 */
function ewm_updateGrid(AppWindow, flgIgnoreMissingColumns)
{
	this.initialiseGrid();
	
	if (this.Grid == null)
		return;

	var objEditWindow = this.getEditWindow(AppWindow);
	var objForm = objEditWindow.Form;
	var objGrid = this.Grid;
	var strCommand;
	var strSelectID;
	
	if (objGrid.Tree != null) {
		objGrid.Tree.refresh();
		return;
	}

	var objHeadCells = objGrid.HTMLtable.tHead.rows[0].cells;

	if (objForm.editMode == "add")
	{
		strSelectID = this.Grid.getMaxUniqueID() + 1;
		objEditWindow.currentRecordID = strSelectID;
		strCommand = "objGrid.insertRow(etc_AFTER, -1, " + strSelectID;
	}
	else
	{
		strSelectID = objEditWindow.currentRecordID;
		strCommand = "objGrid.updateRow(objEditWindow.currentRecordID";
	}

	for (var intCtr = 0, intLen = objHeadCells.length; intCtr < intLen; intCtr++)
	{
		var objHeadCell = objHeadCells[intCtr];
		
		var strGridColRef = objHeadCell.id.replace("grid_col_", "");
		
		var objField = null;

		for (var i = 0, intFormLen = objEditWindow.arrFormRefs.length; i < intFormLen; i++)
		{
			var objEWForm = objEditWindow.arrFormRefs[i];
			var objTmpField = objEWForm.getFieldByRef(strGridColRef);
			if (objTmpField != null)
				objField = objTmpField;
			
			if (objTmpField != null && !isBlank(objTmpField.getValue()))
				break;
		}

		if (objField != null)
		{
			// if the form has not been loaded and we are updating the grid, objField.getValue() will return ""
			// so instead pass the original grid column value to updateGrid
			
			if (objForm.editMode == "update" && objField.objForm.flgFiredOnload == false) 	
				var strValue = String(this.Grid.getColumnValue(strSelectID, strGridColRef));
			else
			{
				var strValue = objField.getValue();
				
				if (objField.selectOne != null)
				{				
					if (objField.selectOne.listValueOnly == true)
					{
						for (var i=0, intValuesLen = objField.selectOne.Values.length; i < intValuesLen; i++)
						{
							if (objField.selectOne.Values[i] == strValue)
							{
								strValue = objField.selectOne.Captions[i];
								break;
							}
						}
					}
				}

				if (objField.strDataType == "xsd:boolean")
				{
					if (this.Grid.objGridHeadingsXML.selectNodes("/grid/column").item(intCtr).getAttribute("yesno") == "true")
					{
						if (objField.getValue() == "true")
							strValue = fl ("YES");
						else
							strValue = fl("NO");
					}
				}
			}
			
			strValue = EscapeStringBackslash(strValue);
			strValue = EscapeStringDoublequote(strValue);

			strCommand += ", \"" + strValue + "\"";
		}
		else
		{
			if (strGridColRef != "uniqueid")
			{
				if (flgIgnoreMissingColumns == true)
					strCommand += ", null";
				else
					alert("Cannot find form field (" + strGridColRef + ") but it exists in the grid - the grid-ref and form-ref should match.");
			}
		}
	}
	
	strCommand += ")";

	var regEx = /\n/g;
	strCommand = strCommand.replace(regEx, " ");

	var regEx = /\r/g;
	strCommand = strCommand.replace(regEx, "");

	var evalFunction = new Function("objEditWindow", "objGrid", strCommand);
	evalFunction(objEditWindow, objGrid);
	
	objGrid.selectRow(strSelectID);	
}

function ewm_newRecord(AppWindow)
{
	// Close any child windows of the passed AppWindow.
	for (var i=0, intLen = objApplication.arrEditWindowManagers.length; i < intLen; i++)
	{
		var objEWM = objApplication.arrEditWindowManagers[i];
		if (objEWM != null && AppWindow == objEWM.AppWindow)
			objEWM.closeAll();
	}

	this.flgRemoveEditWindow = false;
	this.onBeforeUnload(AppWindow);
	this.flgRemoveEditWindow = true;

	var objEditWindow = this.getEditWindow(AppWindow);
	var objAppWindowTextEditor = null;
	var objAppWindowDocManager = null;

	if (objEditWindow.Form.tabbedDialog != null && objEditWindow.Form.tabbedDialog.TextEditor != null)
		objAppWindowTextEditor = objEditWindow.Form.tabbedDialog.TextEditor;
	if (objEditWindow.Form.tabbedDialog != null && objEditWindow.Form.tabbedDialog.documentManager != null)
		objAppWindowDocManager = objEditWindow.Form.tabbedDialog.documentManager;

	if (objEditWindow.Form.isInvalid()){
		if (eMsgBox(fl("RECORDERRORS"), vbYesNo, msg_Exclamation, AppWindow) == vbNo)
			return;
	}else{
		if (objAppWindowTextEditor != null) {
			if (objAppWindowTextEditor.isNotesDirty())
			{
				if (eMsgBox(fl("SAVEENOTESCHANGES"), vbYesNo, msg_Exclamation, AppWindow) == vbYes)
					objAppWindowTextEditor.performOperation(AppWindow, 'save');
			}
		}
	}
	
	if (objAppWindowTextEditor != null)
		objAppWindowTextEditor.emptyNotesXML();
	
	if (objAppWindowDocManager != null)
	{
		objAppWindowDocManager.documentKeys = null;
		if (objEditWindow.Form.tabbedDialog.getCurrentTab().strRef  == objEditWindow.Form.tabbedDialog.strDocumentTab)
			objEditWindow.Form.tabbedDialog.arrTabs[0].select();
	}
	
	objEditWindow.Form.editMode = "add";
	objEditWindow.editMode = "add";
	objEditWindow.syncFormEditModes();

	objEditWindow.dataprocessXML = null;
	this.resyncForm(AppWindow);

	// Set all forms as valid - i.e. the same as when the page first loaded.
	for (var i = 0, intLen = objEditWindow.arrFormRefs.length; i < intLen; i++)
	{
		var objForm = objEditWindow.arrFormRefs[i];
		for (var j = 0, intJLen = objForm.fields.length; j < intJLen; j++)
		{
			var objField = objForm.fields[j];
			if (objField.isInvalid == true)
				objField.setValid();
		}
	}

	// Set focus on first editable field.
	for (var i = 0, intLen = objEditWindow.arrFormRefs.length; i < intLen; i++)
	{
		var objForm = objEditWindow.arrFormRefs[i];
		if (objForm.setInitialFocus() == true)
			break;
	}

	if (AppWindow.document.body.initialFocusId != null)
	{
		try {
			AppWindow.document.getElementById(AppWindow.document.body.initialFocusId).focus();
		} catch (objError) {
		}
	}

	if (typeof(AppWindow.window_onloadrecord) != "undefined")
		AppWindow.window_onloadrecord();

	objApplication.performADAPTScript(ADAPT_ONAPPLICATIONLOADRECORD, AppWindow);
}

function ewm_selectRecordById(strUniqueId, objEditWindow)
{
	var AppWindow = objEditWindow.AppWindow;

	this.flgRemoveEditWindow = false;
	this.onBeforeUnload(AppWindow);
	this.flgRemoveEditWindow = true;
	
	if (objEditWindow.Form.isInvalid())
		return;
	
	// Make sure the edit mode for the window is correct. (Might be reusing 
	// a window and changing from e.g. add to update.  In this case by default the 
	// mode will still be that of the original record.)
	if (strUniqueId != null)
		objEditWindow.editMode = "update";
	else
		objEditWindow.editMode = "add";
	
	objEditWindow.syncFormEditModes();
	this.resyncForm(AppWindow, strUniqueId);

	if (typeof(AppWindow.window_onloadrecord) != "undefined")
		AppWindow.window_onloadrecord();

	this.setToolBarButtonStates(AppWindow);
	this.checkWindowAlreadyOpen(AppWindow);

	objApplication.performADAPTScript(ADAPT_ONAPPLICATIONLOADRECORD, AppWindow);
}

function ewm_firstRecord(AppWindow)
{
	this.moveToRecord(AppWindow, EWM_FIRST);
}

function ewm_previousRecord(AppWindow)
{
	this.moveToRecord(AppWindow, EWM_PREVIOUS);
}

function ewm_nextRecord(AppWindow)
{
	this.moveToRecord(AppWindow, EWM_NEXT);
}

function ewm_lastRecord(AppWindow)
{
	this.moveToRecord(AppWindow, EWM_LAST);
}

function ewm_moveToRecord(AppWindow, flgLocation)
{
	var objEditWindow = this.getEditWindow(AppWindow);
	
	this.flgRemoveEditWindow = false;
	this.onBeforeUnload(AppWindow);
	this.flgRemoveEditWindow = true;

	if (objEditWindow.Form.isInvalid())
		return;

	if (objEditWindow.Form.tabbedDialog != null && objEditWindow.Form.tabbedDialog.TextEditor != null){
		if (objEditWindow.Form.tabbedDialog.TextEditor.isNotesDirty())
		{
			if (eMsgBox(fl("SAVEENOTESCHANGES"), vbYesNo, msg_Exclamation, AppWindow) == vbYes)
				objEditWindow.Form.tabbedDialog.TextEditor.performOperation(AppWindow, 'save');
		}
		objEditWindow.Form.tabbedDialog.TextEditor.emptyNotesXML();
	}

	this.initialiseGrid();

	var intRowIndex = this.Grid.getRowIndex(objEditWindow.currentRecordID);

	if (flgLocation & EWM_FIRST)
		intRowIndex = 0;
	else if (flgLocation & EWM_LAST)
		intRowIndex = this.Grid.HTMLtable.tBodies[0].rows.length - 1;
	else if (flgLocation & EWM_NEXT)
		intRowIndex ++;
	else if (flgLocation & EWM_PREVIOUS)
		intRowIndex --;

	/* Safety valve to stop "array index out of bounds" errors. */
	if (intRowIndex == this.Grid.HTMLtable.tBodies[0].rows.length)
		intRowIndex --;
	else
	if (intRowIndex == -1)
		intRowIndex = 0;

	var lngNewID = this.Grid.HTMLtable.tBodies[0].rows[intRowIndex].cells[0].innerHTML;

	this.Grid.selectRow(lngNewID);

	this.resyncForm(AppWindow, lngNewID);

	if (typeof(AppWindow.window_onloadrecord) != "undefined")
		AppWindow.window_onloadrecord();

	objApplication.performADAPTScript(ADAPT_ONAPPLICATIONLOADRECORD, AppWindow);

	// Make sure only one window per record.	
	this.checkWindowAlreadyOpen(AppWindow);	
	this.setToolBarButtonStates(AppWindow);
}

function ewm_resyncForm(AppWindow, lngUniqueID)
{
	var objEditWindow = this.getEditWindow(AppWindow);

	objApplication.Debug.writeTime("RESYNC FORMS BEGIN", "file-name=ssEditWindowManager.js");

	if (objEditWindow.editMode == "add")
	{
		var objNode = objApplication.Data.generateNewRow(objEditWindow.Form.schemaName);

		if (objApplication.Modules("0020a-docm") && objEditWindow.Form.hasDocs())
			this.showDocumentTab(objEditWindow);

		objApplication.Debug.writeTime("RESYNC FORM - generated new row", "file-name=ssEditWindowManager.js");

		// Point data-entry form to scratch XML buffer area...
		for (var i = 0, intLen = objEditWindow.arrFormRefs.length; i < intLen; i++)
		{
			var objForm = objEditWindow.arrFormRefs[i];

			if (objForm.schemaName == objEditWindow.Form.schemaName)
				objForm.setXMLDataLocation(objNode, "/*");
		}
	}
	else if (!isBlank(this.populateFormDataMethod))
	{
		var evalFunction = new Function("AppWindow", "AppWindow.opener." + this.populateFormDataMethod);
		evalFunction(AppWindow);
	}
	else
	{
		// Load the record from the database.
		var objXML = this.loadRecord(lngUniqueID, AppWindow);
		
		if (objApplication.hadCriticalError || objXML == null)
			return;

		if (objXML.selectSingleNode(this.XPath) == null)
		{
			eMsgBox("Data Error.<p></p>Cannot open record.<p></p>Business Entity : " + objEditWindow.Form.schemaName + "<p></p>Key Values : " + this.getPrimaryKeyValueList(lngUniqueID, AppWindow) + "<p></p>Please contact your system administrator", vbOKOnly, msg_Critical, AppWindow);
			AppWindow.close();
			return;
		}

		// Strip off collection wrapper.
		strXML = objXML.selectSingleNode(this.XPath).xml();
		objXML.loadXML(strXML);

		if (objApplication.Modules("0020a-docm") && objEditWindow.Form.hasDocs())
			this.showDocumentTab(objEditWindow);

		// Point data-entry form to scratch XML buffer area...
		for (var i = 0, intLen = objEditWindow.arrFormRefs.length; i < intLen; i++)
		{
			var objForm = objEditWindow.arrFormRefs[i];
			if (objForm.schemaName == objEditWindow.Form.schemaName)
				objForm.setXMLDataLocation(objXML, "/*");
		}
	}

	objEditWindow.currentRecordID = lngUniqueID;

	// Refresh main edit window form.
	objEditWindow.Form.refresh();
	
	// Refresh all other visible forms.
	for (var i = 1, intLen = objEditWindow.arrFormRefs.length; i < intLen; i++)
	{
		var objForm = objEditWindow.arrFormRefs[i];
		if (objForm.editMode != "filter" && isHTMLElementVisible(objForm.formGroup) && objForm.DOM != null)
			objForm.refresh();
	}

	objApplication.Debug.writeTime("RESYNC FORM - done form refreshes", "file-name=ssEditWindowManager.js");

	// Need to check for critical error - form refresh may have failed with system parameter requests.
	if (objApplication.hadCriticalError == true)
		return;

	this.setCaption(AppWindow, objEditWindow);

	objApplication.Debug.writeTime("RESYNC FORM - set window caption", "file-name=ssEditWindowManager.js");

	// Disable first/next/last/previous buttons if in 'add' mode.
	if (objEditWindow.editMode == "add")
	{
		AppWindow.document.getElementById("btnNext").style.display = "none";
		AppWindow.document.getElementById("btnPrevious").style.display = "none";
		AppWindow.document.getElementById("btnFirst").style.display = "none";
		AppWindow.document.getElementById("btnLast").style.display = "none";
	}

	if (objEditWindow.Form.tabbedDialog != null && ParseStringFromURL("selTab", AppWindow.document.URL) == "eNotes")
	{
		var objTab = objEditWindow.Form.tabbedDialog.getTab(objEditWindow.Form.tabbedDialog.strTextTab);
		if (objTab != null)
			objTab.select();
	}

	// if Enotes tab has focus load Enote details.
	if (objEditWindow.Form.tabbedDialog != null && objEditWindow.Form.tabbedDialog.TextEditor != null){
		if (objEditWindow.Form.tabbedDialog.getTab(objEditWindow.Form.tabbedDialog.strTextTab).hasFocus())
		{
			this.loadNotes(objEditWindow.Form.tabbedDialog.TextEditor, AppWindow);
		}
	}

	if (objEditWindow.Form.tabbedDialog != null && ParseStringFromURL("selTab", AppWindow.document.URL) == "documents")
	{
		var objTab = objEditWindow.Form.tabbedDialog.getTab(objEditWindow.Form.tabbedDialog.strDocumentTab);
		if (objTab != null && objEditWindow.editMode != "add")
			objTab.select();
	}

	// if Documents tab has focus load Document details.
	if (objEditWindow.Form.tabbedDialog != null && objEditWindow.Form.tabbedDialog.strDocumentTab != null){
		// Disable auto documents tab until parent record key details have been saved.
		if (objEditWindow.editMode == "add") {
			objEditWindow.Form.tabbedDialog.getTab(objEditWindow.Form.tabbedDialog.strDocumentTab).disable();
		}
		else if (objEditWindow.Form.tabbedDialog.getTab(objEditWindow.Form.tabbedDialog.strDocumentTab).hasFocus())
		{
			if (objEditWindow.Form.tabbedDialog.documentManager != null)
				objEditWindow.Form.tabbedDialog.documentManager.loadDocuments(AppWindow);
		}
	}
	
	objApplication.Debug.writeTime("RESYNC FORM - checked tab and loaded documents if required", "file-name=ssEditWindowManager.js");

	//Loop through all fields on all forms and fire lookups if present.
	var formArray = objEditWindow.arrFormRefs;
	for (var intFrmIdx = 0, intFrmLen = formArray.length; intFrmIdx < intFrmLen ; intFrmIdx++)
	{
		var fieldArray = formArray[intFrmIdx].fields;
		for (var intFldIdx = 0, intFldLen = fieldArray.length; intFldIdx < intFldLen ; intFldIdx++)
			fieldArray[intFldIdx].processLookups();
	}

	objApplication.Debug.writeTime("RESYNC FORM DONE -  Called applications own window_onloadrecord()", "file-name=ssEditWindowManager.js");
}

/**
 * Displays the documents tab
 * @param objEditWindow The edit window
 */
function ewm_showDocumentTab(objEditWindow)
{
	var objForm = objEditWindow.Form;

	// Show documents tab
	if (objForm.tabbedDialog != null)
		objForm.tabbedDialog.EditWindowManager = this;
	else
		return;
		
	objForm.tabbedDialog.getTab(objEditWindow.Form.tabbedDialog.strDocumentTab).show();
}

function ewm_setCaption(AppWindow, objEditWindow)
{
	var strCaption;

	if (objEditWindow.editMode == "add")
		strCaption = fl("ADDRECORD", AppWindow.m_strDisplayName);
	else
		strCaption = fl("UPDATERECORD", AppWindow.m_strDisplayName)

	// Remove bold tags - not valid in window captions.
	for ( ; strCaption.indexOf("<b>") != -1 ; )
		strCaption = strCaption.replace("<b>", "").replace("</b>", "");

	AppWindow.setWindowCaption(strCaption);
}

// Passed a operational mode.  This is normally either "add" or "update" 
// depending on whether you are adding a new record or updating an existing record.
function ewm_openChildWindow(strMode, AppWindow, lngUniqueID, strURLArgs)
{
	var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Applications_HTML/" + this.applicationName;
	strURL += "?mode=" + strMode;    	
	strURL += "&uniqueid=" + replaceForURL(b64Encode(lngUniqueID));
	if (!isBlank(objApplication.appID))
	{	
		strURL += "&appid=" + objApplication.appID;
		strURL += "&menuid=" + objApplication.menuID;
	}

	if (strURLArgs != null)
		strURL += strURLArgs

	if (strMode != "add")
	{
		for (var intCtr = 0, intLen = this.arrEditWindows.length; intCtr < intLen; intCtr++)
		{
			if (this.arrEditWindows[intCtr].currentRecordID == lngUniqueID)
			{
				this.arrEditWindows[intCtr].AppWindow.document.body.focus();
				return;
			}
		}
	}

	if (this.windowsOpened > 0)
	{
		var objParam = objApplication.Data.getSystemParameter("MULTIPLEEDITS");
		
		if (objApplication.hadCriticalError)
		{
			this.closeAll();
			return;
		}

		if (objParam.selectSingleNode("spvalue/value").getText() == "0" || (this.Grid != null && this.Grid.selectType == "single"))
		{
			// If a window is open and multipleedits is set to 0 then reuse the window
			// If a window is in the process of being opened (i.e. windowsOpened > 0 but 
			// the array of edit windows is empty) then there is no point in trying to open another window 
			// because multipleedits is 0 or we are only allowed to open one window.
			if (this.arrEditWindows[0] != null)
			{
				if (strMode != "add")
				{
					this.selectRecordById(lngUniqueID, this.arrEditWindows[0]);
					this.arrEditWindows[0].AppWindow.focus();
				}
				else
				{
					this.newRecord(this.arrEditWindows[0].AppWindow);
				}
			}
			return;
		}
	}

	var objParam = objApplication.Data.getSystemParameter("MAXEDITWINDOWS");

	if (objApplication.hadCriticalError)
	{
		this.closeAll();
		return;
	}

	var intMaxEditWindows = Number(objParam.selectSingleNode("spvalue/value").getText());

	if (this.windowsOpened >= intMaxEditWindows)
	{
		// Attempting to open more records than allowed.  
		// If all windows have been set then reuse the last one for the newly selected one.
		// Otherwise ignore the request as we must have at least one window in the process of being initialised anyway.
		if (this.windowsOpened == this.arrEditWindows.length)
		{
			if (strMode != "add")
			{
				this.selectRecordById(lngUniqueID, this.arrEditWindows[intMaxEditWindows - 1]);
				this.arrEditWindows[intMaxEditWindows - 1].AppWindow.focus();
			}
			else
			{
				this.newRecord(this.arrEditWindows[intMaxEditWindows - 1].AppWindow);
			}
		}
		return;
	}

	var strTargetName = objApplication.EfacsApplet.getWindowTargetName(this.applicationName.replace(".", "_"));
	// hyphens are not legal in the Window.Open command
	var regEx = /\-/g;
	strTargetName = strTargetName.replace(regEx, "_");

	// Generate the features string
	// Basically turn off everything apart from resizing and set window position
	var strFeatures = "directories=no, location=no, menubar=no,";
	strFeatures += " scrollbars=no, status=no, titlebar=no,";
	strFeatures += " toolbar=no, resizable=yes";
	strFeatures += objApplication.PersistentXML.getWindowSettings(strURL, false);

	// Calculate the full address for the Child
	var strAddress = strURL;
	// Append targetname to url - this uniquely identifies each window.
	strAddress += "&targetname=" + strTargetName;

	// Open the Child window.
	// URL  Name for target plus features.
	AppWindow.open(strAddress, strTargetName, strFeatures);
	
	this.windowsOpened++;
}

function ewm_checkWindowAlreadyOpen(AppWindow)
{
	var objCurrentEditWindow = this.getEditWindow(AppWindow);
	var objEditWindow;

	for (var intCtr = 0, intLen = this.arrEditWindows.length; intCtr < intLen; intCtr++)
	{
		objEditWindow = this.arrEditWindows[intCtr];
		if (objEditWindow != null && objCurrentEditWindow != objEditWindow)
		{
			if (objCurrentEditWindow.currentRecordID == objEditWindow.currentRecordID)
			{
				// Need to check whether the information is the same in the window we are closing
				// as the one we are loading
				if (objCurrentEditWindow.Form != objEditWindow.Form)
				{
					var objNodes = objEditWindow.Form.DOM.selectNodes(".//*[original != value]");
					var objCurrentXML = objCurrentEditWindow.Form.DOM;
					for (var objNode = objNodes.nextNode(); objNode != null; objNode = objNodes.nextNode())
					{
						objCurrentXML.selectSingleNode(objNode.nodeName() + "/value").setText(objNode.selectSingleNode("value").getText());
					}
				}	
				// Any notes changes?
				this.updateENotes(objEditWindow, objCurrentEditWindow);

				objEditWindow.AppWindow.document.body.onbeforeunload = null;
				objEditWindow.AppWindow.ignoreOnBeforeUnload = true;
				objApplication.removeForm(objEditWindow.Form);
					
				objEditWindow.AppWindow.close();				
				this.removeEditWindow(objEditWindow.AppWindow);
				objCurrentEditWindow.Form.refresh();
				
			}
		}
	}
}

/**
 *  Determines whether eNotes have changed and need relecting in the new window.
 *  This should only be called internally.
 *  This is used when navigating from one record to another and the eNotes
 *  for the record that is being navigated to have been changed in a window 
 *  that is already open.
 *  The changes in eNotes in the original window should be reflected in the new 
 *  window (ie the one navigation is taking place in) but not saved until the user
 *  actually saves or confirms they want to save on exit from the window.
 *  
 *  @param objEditWindow The original edit window where the notes have been changed.
 *  @param objCurrentEditWindow The edit window where the navigation is taking place.
 */
function ewm_updateENotes(objEditWindow, objCurrentEditWindow)
{
	// First get reference to the Text Editor
	//var strENotes = objEditWindow.AppWindow.m_strTextEditor;
	var objExistingEditor = objEditWindow.Form.tabbedDialog.TextEditor;
	if (objExistingEditor != null)
	{
		if (objExistingEditor.isNotesDirty() == true)
		{
			// We now know they've changed, get a reference to the texteditor in the current window.
			//var strCurrentENotes = objCurrentEditWindow.AppWindow.m_strTextEditor;
			var objCurrentEditor = objCurrentEditWindow.Form.tabbedDialog.TextEditor;
			if (objCurrentEditor != null)
			{
				// Force the eNotes tab to be selected
				var tabbedDialogID = objCurrentEditor.tabbedDialogID;
				var eNotesTab = objCurrentEditWindow.AppWindow[tabbedDialogID].getTab("txt" + tabbedDialogID);
				if (eNotesTab != null)
					eNotesTab.select();
				else
					return;

				// Get the text from the original, edited window
				var editText = objExistingEditor.objEditor.getText();
	
				if (!objCurrentEditor.appletReady)
				{
					// So now update to the edited value and ensure the applet is initialised.
					var editElement = objCurrentEditor.XMLDetail.selectSingleNode("//emediadetail[emediaid/value='" + objCurrentEditor.emediaID +
						"' and emediatype/value='" + objCurrentEditor.sTextType +
						"' and keyvalue1/value='" + objCurrentEditor.keys[0] +
						"' and keyvalue2/value='" + objCurrentEditor.keys[1] +
						"' and keyvalue3/value='" + objCurrentEditor.keys[2] +
						"' and keyvalue4/value='" + objCurrentEditor.keys[3] +
						"']");

					if (editElement != null)
						editElement.selectSingleNode("data/value").setText(editText);
					else
						objCurrentEditor.XMLDetail = objExistingEditor.XMLDetail;
						
					objCurrentEditor.initialise();
					objCurrentEditor.changeEditorMode();
				}
				else
				{
					objCurrentEditor.XMLDetail = objExistingEditor.XMLDetail;
					objCurrentEditor.loadDetail();
				}

				objCurrentEditor.unsavedNotes = true;
			}
		}
	}
}

/**
 * Removes selected records.
 *
 * @param arrUniqueIDs - an array containing the unique ID's of the selected records.
 */
function ewm_removeRecords(arrUniqueIDs)
{
	this.removeOpenWindows(arrUniqueIDs);
	
	if (typeof(this.AppWindow[this.id + "_removeRecords"]) != "undefined") {
		this.AppWindow[this.id + "_removeRecords"](arrUniqueIDs);

		return;
	}

	var blnDeletedSome = false;
	for (intCtr = 0, intLen = arrUniqueIDs.length; intCtr < intLen; intCtr++)
	{
		// MCB - want to be able to call detelet on the bean with primary key information - but not supported yet.		
		// so for now we need to load the deleted records, flag them as deleted and then call save.
		var objXML = this.loadRecord(arrUniqueIDs[intCtr]);

		if (objApplication.hadCriticalError)
		{
			this.closeAll();
			return;
		}

		objXML.selectSingleNode("//*[@isdeleted = 'false']").setAttribute("isdeleted", "true");

		var strBeanName;
		if (this.primaryKeyClassName == null)
			strBeanName = this.DataEngine.className.substring(this.DataEngine.className.lastIndexOf(".") + 1, this.DataEngine.className.length).replace("Bean", "");
		else
			strBeanName = this.primaryKeyClassName;
			
		var objRPCObject = null;
		
		if (this.strCustomEntityName == null) {
			objRPCObject = new RPCObject(strBeanName, this.AppWindow);
			objRPCObject.execute("Save", objApplication.Connection.strConnectionString, objXML.xml());
		} else {
			objRPCObject = new RPCObject("genericbusinessobject", this.AppWindow);
			objRPCObject.execute("Save", objApplication.Connection.strConnectionString, objXML.xml(), this.strCustomEntityName);
		}

		if (!objRPCObject.FAILED) {
			this.Grid.deleteRow(arrUniqueIDs[intCtr]);
			blnDeletedSome = true;
		}
	}
	
	if (blnDeletedSome && this.Grid.Tree != null) {
		// Refresh the entire tree since these nodes may have been in other
		// places
		this.Grid.Tree.refresh();
	}
}

/**
 * Closes any open windows.  This method should be called to ensure windows are closed 
 * before deleteing the records
 * @param arrUniqueIDs Array of unique ids relating to the records for which windows 
 *                     should be closed.
 */
 
function ewm_removeOpenWindows(arrUniqueIDs)
{
	var intUniqueIDCtr;

	for (var intCtr = 0, intLen = this.arrEditWindows.length; intCtr < intLen; intCtr++)
	{
		for (intUniqueIDCtr = 0, intJLen = arrUniqueIDs.length; intUniqueIDCtr < intJLen; intUniqueIDCtr++)
		{
			if (this.arrEditWindows[intCtr].currentRecordID == arrUniqueIDs[intUniqueIDCtr])
			{
				this.arrEditWindows[intCtr].AppWindow.close();
				break;
			}
		}
	}
}

function ewm_loadRecord(lngUniqueId, AppWindow)
{
	var strCommand;
	var strValue;

	if (AppWindow)
		var objEditWindow = this.getEditWindow(AppWindow);

	var strBeanName;
	if (this.primaryKeyClassName == null)
		strBeanName = this.DataEngine.className.substring(this.DataEngine.className.lastIndexOf(".") + 1, this.DataEngine.className.length).replace("Bean", "");
	else
		strBeanName = this.primaryKeyClassName;
		
	var objRPCObject = new RPCObject(strBeanName, AppWindow);

	if (this.primaryKeyClassMethod == null)
		strCommand = "objRPCObject.execute(\"Load\", objApplication.Connection.strConnectionString";
	else
		strCommand = "objRPCObject.execute(primaryKeyClassMethod, objApplication.Connection.strConnectionString";
	
	for (var intPK = 0, intLen = this.arrPrimaryKeyFields.length; intPK < intLen; intPK++)
	{
		strValue = null;
		objPrimaryKeyField = this.arrPrimaryKeyFields[intPK];

		if (objPrimaryKeyField.formID != null) {
			strValue = objApplication.Forms(objPrimaryKeyField.formID).getFieldByRef(objPrimaryKeyField.fieldRef).getValue();
		} else if (objPrimaryKeyField.methodName != null) {
			strValue = eval("this.AppWindow." + objPrimaryKeyField.methodName);
		} else if (objPrimaryKeyField.variableName != null) {
			strValue = this.AppWindow[objPrimaryKeyField.variableName];
		} else if (objPrimaryKeyField.value != null) {
			strValue = objPrimaryKeyField.value;
		} else if (objPrimaryKeyField.gridColumnRef != null) {
			if (this.Grid == null)
				this.Grid = objApplication.Grids(this.gridId);

			// Get cell index;
			var objCells = this.Grid.HTMLtable.tHead.rows[0].cells;
			var intIndex = 0;
			for (var intCell = 0, intJLen = objCells.length; intCell < intJLen; intCell++)
			{
				if (objCells[intCell].id.replace("grid_col_", "") == objPrimaryKeyField.gridColumnRef)
				{
					intIndex = intCell;
					break;
				}
			}

			var intRowNumber;
			var objRows = this.Grid.HTMLtable.tBodies[0].rows;
			for (var intRow = 0, intJLen = objRows.length; intRow < intJLen; intRow++)
			{
				if (unescapeXML(objRows[intRow].cells[0].innerHTML) == lngUniqueId)
				{
					intRowNumber = intRow;
					break;
				}
			}

			strValue = this.Grid.HTMLtable.tBodies[0].rows[intRowNumber].cells[intIndex].innerHTML;
			strValue = unescapeXML(strValue);
						
			if (isBlank(strValue))
				strValue = "";
			else
			{
				var strDataType = this.Grid.objGridHeadingsXML.selectNodes("/grid/column").item(intIndex).getAttribute("datatype");
				if (strDataType == "xsd:float" || strDataType == "xsd:double" || strDataType == "xsd:integer" || 
					strDataType == "xsd:decimal" || strDataType == "xsd:smallint" || strDataType == "xsd:short")
				{
					strValue = objApplication.EfacsApplet.parseNumber(strValue);
				}
			}
		}

		if (objPrimaryKeyField.dataType == "xsd:dateTime")
		{
			// make sure the date really is in ISO
			if (! isISODate (strValue)) {
				var objEfacsCalendar=objApplication.getCalendarParser();
				objEfacsCalendar.setDateTimeInLocaleFormat(strValue);
				strValue = objEfacsCalendar.getDateTimeInISO();
			}	
		}

		// if this is a string, we need to see that any backslash characters are escaped.
		if (objPrimaryKeyField.dataType == "xsd:string")
			strValue = EscapeStringBackslash(strValue);

		if (objPrimaryKeyField.dataType == "xsd:boolean" || objPrimaryKeyField.dataType == "xsd:integer")
			strCommand += ", " + strValue;
		else
			strCommand += ", \"" + EscapeStringDoublequote(strValue) + "\"";
	}
	strCommand += ");";
	
	var evalFunction = new Function("AppWindow", "primaryKeyClassMethod", "objRPCObject", strCommand);
	evalFunction(this.AppWindow, this.primaryKeyClassMethod, objRPCObject);

	if (objRPCObject.FAILED == false)
	{
		if (AppWindow)
			objEditWindow.dataprocessXML = objRPCObject.getReturnedXMLDom().selectSingleNode("/*/dataprocess").xml();

		return objRPCObject.getReturnedXMLDom();
	}
}

function ewm_removeEditWindow(AppWindow)
{
	if (this.flgRemoveEditWindow == false)
		return;

	var objCurrentEditWindow = this.getEditWindow(AppWindow);
	
	var arrNewArray = new Array();
	var flgFound = false;
	for (var intCtr = 0, intLen = this.arrEditWindows.length; intCtr < intLen; intCtr++)
	{
		if (objCurrentEditWindow != this.arrEditWindows[intCtr])
			arrNewArray[arrNewArray.length] = this.arrEditWindows[intCtr];
		else {
			flgFound = true;
			this.arrEditWindows[intCtr].destroy();
			this.arrEditWindows[intCtr] = null;
		}
	}
	if (flgFound)
	{
		this.arrEditWindows = arrNewArray;
		this.windowsOpened--;
	}
}

// Constructor for edit window object
function ewm_EditWindow(objForm, strEditMode, AppWindow)
{
// properties
	this.Form = objForm;
	this.editMode = strEditMode;
	this.currentRecordID = null;
	this.AppWindow = AppWindow;
	this.objRecordList = null;						// Record list object.
	this.dataprocessXML = null;
	this.arrFormRefs = new Array();

// methods
	this.syncFormEditModes = ew_syncFormEditModes;
	this.destroy = ew_destroy;
}

/**
 * Clear references for the edit window
 */
function ew_destroy() {
	try {
		this.Form = null;
		this.editMode = null;
		this.currentRecordID = null;
		this.AppWindow = null;
		this.objRecordList = null;
		this.dataprocessXML = null;
		if (this.arrFormRefs != null) {
			for (var i = 0, len = this.arrFormRefs.length; i < len; i++ ) {
				this.arrFormRefs[i] = null;
			}
			this.arrFormRefs = null;
		}
	} catch (error) {
	}
}

function ewm_setToolBarButtonStates(AppWindow)
{
	var objEditWindow = this.getEditWindow(AppWindow);

	this.initialiseGrid();

	var objToolbar = util_getToolbarFromButton(AppWindow.document.getElementById("btnNext"), AppWindow);

	if (objToolbar == null)
		return;
		
	if (objEditWindow.editMode == "add" || this.Grid == null || this.Grid.HTMLtable.tBodies[0].rows.length == 1)
	{
		if (objToolbar.getButton("btnNext").isVisible() == true)
		{
			objToolbar.getButton("btnNext").hide();
			objToolbar.getButton("btnPrevious").hide();
			objToolbar.getButton("btnFirst").hide();
			objToolbar.getButton("btnLast").hide();
		}
		return;
	}
	else
	{
		// If one button is hidden the rest will be.
		if (objToolbar.getButton("btnNext").isVisible() == false)
		{
			// Ensure the navigation buttons are visible.  This is for cases where 
			// we change from add to update mode.
			objToolbar.getButton("btnNext").show();
			objToolbar.getButton("btnPrevious").show();
			objToolbar.getButton("btnFirst").show();
			objToolbar.getButton("btnLast").show();
		}
	}

	var intCurrentRowIndex = this.Grid.getRowIndex(objEditWindow.currentRecordID);

	if (intCurrentRowIndex == this.Grid.HTMLtable.tBodies[0].rows.length - 1)
	{
		objToolbar.getButton("btnNext").disable();
		objToolbar.getButton("btnLast").disable();
	}
	else
	{
		objToolbar.getButton("btnNext").enable();
		objToolbar.getButton("btnLast").enable();
	}

	if (intCurrentRowIndex == 0)
	{
		objToolbar.getButton("btnPrevious").disable();
		objToolbar.getButton("btnFirst").disable();
	}
	else
	{
		objToolbar.getButton("btnPrevious").enable();
		objToolbar.getButton("btnFirst").enable();
	}
}

function ewm_closeAll()
{
	for (var intCtr = this.arrEditWindows.length - 1; intCtr >= 0; intCtr--)
	{
		var objWindow = this.arrEditWindows[intCtr].AppWindow;

		if (typeof(objWindow.document) != "unknown")
		{
			objWindow.document.body.focus();
			objWindow.appTrans_onbeforeunload();
			objWindow.document.body.onbeforeunload = null;
			objWindow.ignoreOnBeforeUnload = true;
		}
		objWindow.close();
	}
	this.windowsOpened = 0;
}

function ewm_setupWithDataEngine()
{
	var strValue;
	this.Grid = objApplication.Grids(this.gridId);

	if (this.Grid == null)
		return;

	if (!isBlank(this.DataEngine.classMethod))
	{
		// Setup any input parameters
		this.DataEngine.clearInputParameters();
		
		if (this.strCustomEntityName == null) {

			for (var intCtr = 0, intLen = this.arrBeanParams.length; intCtr < intLen; intCtr++)
			{
				strValue = "";
				objBeanParam = this.arrBeanParams[intCtr];

				var strDataType = null;
				if (!isBlank(objBeanParam.dataType))
					strDataType = objBeanParam.dataType;

				if (objBeanParam.formID != null) {
					strValue = objApplication.Forms(objBeanParam.formID).getFieldByRef(objBeanParam.fieldRef).getValue();
				} else if (objBeanParam.methodName != null) {
					strValue = eval("this.AppWindow." + objBeanParam.methodName);
				} else if (objBeanParam.variableName != null) {
					strValue = this.AppWindow[objBeanParam.variableName];
				} else if (objBeanParam.value != null) {
					strValue = objBeanParam.value;
				}

				this.DataEngine.addInputParameter("PM" + intCtr, strValue, null, null, strDataType);
			} 
		} else {
			if (this.DataEngine.classMethod == "loadAll") {
				// loadAll is a special case for generic object pass in the custom object name as a parameter
				this.DataEngine.addInputParameter("PM1", this.strCustomEntityName, null, null, "xsd:string");
			} else {
				for (var intCtr = 0, intLen = this.arrBeanParams.length; intCtr < intLen; intCtr++)
				{
					strValue = "";
					objBeanParam = this.arrBeanParams[intCtr];

					var strDataType = null;
					if (!isBlank(objBeanParam.dataType))
						strDataType = objBeanParam.dataType;

					if (objBeanParam.formID != null) {
						strValue = objApplication.Forms(objBeanParam.formID).getFieldByRef(objBeanParam.fieldRef).getValue();
					} else if (objBeanParam.methodName != null) {
						strValue = eval("this.AppWindow." + objBeanParam.methodName);
					} else if (objBeanParam.variableName != null) {
						strValue = this.AppWindow[objBeanParam.variableName];
					} else if (objBeanParam.value != null) {
						strValue = objBeanParam.value;
					}

					this.DataEngine.addInputParameter("PM" + intCtr, strValue, null, null, strDataType);
				} 
			}
		}

		var strHTML = this.DataEngine.populateEngine();
		
		if (objApplication.hadCriticalError)
		{
			this.closeAll();
			return;
		}
		
		if (!isBlank(strHTML) && strHTML.substring(0, 6) != "<error")
		{
			this.Grid.HTMLdiv.innerHTML = escapeStringDoubleSpaces(strHTML);
			this.Grid.HTMLtable = this.Grid.objAppWindow.document.getElementById("et_grd" + this.Grid.id);
		}
		else
			this.Grid.setupTableHeadings();

		this.Grid.setup();
	}
}

function ewm_addBeanParameter(flgParamType)
{
	var objBeanParam = new EWMBeanParameter();
	
	if (flgParamType & EWM_FORMPARAM)
	{
		objBeanParam.formID = arguments[1];
		objBeanParam.fieldRef = arguments[2];
		objBeanParam.dataType = arguments[3];
	}
	else if (flgParamType & EWM_METHODPARAM)
	{
		objBeanParam.methodName = arguments[1];
		objBeanParam.dataType = arguments[2];
	}
	else if (flgParamType & EWM_VARIABLEPARAM)
	{
		objBeanParam.variableName = arguments[1];
		objBeanParam.dataType = arguments[2];
	}
	else if (flgParamType & EWM_VALUEPARAM)
	{
		objBeanParam.value = arguments[1];
		objBeanParam.dataType = arguments[2];
	}

	if (isBlank(objBeanParam.dataType))
		objBeanParam.dataType = "xsd:string";

	this.arrBeanParams[this.arrBeanParams.length] = objBeanParam;
}

// Constructor for BeanParameter
function EWMBeanParameter()
{
	this.formID = null;
	this.fieldRef = null;
	this.methodName = null;
	this.variableName = null;
	this.value = null;
	this.dataType = null;
	this.destroy = ewmBeanParam_destroy;
}

/**
 * Clear references to bean parameter objects
 */
function ewmBeanParam_destroy() {
	try {
		this.formID = null;
		this.fieldRef = null;
		this.methodName = null;
		this.variableName = null;
		this.value = null;
		this.dataType = null;
	} catch (error) {
	}
}

function ewm_addPrimaryKeyField(flgParamType)
{
	var objPrimaryKeyField = new EWMPrimaryKeyField();
	
	if (flgParamType & EWM_GRIDCOLPARAM)
	{
		objPrimaryKeyField.gridColumnRef = arguments[1];
		objPrimaryKeyField.dataType = arguments[2];
	}
	else if (flgParamType & EWM_FORMPARAM)
	{
		objPrimaryKeyField.formID = arguments[1];
		objPrimaryKeyField.fieldRef = arguments[2];
		objPrimaryKeyField.dataType = arguments[3];
	}
	else if (flgParamType & EWM_METHODPARAM)
	{
		objPrimaryKeyField.methodName = arguments[1];
		objPrimaryKeyField.dataType = arguments[2];
	}
	else if (flgParamType & EWM_VARIABLEPARAM)
	{
		objPrimaryKeyField.variableName = arguments[1];
		objPrimaryKeyField.dataType = arguments[2];
	}
	else if (flgParamType & EWM_VALUEPARAM)
	{
		objPrimaryKeyField.value = arguments[1];
		objPrimaryKeyField.dataType = arguments[2];
	}
	
	if (isBlank(objPrimaryKeyField.dataType))
		objPrimaryKeyField.dataType = "xsd:string";	
	
	this.arrPrimaryKeyFields[this.arrPrimaryKeyFields.length] = objPrimaryKeyField;
}

// Constructor for BeanParameter
function EWMPrimaryKeyField()
{
	this.gridColumnRef = null;
	this.formID = null;
	this.fieldRef = null;
	this.methodName = null;
	this.variableName = null;
	this.value = null;
	this.dataType = null;
	this.destroy = ewmPKField_destroy;
}

/**
 * Clear references for the primary key field objects
 */
function ewmPKField_destroy() {
	try {
		this.gridColumnRef = null;
		this.formID = null;
		this.fieldRef = null;
		this.methodName = null;
		this.variableName = null;
		this.value = null;
		this.dataType = null;
	} catch (error) {
	}
}

function ewm_setUpdateMode(strUniqueId, AppWindow)
{
	var objEditWindow = this.getEditWindow(AppWindow);
	objEditWindow.Form.editMode = "update";
	objEditWindow.currentRecordID = strUniqueId;
	objEditWindow.syncFormEditModes();
}

/**
 * For future development - will be used to determine if table in field defs
 * supports eNotes. Set to return true for now.
 * 
 * @param strTableName The table name as declared in field definitions.
 * @return true if table supports eNotes - false if not.
 */
function ewm_useNotes(strSchema)
{
	// MCB - change this to read new isenabled column from emedia table for schema.
	return true;
}

/**
 * Loads eNotes for the current record being edited.
 * 
 * @param objTextEditor Reference to text editor object on the eNotes tab.
 * @param AppWindow Reference to window object so correct edit window can be located.
 */
function ewm_loadNotes(objTxtEditor, AppWindow)
{
	// Load notes for specified primary key.
	var objEditWindow = this.getEditWindow(AppWindow);
	
	objTxtEditor.flgLoaded = false;

	var keys = 0;
	if (objEditWindow != null && objEditWindow.Form != null){
		for (var n = 0, intLen = objEditWindow.Form.fields.length; n < intLen; n++) 
		{
			var objField = objEditWindow.Form.fields[n];
			if (objField.HTMLElement.isprimary == "true" && objField.HTMLElement.schemaField == "true"){
				if (keys == 0)
				{
					objTxtEditor.clearKeyValues();
				}
				keys++;

				var strValue = objField.getValue();
				if (objField.strDataType == "xsd:float" || objField.strDataType == "xsd:double" || objField.strDataType == "xsd:decimal")
					strValue = Number(strValue);

				objTxtEditor.setSpecificKeyValue(Number(objField.HTMLElement.primarykeyno), strValue);
			}	
		}
	}
	objTxtEditor.initialise();
}

/**
 * Specifies a function to be executed in the edit window.
 *
 * @param strMethod - the name of the function to be executed.
 * @param objObject An optional object reference to be passed to each child window method.
 */
function ewm_executeChildWindowFunction(strMethod, objObject)
{
    for (var i = 0, intLen = this.arrEditWindows.length; i < intLen; i ++)
    {
        var objWindow = this.arrEditWindows[i].AppWindow;
		
		if (objObject == null) {
			objWindow[strMethod.replace(/(\(\));*/, "")]();
		} else {
			objWindow[strMethod.replace(/(\(\));*/, "")](objObject);
		}
    }
}

/**
 * Adds a reference to other forms on this page not being directly managed
 * by edit window manager.
 *
 * @param objForm The form reference.
 * @param AppWindow The window reference on which the form exists.
 */
function ewm_addFormReference(objForm, AppWindow)
{
	var objEditWindow = this.getEditWindow(AppWindow);
	if (objEditWindow != null)
		objEditWindow.arrFormRefs[objEditWindow.arrFormRefs.length] = objForm;
}

/**
 * Synchronizes the edit mode statuses for all forms on this edit window.
 */
function ew_syncFormEditModes()
{
	for (var i=0, intLen = this.arrFormRefs.length; i < intLen; i++)
	{
		var objForm = this.arrFormRefs[i];
		if (objForm.editMode != "filter")
		{
			
			if (objForm.schemaName != null && this.Form.schemaName != null && objForm.schemaName.toLowerCase() == this.Form.schemaName.toLowerCase())
				objForm.editMode = this.editMode;
			else
				objForm.editMode = "update";

			if (objForm.isInitialised)
				objForm.setPrimaryKeyStates();
		}
	}
}

/**
 * Loads all child window forms into IFRAMES - some of them will be pre-populated with data.
 *
 * @param AppWindow The window object.
 * @param strClassName The bean class name.
 * @param strLoadMethod The load method name.
 * @param strSaveMethod The save method name.
 * @param strXPath The xpath into the business data.
 */
function ewm_loadChildWindowForms(AppWindow, strClassName, strLoadMethod, strSaveMethod, strXPath)
{
	this.strClassName = strClassName;
	this.strLoadMethod = strLoadMethod;
	this.strSaveMethod = strSaveMethod;
	this.XPath = strXPath;

	var lngUniqueId = ParseStringFromURL("uniqueid", AppWindow.document.URL);
	lngUniqueId = b64Decode(undoReplaceForURL(lngUniqueId));

	var objEditWindow = this.addNewEditWindow(null, AppWindow);
	AppWindow.AppTranslator_autoSetupEditWindowManagerForms();
	objEditWindow.Form = objEditWindow.arrFormRefs[0];

	for (var i=5, intLen = arguments.length; i < intLen; i++)
	{
		var objForm = arguments[i];
		objForm.fields = new Array();

		var strSchemaName = objForm.schemaName;
		if (isBlank(strSchemaName))
			strSchemaName = "none";
		
		var strEditMode = ParseStringFromURL("mode", AppWindow.document.URL);
		if (strEditMode == null)
		{
			strEditMode = "add";

			for (var j = 0, intJLen = objEditWindow.arrFormRefs.length; j < intJLen; j++)
			{
				objEditWindow.arrFormRefs[j].editMode = "add";
			}
			objEditWindow.editMode = "add";
		}

		var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/servlet/FormProcessorServlet" +
			"?formID=" + replaceForURL(b64Encode(objForm.id)) +
			"&schemaName=" + replaceForURL(b64Encode(strSchemaName.toLowerCase())) +
			"&xsltURL=" + replaceForURL(b64Encode("http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/XSLT/xsltFormTranslator.xslt")) +
			"&formURL=" + replaceForURL(b64Encode("http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Forms/" + objForm.strSrc)) +
			"&languageLocation=" + replaceForURL(b64Encode("http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory)) +
			"&sessionString=" + replaceForURL(b64Encode(objApplication.Connection.strConnectionString)) +
			"&localeid=" + replaceForURL(b64Encode(objApplication.User.localeid)) +
			"&editMode=" + strEditMode +
			"&className=" + replaceForURL(b64Encode(strClassName)) +
			"&loadMethod=" + replaceForURL(b64Encode(strLoadMethod));
			
		if (this.strCustomEntityName != null)
			strURL += "&customobject=" + replaceForURL(b64Encode(this.strCustomEntityName));
		
		if (strEditMode == "update")
			strURL += this.getPrimaryKeyURLParameters(lngUniqueId, AppWindow);
		
		// first managed form in the list will contain bean data xml island
		if (i == 5)
			strURL += "&includeBeanData=true";
		
		if (AppWindow.document.body.mobileApp == "true")
			strURL += "&mobileApp=true";

		objForm.formGroup.src = strURL;
	}
}

/**
 * Sets up a new edit child window
 *
 * @param AppWindow The window object.
 */
function ewm_autoSetupChildWindow(AppWindow)
{
	objApplication.Debug.writeTime("AUTO SETUP CHILD WINDOW BEGIN", "file-name=ssEditWindowManager.js");

	var objEditWindow = this.getEditWindow(AppWindow);
	var objForm = objEditWindow.Form;

	if (this.strCustomEntityName != null) 
		objForm.setCustomEntityName(this.strCustomEntityName);

	if (objEditWindow.editMode != "add")
		objEditWindow.currentRecordID = b64Decode(undoReplaceForURL(ParseStringFromURL("uniqueid", AppWindow.document.URL)));

	// are Notes enabled for this schema 
	if (objForm.tabbedDialog != null) {
		objForm.tabbedDialog.EditWindowManager = this;
		
		if (!this.useNotes(objForm.schemaName))
			objForm.tabbedDialog.getTab(objForm.tabbedDialog.strTextTab).hide();
		else if (objForm.tabbedDialog.TextEditor != null)	
			objForm.tabbedDialog.TextEditor.emediaID = String(objForm.schemaName).toLowerCase();
	}

	// Get the data from the main form.
	var objXML = objApplication.createXMLDocument(objEditWindow.Form.objFrameWindow.m_strBeanDataXML);
	if (objEditWindow.editMode == "update")
		objEditWindow.dataprocessXML = objXML.selectSingleNode("/*/dataprocess").xml();
	else
		objEditWindow.dataprocessXML = null;

	if (objXML.selectSingleNode(this.XPath) == null)
	{
		eMsgBox("Data Error.<p></p>Cannot open record.<p></p>Business Entity : " + objEditWindow.Form.schemaName + "<p></p>Key Values : " + this.getPrimaryKeyValueList(objEditWindow.currentRecordID, AppWindow) + "<p></p>Please contact your system administrator", vbOKOnly, msg_Critical, AppWindow);
		AppWindow.close();
		return;
	}

	// Strip off collection wrapper.
	var strXML = objXML.selectSingleNode(this.XPath).xml();
	objXML.loadXML(strXML);
	for (var i = 0, intLen = objEditWindow.arrFormRefs.length; i < intLen; i++)
	{
		var objForm = objEditWindow.arrFormRefs[i];
		if (objForm.schemaName == objEditWindow.Form.schemaName)
			objForm.setXMLDataLocation(objXML, "/*");
	}

	// Remove island from form iframe window.
	objEditWindow.Form.objFrameWindow.m_strBeanDataXML = null;

	// Post process the main form
	objEditWindow.Form.postProcess();
	objApplication.Debug.writeTime("AUTO SETUP CHILD WINDOW - done post process", "file-name=ssEditWindowManager.js");

	if (objApplication.Modules("0020a-docm") && objEditWindow.Form.hasDocs())
		this.showDocumentTab(objEditWindow);

	this.setCaption(AppWindow, objEditWindow);

	if (objEditWindow.Form.tabbedDialog != null && ParseStringFromURL("selTab", AppWindow.document.URL) == "eNotes")
	{
		var objTab = objEditWindow.Form.tabbedDialog.getTab(objEditWindow.Form.tabbedDialog.strTextTab);
		if (objTab != null)
			objTab.select();
	}

	// if Enotes tab has focus load Enote details.
	if (objEditWindow.Form.tabbedDialog != null && objEditWindow.Form.tabbedDialog.TextEditor != null){
		if (objEditWindow.Form.tabbedDialog.getTab(objEditWindow.Form.tabbedDialog.strTextTab).hasFocus())
		{
			this.loadNotes(objEditWindow.Form.tabbedDialog.TextEditor, AppWindow);
			objApplication.Debug.writeTime("AUTO SETUP CHILD WINDOW - loaded eNotes", "file-name=ssEditWindowManager.js");
		}
	}

	if (objEditWindow.Form.tabbedDialog != null && ParseStringFromURL("selTab", AppWindow.document.URL) == "documents")
	{
		var objTab = objEditWindow.Form.tabbedDialog.getTab(objEditWindow.Form.tabbedDialog.strDocumentTab);
		if (objTab != null && objEditWindow.editMode != "add")
			objTab.select();
	}

	// if Documents tab has focus load Document details.
	if (objEditWindow.Form.tabbedDialog != null && objEditWindow.Form.tabbedDialog.strDocumentTab != null){
		// Disable auto documents tab until parent record key details have been saved.
		if (objEditWindow.editMode == "add") {
			objEditWindow.Form.tabbedDialog.getTab(objEditWindow.Form.tabbedDialog.strDocumentTab).disable();
		}
		else if (objEditWindow.Form.tabbedDialog.getTab(objEditWindow.Form.tabbedDialog.strDocumentTab).hasFocus())
		{
			if (objEditWindow.Form.tabbedDialog.documentManager != null)
				objEditWindow.Form.tabbedDialog.documentManager.loadDocuments(AppWindow);
		}
	}

	this.setToolBarButtonStates(AppWindow);

	objApplication.Debug.writeTime("AUTO SETUP CHILD WINDOW DONE", "file-name=ssEditWindowManager.js");
}

/**
 * Returns URL parameters containing primary key information for the edit window.
 *
 * @param lngUniqueId The id of the row clicked in the grid.
 * @param AppWindow The window object.
 * @return The URL parameters string.
 */
function ewm_getPrimaryKeyURLParameters(lngUniqueId, AppWindow)
{
	var strCommand = "";

	var strRunMode = ParseStringFromURL("runmode", AppWindow.document.URL);
    if (strRunMode != null && strRunMode.indexOf("FROMSAPPHIRE") == 0) {
		for (var i = 0; i < primaryKeysFromSapphire.length; i++) {
			strCommand += "&pkvalue" + i + "=" + replaceForURL(b64Encode(primaryKeysFromSapphire[i]));
			strCommand += "&pkdatatype" + i + "=eHNkOnN0cmluZw..";
		}
		return strCommand;
	}    

	for (var intPK = 0, intLen = this.arrPrimaryKeyFields.length; intPK < intLen; intPK++)
	{
		var strValue = null;
		var objPrimaryKeyField = this.arrPrimaryKeyFields[intPK];

		if (objPrimaryKeyField.formID != null) {
			strValue = objApplication.Forms(objPrimaryKeyField.formID).getFieldByRef(objPrimaryKeyField.fieldRef).getValue();
		} else if (objPrimaryKeyField.methodName != null) {
			strValue = eval("this.AppWindow." + objPrimaryKeyField.methodName);
		} else if (objPrimaryKeyField.variableName != null) {
			strValue = this.AppWindow[objPrimaryKeyField.variableName];
		} else if (objPrimaryKeyField.value != null) {
			strValue = objPrimaryKeyField.value;
		} else if (objPrimaryKeyField.gridColumnRef != null) {
			if (this.Grid == null)
				this.Grid = objApplication.Grids(this.gridId);

			// Get cell index;
			var objCells = this.Grid.HTMLtable.tHead.rows[0].cells;
			var intIndex = 0;
			for (var intCell = 0, intCellLen = objCells.length; intCell < intCellLen; intCell++)
			{
				if (objCells[intCell].id.replace("grid_col_", "") == objPrimaryKeyField.gridColumnRef)
				{
					intIndex = intCell;
					break;
				}
			}

			var intRowNumber;
			var objRows = this.Grid.HTMLtable.tBodies[0].rows;
			for (var intRow = 0, intRowLen = objRows.length; intRow < intRowLen; intRow++)
			{
				if (objRows[intRow].cells[0].innerHTML == lngUniqueId)
				{
					intRowNumber = intRow;
					break;
				}
			}

			strValue = this.Grid.HTMLtable.tBodies[0].rows[intRowNumber].cells[intIndex].innerHTML;
			strValue = unescapeXML(strValue);

			var strDataType = this.Grid.objGridHeadingsXML.selectNodes("/grid/column").item(intIndex).getAttribute("datatype");
			if (strDataType == "xsd:float" || strDataType == "xsd:double" || strDataType == "xsd:integer" || 
				strDataType == "xsd:decimal" || strDataType == "xsd:smallint" || strDataType == "xsd:short")
			{
				strValue = util_parseNumber(strValue);
			}
		}

		if (objPrimaryKeyField.dataType == "xsd:dateTime")
		{
			// make sure the date really is in ISO
			if (! isISODate (strValue)) {
				var objEfacsCalendar=objApplication.getCalendarParser();
				objEfacsCalendar.setDateTimeInLocaleFormat(strValue);
				strValue = objEfacsCalendar.getDateTimeInISO();
			}	
		}

		strCommand += "&pkvalue" + intPK + "=" + replaceForURL(b64Encode(strValue));
		strCommand += "&pkdatatype" + intPK + "=" + replaceForURL(b64Encode(objPrimaryKeyField.dataType));
	}

	return strCommand;
}

/**
 * Saves and closes the passed edit window.
 * Checks for application specifically defined methods
 * and if not present auto validates and saves the data.
 *
 * @param AppWindow The window object.
 */
function ewm_saveAndClose(AppWindow)
{
	if (typeof(AppWindow.saveAndClose) != "undefined")
	{
		AppWindow.setEWMSavedAndClosedFlag();
		AppWindow.saveAndClose();
		return;
	}
	var objEditWindow = this.getEditWindow(AppWindow);
	
	if (this.validateForms(AppWindow) == false)
		return;

	if (objApplication.Data.isDirty(objEditWindow.Form.DOM))
	{
		if (this.performSave(AppWindow) == false)
			return;
	}

	AppWindow.setEWMSavedAndClosedFlag();
	AppWindow.close();
}

/**
 * Performs the RPC call for auto saved data.
 *
 * @param AppWindow The window object.
 * @return True if save successful, false if an error was detected.
 */
function ewm_performSave(AppWindow)
{
	if (typeof(AppWindow.performSave) != "undefined")
	{
		return AppWindow.performSave();
	}

	var strSaveXML = this.prepareDataChanges(AppWindow);
	var objEditWindow = this.getEditWindow(AppWindow);

	var objRPCObject = null
	if (this.strCustomEntityName == null) {
		objRPCObject = new RPCObject(objEditWindow.Form.schemaName, AppWindow);
		objRPCObject.execute("Save", objApplication.Connection.strConnectionString, strSaveXML);
	} else {
		objRPCObject = new RPCObject("genericbusinessobject", AppWindow);
		objRPCObject.execute("Save", objApplication.Connection.strConnectionString, strSaveXML, this.strCustomEntityName);
	}
	if (objRPCObject.FAILED)
		return false;

	this.applyDataChanges(AppWindow);

	return true;
}

/**
 * Called before an edit window is unloaded.
 * Checks for application specifically defined methods
 * and if not present auto prompts to save any valid data.
 *
 * @param AppWindow The window object.
 */
function ewm_onBeforeUnload(AppWindow)
{
	if (typeof(AppWindow.window_onbeforeunload) != "undefined")
	{
		AppWindow.window_onbeforeunload();
		return;
	}
	var objEditWindow = this.getEditWindow(AppWindow);
	
	if (objApplication.Data.isDirty(objEditWindow.Form.DOM) && this.validateForms(AppWindow) == true)
	{
		if (eMsgBox(fl("SAVECHANGES"), vbYesNo, msg_Exclamation, AppWindow) == vbYes)
			this.performSave(AppWindow);
	}

	this.removeEditWindow(AppWindow);
}

/**
 * Validates all forms being managed by this edit window manager.
 *
 * @param AppWindow The window object.
 * @return True if all forms are valid, false if not.
 */
function ewm_validateForms(AppWindow)
{
	var objEditWindow = this.getEditWindow(AppWindow);

	for (var i = 0, intLen = objEditWindow.arrFormRefs.length; i < intLen; i++)
	{
		if (objEditWindow.arrFormRefs[i].validate() == false)
			return false;
	}

	return true;
}

/**
 * Returns comma separated list of primary key values - used in error reporting.
 *
 * @param lngUniqueID The id of the row clicked in the grid.
 * @param AppWindow The window object.
 * @return Comma separated string of primary key values.
 */
function ewm_getPrimaryKeyValueList(lngUniqueID, AppWindow)
{
	if (lngUniqueID == null)
		return fl("NEW");

	var strURL = this.getPrimaryKeyURLParameters(lngUniqueID, AppWindow);
	var strValues = "";

	for (var i = 0; ; i++)
	{
		var strB64Val = ParseStringFromURL("pkvalue" + i, strURL)
		if (strB64Val == null)
			break;

		if (i > 0)
			strValues += ", ";

		strValues += b64Decode(undoReplaceForURL(strB64Val));
	}
	
	return strValues;
}

/**
 * Finialises auto setup of child windows.
 *
 * @param AppWindow The window object.
 */
function ewm_autoSetupComplete(AppWindow)
{
	var objEditWindow = this.getEditWindow(AppWindow);
	var objForm = objEditWindow.Form;

	if (objForm.flgFiredOnload == true)
		return;

	var strOnload = objForm.id + "_onLoad";
	if (typeof(AppWindow[strOnload]) != "undefined") {
		AppWindow[strOnload.replace(/(\(\));*/, "")](objEditWindow.Form);
	}

	objForm.flgFiredOnload = true;
}

/** Set the custom entity name and load its schema
 * @param strName Schema name
 */
function ewm_setCustomEntityName(strName) {
	this.strCustomEntityName = strName;
	
	// load the schema into the application
	var objRPCObject = new RPCObject("genericbusinessobject");
	objRPCObject.execute("loadSchema", objApplication.Connection.strConnectionString, this.strCustomEntityName);
	objSchema = objRPCObject.getReturnedXMLDom();
	if (objSchema != null) {
		// Add this schema to the applet so it can be re-used if required without making another soap call.
		objApplication.Schema.objSchemaCache[this.strCustomEntityName] = objSchema;
	}

}

/**
 * Clear references for the edit window manager object
 */
function ewm_destroy() {

	try {
		this.applicationName = null;
		this.gridId = null;
		this.AppWindow = null;
		this.XPath = null;
	
		if (this.arrEditWindows != null) {
			for (var i = 0, len = this.arrEditWindows.length; i < len; i++ ) {
				if (this.arrEditWindows[i] != null) {
					this.arrEditWindows[i].destroy();
					this.arrEditWindows[i] = null;
				}
			}
		} 
		this.arrEditWindows	= new Array();
	
		this.strClassName = null;
		this.strLoadMethod = null;
		this.strSaveMethod = null;
	
		if (this.DataEngine != null) {
			this.DataEngine.destroy();
			this.DataEngine	= null;
		}
		this.Grid = null;
		
		if (this.arrPrimaryKeyFields != null) {
			for (var i = 0, len = this.arrPrimaryKeyFields.length; i < len; i++) {
				if (this.arrPrimaryKeyFields[i] != null) {
					this.arrPrimaryKeyFields[i].destroy();
					this.arrPrimaryKeyFields[i] = null;
				}
			}
		}
		this.arrPrimaryKeyFields = new Array();
	
		if (this.arrBeanParams != null) {
			for (var i = 0, len = this.arrBeanParams.length; i < len; i++) {
				if (this.arrBeanParams[i] != null) {
					this.arrBeanParams[i].destroy();
					this.arrBeanParams[i] = null;
				}
			}
		}
		this.arrBeanParams = new Array();
	
		this.populateFormDataMethod = null;
		this.primaryKeyClassName = null;
		this.primaryKeyClassMethod = null;
		this.documentGrid = null;
		this.strCustomEntityName = null;
		this.id = null;
	} catch (error) {
	}
}



/** 
 * Constructor for EfacsEditor object
 *
 * @param objTextEditor Reference to the wrapper TextEditor object.
 */
function EfacsEditor(objTextEditor)
{
	this.objTextEditor			= objTextEditor;
	this.name					= "TextEditor";
	this.appletElement			= null;

	//methods
	this.createEditorHTML		= ee_createEditorHTML;
	this.setNotesText			= ee_setNotesText;
	this.getText				= ee_getText;
	this.getBase64EncodedText	= ee_getBase64EncodedText;
	this.hideGroup				= ee_hideGroup;
	this.showGroup				= ee_showGroup;
	this.setCombos				= ee_setCombos;
	this.changeEditorMode		= ee_changeEditorMode;
	this.displayDiv				= ee_displayDiv;
	this.getFontList			= ee_getFontList;
	this.getFontSizeList		= ee_getFontSizeList;
	this.bold					= ee_bold;
	this.italic					= ee_italic;
	this.underline				= ee_underline;
	this.cut					= ee_cut;
	this.copy					= ee_copy;
	this.paste					= ee_paste;
	this.alignLeft				= ee_alignLeft;
	this.alignRight				= ee_alignRight;
	this.alignCenter			= ee_alignCenter;
	this.setFontFamily			= ee_setFontFamily;
	this.setFontSize			= ee_setFontSize;
	this.insertDate				= ee_insertDate;
	this.createTable			= ee_createTable;
	this.addHTML				= ee_addHTML;
	this.pickColourRGB			= ee_pickColourRGB;
	this.pickColourHex			= ee_pickColourHex;
	this.processText			= ee_processText;
	this.replaceLeadingSpaces	= ee_replaceLeadingSpaces;
	this.replaceSpaces			= ee_replaceSpaces;
	this.removeEditorFormatting = ee_removeEditorFormatting;
	this.storeText				= ee_storeText;
}

/**
 * Returns applet html for the efacs editor.
 *
 * @return The applet html string.
 */
function ee_createEditorHTML()
{
	return createApplet(this.objTextEditor.id + "_notes", this.name, "100%", "100%", "jar" + this.name, "jarEfacsApplet");
}

/**
 * Sets the text editor content.
 *
 * @param strHTML The HTML editor content.
 */
function ee_setNotesText(strHTML)
{
	this.appletElement.setNotesText(strHTML);
}

/**
 * Returns the current text editor content.
 *
 * @return Text editor content.
 */
function ee_getText()
{
	var retVal;

	if (this.objTextEditor.flgEditorDisplay == true)
		retVal = this.objTextEditor.objWindow.document.getElementById(this.objTextEditor.id + "_notes_div_display").innerHTML;
	else
		retVal = this.appletElement.getText();
	
	return retVal;
}

/**
 * Returns the text contained in the editor as a base-64 encoded string.
 *
 * @return The base64 encoded string.
 */
function ee_getBase64EncodedText()
{
	return this.appletElement.getBase64EncodedText();
}

/**
 * Hides second group of buttons on text editor toolbar.
 *
 * @param objToolbar The toolbar reference.
 */
function ee_hideGroup(objToolbar)
{
	objToolbar.hideGroup("2");
}

/**
 * Shows second group of buttons on text editor toolbar.
 *
 * @param objToolbar The toolbar reference.
 */
function ee_showGroup(objToolbar)
{
	objToolbar.showGroup("2");
	objToolbar.suppressGroupLabels("2");
}

/**
 * Takes references and populates combo boxes.
 */
function ee_setCombos()
{
	var fontcombo = this.objTextEditor.objWindow.document.getElementById(this.objTextEditor.id + "cmbFont");
	var sizecombo = this.objTextEditor.objWindow.document.getElementById(this.objTextEditor.id + "cmbSize");
	var appletParam = this.objTextEditor.objWindow.document.getElementById(this.objTextEditor.id + "_notes");

	var sFont = this.getFontList();
	var sFonts = sFont.split("|");
	for (loop=0; loop < sFonts.length - 1;loop++)
	{			
		fontcombo.options[loop] = new Option(sFonts[loop]);
		if(sFonts[loop] == "Times New Roman")
		{
			fontcombo.options[loop].selected=true;
		}
	}		
	var sSize = this.getFontSizeList();
	var sSizes = sSize.split("|");
	for (loop=0; loop < sSizes.length - 1;loop++)
	{
		sizecombo.options[loop] = new Option(sSizes[loop]);
	}
}

/**
 * Changes editor mode.
 */
function ee_changeEditorMode()
{
}

/**
 * Initialise applet when text editor div is displayed.
 */
function ee_displayDiv()
{
	if (!this.objTextEditor.flgLoaded)
		this.objTextEditor.initialiseApplet();
}

/**
 * Returns font list.	
 *
 * @return The pipe separated list of fonts.
 */
function ee_getFontList()
{
	return this.appletElement.getFontList();		
}

/**
 * Returns font size list.
 *
 * @return The pipe separated list of font sizes.
 */
function ee_getFontSizeList()
{
	return this.appletElement.getFontSizeList();
}

/**
 * Toggles bold property for highlighted text.
 */
function ee_bold()
{
	this.appletElement.bold();
}

/**
 * Toggles italic property for highlighted text.
 */
function ee_italic()
{
	this.appletElement.italic();
}

/**
 * Toggles underline property for highlighted text.
 */
function ee_underline()
{
	this.appletElement.underline();
}

/**
 * Cuts highlighted text.
 */
function ee_cut()
{
	this.appletElement.cut();
}

/**
 * Copies highlighted text.
 */
function ee_copy()
{
	this.appletElement.copy();
}

/**
 * Pastes text from clipboard at current cursor location.
 */
function ee_paste()
{
	this.appletElement.paste();
}

/**
 * Aligns highlighted text to the left.
 */
function ee_alignLeft()
{
	this.appletElement.alignLeft();
}

/**
 * Aligns highlighted text to the right.
 */
function ee_alignRight()
{
	this.appletElement.alignRight();
}

/**
 * Centers the highlighted text.
 */
function ee_alignCenter()
{
	this.appletElement.alignCenter();
}

/**
 * Sets font name for highlighted text.
 *
 * @param strFontName The font name.
 */
function ee_setFontFamily(strFontName)
{
	this.appletElement.setFontFamily(strFontName);
}

/**
 * Sets font size for highlighted text.
 *
 * @param intFontSize The font size.
 */
function ee_setFontSize(intFontSize)
{
	this.appletElement.setFontSize(intFontSize);
}

/**
 * Inserts date at current cursor location.
 *
 * @param strDate The date string
 */
function ee_insertDate()
{
	this.appletElement.insertDate("<br>" + objApplication.getDateParser().getCurrentLocaleDateTime() + "</br>");
}

/**
 * Inserts a HTML table at current cursor location.
 *
 * @param strTableHTML The table html string.
 */
function ee_createTable(strTableHTML)
{
	this.appletElement.createTable(strTableHTML);
}

/**
 * Adds HTML at current cursor location.
 *
 * @param strHTML The html string.
 */
function ee_addHTML(strHTML)
{
	this.appletElement.addHTML(strHTML);
}

/**
 * Sets foreground colour for highlighted text.
 *
 * @param r The red value.
 * @param g The blue value.
 * @param b The green value.
 */
function ee_pickColourRGB(r, g, b)
{
	this.appletElement.pickcolour(r, g, b);
}

/**
 * Sets foreground colour for highlighted text.
 *
 * @param hexValue The r,g,b hex value.
 */
function ee_pickColourHex(hexValue)
{
}

/**
 * Performs any editor specific text manipulation.
 * Called before saving and setting notes text into the editor.
 *
 * @param strHTML The preprocessed HTML.
 * @return The processed HTML.
 */
function ee_processText(strHTML)
{
	return this.replaceLeadingSpaces(strHTML);
}

/**
 * Replaces spaces with &nbsp; so that leading spaces are not lost.
 * @param sHTML The html string which might have leading spaces
 * @return The html string with any leading spaces replaced.
 */
function ee_replaceLeadingSpaces(sHTML)
{
	var intFirstPTag = sHTML.indexOf("<p>");
	var intLastPTag = sHTML.lastIndexOf("</p>");
	
	// initial population with no spaces
	if (intFirstPTag + 3 == intLastPTag || intFirstPTag == -1 || intLastPTag == -1)
		return sHTML
	
	var strSubString = sHTML.substring(intFirstPTag + 4, intLastPTag); // + 4 = <p>\n 

	var strStart = sHTML.substring(0, intFirstPTag + 4);
	var strContent = this.removeEditorFormatting(strSubString);	
	var strEnd = sHTML.substring(intLastPTag);

	strContent = this.replaceSpaces(strContent);

	return strStart + strContent + strEnd;
}

/**
 * Replace spaces with &nbsp unless the space is inside a tag
 * @return The string with the appropriate spaces converted.
 */
function ee_replaceSpaces(strContent)
{
	var flgInTag = false;
	var strNewString = "";
	
	for (var n = 0; n < strContent.length; n++)
	{
		if (strContent.charAt(n) == "<") {
			flgInTag = true;
			strNewString += strContent.charAt(n);
		}
		else if (strContent.charAt(n) == ">") {
			flgInTag = false;
			strNewString += strContent.charAt(n);
		}
		else if (strContent.charAt(n) == " ") {

			if (!flgInTag) {
				strNewString += "&nbsp;";
			}
			else {
				strNewString += " ";
			}
		}
		else {
			strNewString += strContent.charAt(n);
		}
	}
	return strNewString;
}

/**
 * Remove any extra formatting inserted by the editor
 * @param sHTML The html from which formatting is to be removed
 * @return The html with the formatting removed.
 */
function ee_removeEditorFormatting(sHTML)
{
	// The first six characters may be spaces introduced by the editor.
	var n = 0;
	
	if (sHTML.charAt(n) == "\r")
		sHTML = sHTML.substring(1);
	
	while (sHTML.charAt(n) == " " && n < 7) 
	{
		n++;
	}

	var strContent;
	if (n < 6)		
		strContent = sHTML;
	else
		strContent = sHTML.substring(6);
	
	// Now search for CR/LF combinations.  If there are six spaces after this then remove the six spaces.
	var regEx = /\r\n      /g;
	strContent = strContent.replace(regEx, "\r\n");

	regEx = /\r      /g;
	strContent = strContent.replace(regEx, "\r");

	regEx = /\n      /g;
	strContent = strContent.replace(regEx, "\n");
	
	return strContent;
}

/**
 * Call the text editor storeText method which updates/adds the editor text to the 
 * XMLDetail XML island.
 *
 * @param objElement - The element from which the texteditor reference is obtained.
 */
function ee_storeText(objElement) {
	var objThisTextEditor = eval(objElement.srcElement.id.replace("_notes", ""));
	objThisTextEditor.storeText();
}

	
	
//Constructor
function EfacsError(objError, objWindow) {

//properties
	this.error						= objError;
	this.errorMessage				= "";
	this.errorSource				= "";
	this.errorDetail				= "";
	this.serverErrorNumber			= 0;
	this.clientErrorNumber			= 0;
	this.systemMessage				= null;
	this.isCritical					= false;
	this.isCommitFailure			= false;
	this.isDataEngineError			= false
	this.appServerNotRunning		= false;
	this.commitFailureXML			= null;
	this.dataEngineErrorXML			= null;
	this.errorMsgType				= msg_Exclamation;
	this.efacsErrorFromString		= err_efacsErrorFromString;
	this.efacsErrorFromJScriptError = err_efacsErrorFromJScriptError;
	this.setCritical				= err_setCritical;
	this.getPredefinedErrorMsg		= err_getPredefinedErrorMsg;
	this.showError					= err_showError;
	this.setJavaScriptMessage		= err_setJavaScriptMessage;
	
	if (objWindow != null)
		this.objWindow				= objWindow;
	else
		this.objWindow				= window;
	
	if (typeof(objError) == "string") {
		this.efacsErrorFromString(objError);
	}else{
		this.efacsErrorFromJScriptError();
	}
}

/* 
 * Setup EfacsError from error string. 
 * @param strError - String containing error information. Will be in XML format if error received through DataException or DataEngine.
 */
function err_efacsErrorFromString(strError)
{
	var objErrorXML = objApplication.createXMLDocument();
	
	//Obtain error xml and load into xmldom, if load fails, the message string is not xml therefore set it directly to errorMessage.
	var strErrorXML = strError.substring(strError.indexOf("<error"), strError.lastIndexOf("</error>") + 8);
	if (objErrorXML.loadXML(unescapeXML(strErrorXML))) 
	{
		this.errorMessage = objErrorXML.selectSingleNode("message").getText();
		this.serverErrorNumber = Number(objErrorXML.selectSingleNode("/error").getAttribute("errorNo"));
		this.errorSource = objErrorXML.selectSingleNode("source").getText();
		this.errorDetail = objErrorXML.selectSingleNode("detail").getText();
		//Determine whether error is a commit failure.
		if (objErrorXML.selectSingleNode("detail/commitfailure")) {
			this.isCommitFailure = true;
			this.commitFailureXML = objErrorXML.selectSingleNode("detail/commitfailure");
		}
		//Determine whether error is a data engine error.
		if (objErrorXML.selectSingleNode("requestinfo")) {
			this.isDataEngineError = true;
			this.dataEngineErrorXML = objErrorXML.selectSingleNode("requestinfo");
		}
	} else
		this.errorMessage = strError;
	
	//If the error that has occured can be identified, then set the systemMessage to a user friendly predefined format or message.
	//Commit failures, Data Engine errors and specifically handled errors will display via a predefined format. 
	this.systemMessage = this.getPredefinedErrorMsg();
}

/*
 * Extract client-side error number as error has been wrapped in a JavaScript Error object. 
 * Set up error from JavaScript error object message attribute(String).
 */
function err_efacsErrorFromJScriptError()
{
	this.clientErrorNumber = this.error.number;
	if (this.clientErrorNumber == ERROR_JAVASCRIPTERROR){
		//Set as Javascript Error message format.
		this.setJavaScriptMessage();
	}else
		this.efacsErrorFromString(this.error.message);
}

/*
 * Set the error as a critical error to display critical icon in error message dialog.
 */
function err_setCritical()
{
	this.isCritical = true;
	this.errorMsgType = msg_Critical;
}

/*
 * Check if we have a predefined display format or specific message for the error that has occured.
 * Method will set error to critical for those errors that need to display a critical icon and close the culpable application.
 * @return A string with either a predefined message or built up HTML for displaying a variable message.
 */
function err_getPredefinedErrorMsg()
{
	var strError;
	
	//Application server is not available.
	if (this.clientErrorNumber == -2147352567)
	{
		this.setCritical();
		this.appServerNotRunning = true;
		return;
	}
	
	//Any type of out of memory error.
	if (this.errorMessage.indexOf("java.lang.OutOfMemoryError") != -1 || this.errorDetail.indexOf("java.lang.OutOfMemoryError") != -1)
	{
		this.setCritical();
		return fl("OUTOFMEMORYERROR");
	}
	
	//Commit Failure: Build up a HTML message with a table of fields and values which have caused the commit failure conflict.
	if (this.isCommitFailure) 
	{
		strError = fl("FAILEDPERFORMACTION") + "<br/><br/>";
		this.errorMsgType = msg_Exclamation;

		var objNodes = this.commitFailureXML.selectNodes("conflicts/conflict");
		if (objNodes.length() > 0)
		{
			strError = 	fl("CONFLICTWARNING");
			strError += "<div><table><tr><td>&nbsp;</td></tr></table></div>";
			strError += "<div class='GridDiv'  style='margin-right:50px'><table cellspacing='0' cellpadding='0' width='500px' class='GridContainer'><thead><tr>";

			strError += "<tr><td><b>" + fl("FIELDNAME") + "</b></td><td><b>" + fl("ORIGINALVALUE") + "</b></td><td><b>" + fl("CURRENTVALUE") + "</b></td>";

			strError += "</tr></thead><tbody>";
			for (var objNode = objNodes.nextNode(); objNode != null; objNode = objNodes.nextNode())
			{
				strError += "<tr><td>" + objNode.selectSingleNode("propertyname").getText() + "</td>";
				strError += "<td>" + objNode.selectSingleNode("dboriginalvalue").getText() + "</td>";
				strError += "<td>" + objNode.selectSingleNode("dbvalue").getText() + "</td>";
			}
				
			strError += "</tbody></table></div>";
				
		}
	
		objNodes = this.commitFailureXML.selectNodes("validationerrors/validationerror");
		if (objNodes.length() > 0)
		{
			strError = "<div class='GridDiv'><table cellspacing='0' cellpadding='0' width='600px' class='GridContainer'><thead><tr>";
			strError += "<td><b>" + fl("ERRORNUMBER") + "</b></td><td><b>" + fl("BUSINESSNAME") + "</b></td><td><b>" + fl("PROPERTYNAME") + "</b></td><td><b>" + fl("REASON")+ "</b></td>";
			strError += "</tr></thead><tbody>";
			for (var objNode = objNodes.nextNode(); objNode != null; objNode = objNodes.nextNode())
			{
				strError += "<tr><td>" + objNode.getAttribute("errno") + "</td>";
				strError += "<td>" + objNode.selectSingleNode("businessname").getText() + "</td>";
				strError += "<td>" + objNode.selectSingleNode("propertyname").getText() + "</td>";
				strError += "<td>" + objNode.selectSingleNode("reason").getText() + "</td></tr>";
			}
			strError += "</tbody></table></div>";	
		}
		
		return strError;
	}
	
	//Data Engine Error: Build up a HTML message with details of data engine error if available.
	if (this.isDataEngineError)
	{
		strError = fl("DATAENGINEERROR") + "<p />";
		
		if (this.dataEngineErrorXML != null)
		{
			//Data engine error occured due to a method call.
			if (this.dataEngineErrorXML.selectSingleNode("class"))
			{
				var strClassName = this.dataEngineErrorXML.selectSingleNode("class").getText();
				var strMethodName = this.dataEngineErrorXML.selectSingleNode("method").getText();
				var objParamNodes = this.dataEngineErrorXML.selectNodes("parameters/input/column");
				
				strError = "<table class='DialogMessage' style='margin-right:1.5cm'>";
				strError += "<tr>" + fl("DATAENGINEERROR") + "</tr><tr/>";
				strError += "<tr>" + fl("DATAENGINECLASSERROR") + "</tr>";
				
				if (!isBlank(this.errorMessage) && this.errorMessage.length < 256){//Don't display stack traces which can sometimes appear in the message element.
					strError += "<tr><td valign='top'><b>" + fl("ERROR") + "</b></td><td valign='top'><b>:</b></td><td>";
					strError += this.errorMessage + "</td></tr>";
				}
				
				strError += "<tr><td valign='top'><b>" + fl("CLASS") + "</b></td><td valign='top'><b>:</b></td><td>";
				strError += strClassName;
				strError += "</td></tr><tr><td valign='top'><b>" + fl("METHOD") + "</b></td><td valign='top'><b>:</b></td><td>";
				strError += strMethodName;
				strError += "</td></tr>";

				if (objParamNodes.length() > 4)
					strError += "<tr><td colspan='3'><div style='height:100px; width:380px; overflow:auto; margin-right:1.4cm; border:medium window-inset'><table>";
				
				var paramCtr = 1;
				for (var objNode = objParamNodes.nextNode(); objNode != null; objNode = objParamNodes.nextNode())
				{
					
					strError += "<tr><td valign='top' nowrap='true'><b>" + fl("PARAMETER") + " " + paramCtr +  "</b></td><td valign='top'><b>:</b></td><td>";
					strError += (objNode.getText() + " [" + objNode.getAttribute("type") + "]");
					strError += "</td></tr>";
					paramCtr++;
				}
				
				if (objParamNodes.length() > 4)
					strError += "</table></div></td></tr>";
				
				
				strError += "</table>";
			}
			else if (this.dataEngineErrorXML.selectSingleNode("sql")) //Data engine error occured due to SQL issues.
			{
				strError += this.errorMessage;
				var strSQL = this.dataEngineErrorXML.selectSingleNode("sql").getText();
				var strWhereClause = this.dataEngineErrorXML.selectSingleNode("whereclause").getText();
				var strGroupBy = this.dataEngineErrorXML.selectSingleNode("groupby").getText();
				var strOrderBy = this.dataEngineErrorXML.selectSingleNode("orderby").getText();
				
				//Add show/hide SQL button and SQL pane if data-engine SQL error returned the erroring SQL.
				if (!isBlank(strSQL)){
					if (!isBlank(strWhereClause))
						strSQL += ("\n" + strWhereClause);
					if (!isBlank(strGroupBy))
						strSQL += ("\n" + strGroupBy);
					if (!isBlank(strOrderBy))
						strSQL += ("\n" + strOrderBy);
					
					strError += "<table class='DialogMessage'>";
					strError += "<tr><td valign='top'><button class='button' id='btnToggleSQL' style='height:20px' onclick='toggleErrorSQL()'><b>" + fl("SHOWSQL") + "</b></button></td></tr>";
					strError += "<tr><td valign='top' id='TDerrorSQL' style='display:none'><div style='height:200px; width:700px; overflow:auto; margin-right:1.5cm; border:medium window-inset'>" + strSQL + "</div></td></tr></table>";
				}
			}
		}
		
		return strError;
	}

	//Specifically handle period not defined error 10001;
	if (this.serverErrorNumber == 10001)
		return fl("PERIODNOTDEFINED") + "<p />" + fl(this.errorMessage);
	
	//Specifically handle batch frozen error 15001;
	if (this.serverErrorNumber == 15001)
		return fl("BATCHFROZEN") + "<p />" + fl(this.errorMessage);
	
	//Specifically handle session creation error 21051;	
	if (this.serverErrorNumber == 21051)
		return fl("IOCREATESESSION") + "<p />" + fl(this.errorMessage);
	
	//Specifically handle session string format invalid error 21052;
	if (this.serverErrorNumber == 21052)
		return fl("INVALIDSESSIONFORMAT") + "<p />" + fl(this.errorMessage);
	
	//Specifically handle invalid date range entered error 27000;
	if (this.serverErrorNumber == 27000)
		return fl("INVALIDCALENDARDATERANGE") + "<p />" + fl(this.errorMessage);
	
	//Specifically handle overlap or gap not allowed error 27001;
	if (this.serverErrorNumber == 27001)
		return fl("OVERLAPORGAPNOTALLOWED") + "<p />" + fl(this.errorMessage);
	
	// Specifically handle error -2601 - cannot insert duplicate record.
	if (this.serverErrorNumber == -2601 && this.errorSource == "SQLERROR")
	{
		return fl("CANNOTINSERTDUPLICATERECORD");
	}
	
	// Specifically handle error -547 - constraint violation
	if (this.serverErrorNumber == -547 && this.errorSource == "SQLERROR") {
		return fl("CANNOTDELETERECORDINUSE");
	}
	
	/*
	 * Constraint violation for MSSQL and Informix is now handled by the above -547 test but leave
	 * the below string check for these vendors in for now...
	 */
	//Specifically handle Database FOREIGN KEY conflict errors.
	if (this.errorMessage.indexOf("DELETE statement conflicted with COLUMN REFERENCE constraint") != -1 ||
			 this.errorMessage.indexOf("DELETE statement conflicted with TABLE REFERENCE constraint") != -1 ||
			 this.errorMessage.indexOf("DELETE statement conflicted with the REFERENCE constraint") != -1 ||
			 this.errorMessage.indexOf("DB2 SQL error: SQLCODE: -532") != -1)
	{
		return fl("CANNOTDELETERECORDINUSE");
	}
	
	// Specifically handle errors 20051 and 20054 - Licence failure - licence service not running.
	if (this.serverErrorNumber == 20051 || this.serverErrorNumber == 20054)
	{
		strError = fl("CANNOTCOMMUNICATEWITHLICENCE");
		if (!isBlank(this.errorDetail))
		{
			if (this.errorDetail.indexOf("Session expired") != -1)
				strError += "<p />" + fl("LICENCESESSIONEXPIRED");
			else if (this.errorDetail.indexOf("Connection reset by peer") != -1)
				strError += "<p />" + fl("LICENCECONNECTIONRESETBYPEER");
			else if (this.errorDetail.indexOf("Connection refused") != -1)
				strError += "<p />" + fl("LICENCECONNECTIONREFUSED");
		}
		this.setCritical();
		return strError;
	}
	
	//Specifically handle Database INSERT permission denied error.
	if (this.errorMessage.indexOf("INSERT permission denied on object") != -1)
	{
		return fl("INSERTPERMISSIONDENIED");
	}
	
	//Specifically handle Database UPDATE permission denied error.
	if (this.errorMessage.indexOf("UPDATE permission denied on object") != -1)
	{
		return fl("UPDATEPERMISSIONDENIED");
	}
	
	//Specifically handle Database DELETE permission denied error.
	if (this.errorMessage.indexOf("DELETE permission denied on object") != -1)
	{
		return fl("DELETEPERMISSIONDENIED");
	}
	
	//Return null to indicate the error that has occured is not a predefined error or error format.
	return null;
}

/*
 * Displays the error with eMsgBox. Determines the style of message depending on whether a predefined message
 * was obtained or error was due to application server issues. 
 * Closes the erroring application if a critical error has occured.
 */
function err_showError()
{		
	if (this.appServerNotRunning){
		//Cannot display as eMsgBox as application server is required to resolve path to message html file (msgGeneric.html);
		alert(fl("APPSERVERNOTRUNNING"));
	}else if (isBlank(this.systemMessage))
	{
		//Build up error HTML for non-predefined error message. Only display stack trace button if stack trace returned with error.
		var strError = "<table class='DialogMessage'>";
		strError += "<tr><td valign='top'><b>" + fl("DESCRIPTION") + "</b></td><td valign='top'><b>:</b></td><td>";
		strError += fl(this.errorMessage);
		strError += "</td></tr><tr><td valign='top'><b>" + fl("NUMBER") + "</b></td><td valign='top'><b>:</b></td><td>";
		//Output server error number if one has been returned. Otherwise output client error number, usually ERROR_RPCINVOKEERROR(80001)
		strError += (this.serverErrorNumber == 0)? this.clientErrorNumber:this.serverErrorNumber;
		strError += "</td></tr>";
		if (!isBlank(this.errorSource))
			strError += "<tr><td valign='top'><b>" + fl("SOURCE") + "</b></td><td valign='top'><b>:</b></td><td>" + fl(this.errorSource) + "</td></tr>";
		if (!isBlank(this.errorDetail)){
			strError += "<tr><td colspan='3' valign='top'><button class='button' id='btnToggleStackTrace' style='height:20px' onclick='toggleErrorStackTrace()'><b>" + fl("SHOWSTACKTRACE") + "</b></button></td></tr>";
			strError += "<tr><td colspan='3' valign='top' id='TDerrorStackTrace' style='display:none'><div style='height:400px; width:700px; overflow:auto; margin-right:1.5cm; border:medium window-inset'>" + this.errorDetail + "</div></td></tr>";
		}
		strError += "</table>";
		
		eMsgBox(strError, 0, this.errorMsgType, this.objWindow);
	}else
		eMsgBox(this.systemMessage, 0, this.errorMsgType, this.objWindow);

	if (this.isCritical)
	{
		//Set application to a critical error state and close application window [Except if menu].
		objApplication.hadCriticalError = true;
		if (objApplication.fileName != "appMenu.xml")
			objApplication.closeApplication();
	}
}

/*
 * Set up error message from JavaScript error source in order to display a standard efacs format error.
 * Set error message type to critical, but don't set error state to critical, in order to keep application open.
 */
function err_setJavaScriptMessage()
{
	var objErrorXML = objApplication.createXMLDocument();
	var strError = "<table class='DialogMessage'>";
	if (objErrorXML.loadXML(unescapeXML(this.error.message)))
	{
		strError += "<tr><td valign='top' width='40%'><b>" + fl("JSCRIPTERROR") + "</b></td><td valign='top'><b>:</b></td><td>";
		strError += fl(objErrorXML.selectSingleNode("message").getText());
		strError += "</td></tr><tr><td valign='top' width='40%'><b>" + fl("LINENUMBER") + "</b></td><td valign='top'><b>:</b></td><td>";
		strError += objErrorXML.selectSingleNode("linenumber").getText();
		strError += "</td></tr>";
		strError += "<tr><td valign='top' width='40%'><b>" + fl("APPLICATION") + "</b></td><td valign='top'><b>:</b></td><td>";
		strError += fl(objErrorXML.selectSingleNode("apptitle").getText()) + "</td></tr></table>";
		this.systemMessage = strError;
	}else{
		strError += "<tr><td valign='top'><b>" + fl("UNEXPECTEDJSCRIPTERROR") + "</b></td></tr><tr><td>";
		strError += fl(unescapeXML(this.error.message)) + "</td></tr></table>";
	}
	
	this.errorMsgType = msg_Critical;
	this.systemMessage = strError;
}


  

var MAX_ITEMS_IN_HISTORY = 5;

function FieldHistory() {

	var objFHXML;
	var m_objOriginalXML = objApplication.createXMLDocument();
	
	// Set up class members once only...
 	if (typeof(_FH_prototype_called) == 'undefined') {
		_FH_prototype_called = true;
		 FieldHistory.prototype.getClassValue = getClassValue;
		 FieldHistory.prototype.addClassValue = addClassValue;
		 FieldHistory.prototype.getXML = getXML;
		 FieldHistory.prototype.loadXML = loadXML;
		 FieldHistory.prototype.load = load;
		 FieldHistory.prototype.save = save;
		 FieldHistory.prototype.isDirty = isDirty;
	}
	
	// FieldHistory document does not exist so create a new
	// skeleton document...
	objFHXML = objApplication.createXMLDocument();
	objFHXML.loadXML("<field-history><field-classes /><tables /></field-history>");

	function getColumnValue(strTableName, strColumnName) {
		
	}

	function addColumnValue(strTableName, strColumnName, strValue) {
		var objValuesNode;
		var objColumnNode;
		
		// Check to see if there is a "table" entry...
		var objTableNode = objFHXML.selectSingleNode("/field-history/tables/table[@id = '" + strTableName + "']");
		if (objTableNode == null) {
			// Create it...
			objTableNode = objFHXML.createElement("table");
			objFHXML.selectSingleNode("/field-history/tables").appendChild(objTableNode);
			
			objTableNode.setAttribute("id", strTableName);
			objColumnNode = addColumnElement(objTableNode, strColumnName);
			objValuesNode = addValuesElement(objColumnNode);
		}
		else {
			// Check to see if he have a "column" entry...
			objColumnNode = objTableNode.selectSingleNode("column[@id = '" + strColumnName + "']");
			if (objColumnNode == null) {
				objColumnNode = addColumnElement(objTableNode, strColumnName);
				objValuesNode = addValuesElement(objColumnNode);
			}
			else {
				objValuesNode = objColumnNode.firstChild();
				if (objValuesNode == null) {
					objValuesNode = addValuesElement(objColumnNode);
				}
			}
		}
		
		// Now ready to add column value...
		addValueElement(objValuesNode, strValue);
	}

	function getXML()
	{
		return objFHXML.xml();
	}

	function loadXML(strXML)
	{
		objFHXML.loadXML(strXML);
		m_objOriginalXML.loadXML(strXML);
	}

	/**
	*  Determines whether field history has changed since the last time it was loaded.
	*  This can be used to determine whether a save needs to be performed.
	*  @return boolean
	*/
	function isDirty()
	{
		if (objFHXML != null)
		{
			if (String(objFHXML.xml()) != String(m_objOriginalXML.xml()))
				return true;
		}
		
		return false;
	}

	function getClassValue(strClassName, intItemNumber) {
		var objValuesNode = objFHXML.selectSingleNode("/field-history/field-classes/class[@id = '" + strClassName + "']/values");
		if (objValuesNode != null) {
			if (objValuesNode.hasChildNodes() == false)
				return null;
			
			var objValueNode = objValuesNode.childNodes().item(intItemNumber);
			return objValueNode == null ? null : objValueNode.getText();
		}	
		return null;
	}


	function addClassValue(strClassName, strValue) {
		var objValuesNode;
	
		var objClassNode = objFHXML.selectSingleNode("/field-history/field-classes/class[@id = '" + strClassName + "']");	
		if (objClassNode == null) {
			// Create it...
			objClassNode = objFHXML.createElement("class");
			objFHXML.selectSingleNode("/field-history/field-classes").appendChild(objClassNode);
			
			objClassNode.setAttribute("id", strClassName);
			
			objValuesNode = addValuesElement(objClassNode);
		}
		else
			objValuesNode = objClassNode.firstChild();
		
		addValueElement(objValuesNode, strValue);
	}

	
	
	// PRIVATE function to create <column id='partnum'> element.
	function addColumnElement(objNode, strColumnName) {
		var objColumnNode = objFH.createElement("column");
		objNode.appendChild(objColumnNode);
		objColumnNode.setAttribute("id", strColumnName);
		return objColumnNode;
	}
	
	// PRIVATE method to create "<values>"
	function addValuesElement(objNode) {
		var objValuesNode = objFHXML.createElement("values");
		objNode.appendChild(objValuesNode);
		return objValuesNode;
	}

	
	// PRIVATE method to create <value>AR3<value>
	// This function operates like a stack, it will add elements to the top of the node set
	// until the max is reached, at which time it will start to delete of oldest items.
	// It will prevent the addition of duplicate values.
	function addValueElement(objNode, strValue) 
	{
		var escapedString = EscapeStringBackslash(strValue);
		escapedString = EscapeStringDoublequote(escapedString);

		var objExistingNode = objNode.selectSingleNode("value[text() = \"" + escapedString + "\"]");
		
		
		// Do not add if already exists...
		if (objExistingNode != null)
		{
			objNode.insertBefore(objExistingNode.cloneNode(), objNode.childNodes().item(0))
			objNode.removeChild(objExistingNode);
			return;
		}

		if (objNode.childNodes().length() == MAX_ITEMS_IN_HISTORY) {
			// Delete the oldest item from the list...
			var objDelete = objNode.childNodes().item(MAX_ITEMS_IN_HISTORY - 1);
			objNode.removeChild(objDelete);
		}

		var objValueNode = objFHXML.createElement("value");
		objValueNode.setText(strValue);
		
		if (objNode.hasChildNodes() == false)		// Add as first child.
			objNode.appendChild(objValueNode);
		else
		{
			// Place at the top of the list;
			objNode.appendChild(objValueNode);

			var objNewNode = objNode.cloneNode();

			var i = 1;
			var objChildNodes = objNode.childNodes();
			for (var intCtr = 0; intCtr <= objChildNodes.length() - 2; intCtr ++)
			{
				objNewNode.childNodes().item(i).setText(objChildNodes.item(intCtr).getText());
				i++;
			}

			objNewNode.childNodes().item(0).setText(strValue);

			objNode.parentNode().replaceChild(objNewNode, objNode);
		}
	}
	
	function load() 
	{
		var objRPC = new RPCObject("WindowAttribute");

		objRPC.execute("loadPersistedSettings", objApplication.Connection.strConnectionString, 
			"fieldhistory", objApplication.User.userID, objApplication.User.language);

		if (objRPC.isEmpty())
			return;

		var objRetVal = objRPC.getReturnedXMLDom();

		if (objRetVal != null)
			loadXML(objRetVal.selectSingleNode("/windowattributes/windowattribute/xmlcode/value/*").xml());
		
		objRPC = null;
	}

	function save()
	{
		var objRPC = new RPCObject("WindowAttribute");

		objRPC.execute("savePersistedSettings", objApplication.Connection.strConnectionString, 
			"fieldhistory",
			objApplication.User.userID, 
			objApplication.User.language, 
			getXML());
			
		objRPC = null;
	}
}



function FileCache(strUserID, strCompanyID) {
	this.userid		= strUserID;
	this.companyid	= strCompanyID;
	this.XMLObject  = null;
	this.XMLDom		= "";
	
	this.load		= FileCache_load;
	this.save		= FileCache_save;
}

function FileCache_load()
{
	this.XMLObject = objApplication.createXMLDocument();
	this.XMLObject.loadURL("../XML/Cache/" + this.userid + "_Menu_" + this.companyid + ".xml", window.document.URL);

	this.XMLDom = this.XMLObject.xml;
}

function FileCache_save()
{
	var objXMLHTTP;
	var strSource;
	var strRequest;
	
	if (this.userid == null ||
	    this.companyid == null)
			return;

	strSource = "../JSP/fileCache.jsp";
	strRequest = "UserID=" + this.userid + "&CompanyID=" + this.companyid + "&Data=" + this.XMLObject.xml;

	if (navigator.appName == "Microsoft Internet Explorer")
	{
		objXMLHTTP = new ActiveXObject("Microsoft.XMLHTTP");
	}
	else if (navigator.appName == "Netscape")
	{
		objXMLHTTP = new XMLHttpRequest();
	}	
	else
	{
		window.alert("Browser not supported.");
		return;
	}

	objXMLHTTP.open("POST", strSource, false);
	objXMLHTTP.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
	objXMLHTTP.send(strRequest);

	// If the objXMLHTTP request fails
	if (objXMLHTTP.status == "500")
	{
		window.alert("Request or reply failed.");
		return;
	}

}	

	

// ADAPT constants.
var ADAPT_ONBEFORECHANGE = 0x1;
var ADAPT_ONAFTERCHANGE = 0x2;
var ADAPT_ONAFTERKEYPRESS = 0x4;
var ADAPT_VALIDATE = 0x8;

// MCB - Hack for applet text editor - bug with field onblur not being fired when
// applet editor receives focus.
var m_objChangeElement = null;

var m_strCOMBOBOX;
var m_strTEXTBOX;
var m_strCHECKBOX;
var m_strTEXTAREA;
var m_strDATETIMEBOX;

/** 
 * Constructor for the Form object
 *
 * @param objElement The HTML formgroup element containing this form.
 * @param p_objWindow The window object.
 */
function Form(objElement, p_objWindow)
{
//properties
	this.id 			= objElement.id.replace("frm", "");  // Setup a quick reference to this grid objects ID.
	this.strSrc			= null;
	this.strVersion		= null;
	this.strRevision	= null;
	this.strModified	= null;
	this.tabbedDialog = null;
	
	this.DOM			= null;				// Contains reference to  application's data
	this.objXMLNode		= null;
	this.XPath			= "";
	this.formGroup		= objElement;		// HTML container that contains form fields
	
	this.fields			= new Array();
	this.isVisible		= true;
	this.editMode		= ParseStringFromURL("mode", p_objWindow.document.URL);
	this.isInitialised	= false;
	this.flgHasMapModule = null;
	this.flgHasCTIModule = null;
	
	// Constants used for utility routine "Form_setFieldsFromXML".
	this.FDefault		= 1;
	this.FCurrent		= 2;
	this.FOriginal		= 3;
	this.schemaName		= null;	
	this.objWindow		= p_objWindow;
	this.userOnChange	= null;
	this.flgFiredOnload = false;
	this.flgFiringExternalEvent		= false;
	this.intSchemaPrimaryKeyCount	= null;
	this.flgPreparedDataChanges		= false;
	this.flgCreatedFields			= false;
	this.objGridEdit				= null;
	this.strCustomEntityName        = null;
	this.flgHasDocuments			= null;
	
//methods	
	this.refresh		= Form_refresh;		// Re-synchronise form with  application's data.
	this.reset			= Form_reset;		// Clear form fields and reset to default values.

	this.loadFromFile	= Form_loadFromFile;

	this.validate		= Form_validate;		// Perform simple data-type  validation on all fields in form
	this.disable		= Form_disable;		// Disable (make read-only) all form  fields
	this.enable			= Form_enable;		// Enable all form fields.
	this.hideAllFields	= Form_hideAllFields;
	this.getFieldByRef	= Form_getFieldByRef;
	this.getFieldByElement	= Form_getFieldByElement;	
	this.processLookups	= Form_processLookups;
	this.hide			= Form_hide;
	this.show			= Form_show;
	this.getHTMLFieldByRef	= Form_getHTMLFieldByRef;

	this.isInvalid			= Form_isInvalid;
	this.setEditMode		= Form_setEditMode;
	this.setXMLDataLocation = Form_setXMLDataLocation;
	this.applyDefaultFormValues = Form_applyDefaultFormValues;
	this.onchange		= Form_onchange;
	this.isInteractivelyDirty	= Form_isInteractivelyDirty;
	this.permanentlyDisable		= Form_permanentlyDisable;
	this.postProcess			= Form_postProcess;
	this.setInitialFocus		= Form_setInitialFocus;
	this.setCustomEntityName    = Form_setCustomEntityName;
	this.hasDocs				= Form_hasDocs;
	this.destroy 				= Form_destroy;
	this.hasMapModule			= Form_hasMapModule;
	this.hasCTIModule			= Form_hasCTIModule;
	
// PRIVATE methods (these should only be called internally, not from applications)
	this.setFieldsFromXML	= Form_setFieldsFromXML;
	this.createFields		= Form_createFields;
	this.addField			= Form_addField;
	this.toXML				= Form_toXML;
	this.setRevisionInfo    = Form_setRevisionInfo;
	this.setPrimaryKeyStates	= Form_setPrimaryKeyStates;
}

/** 
 * Used by ADAPT - returns a tree formatted xml representation of this object.
 *
 * @return The tree formatted xml representation of this object.
 */
function Form_toXML()
{
	var strUID = this.strSrc.replace("../Forms/", "").replace(".xml", "");
	
	var strXML = "<node uid='" + this.id + "' level='3' open='false' tooltip='" + this.id + "' fire-onclick='true'>";
	strXML += "<vals>";
	strXML += "<val id='label'>" + this.id + "</val>";
	strXML += "<val id='name'>" + strUID + "</val>";
	strXML += "<val id='event1' parameter-name='objForm'>onLoad</val>";
	strXML += "<val id='event2' parameter-name='objForm'>onRefresh</val>";
	strXML += "</vals>";
	
	if (this.fields.length > 0)
	{
		var strFields = "";
		this.fields[0].getHTMLElement();
	
		// FORM FIELDS
		for (var n = 0, intLen = this.fields.length; n < intLen; n++)
		{
			var strFieldXML = this.fields[n].toXML();
			if (strFieldXML != null)
				strFields += strFieldXML;
		}

		if (!isBlank(strFields))
			strXML += "<nodes>" + strFields + "</nodes>";
	}

	// End form node.
	strXML += "</node>";

	return strXML;
}

function Form_setEditMode(p_editMode)
{
	this.editMode = p_editMode;
	this.setPrimaryKeyStates();
}

function Form_addField(p_strRef, p_strDataType, p_strAliasedColumn)
{
	var objField = new FormField(this, p_strRef, p_strDataType, p_strAliasedColumn)
	this.fields[this.fields.length] = objField;
	return objField;
}

/**
 * Returns a reference to the HTML element for the passed field ref.
 *
 * @param strRef The form field ref.
 * @return The HTML element.
 */
function Form_getHTMLFieldByRef(strRef)
{
	var objElement = this.objFrameWindow.document.getElementById(this.id + "_" + strRef);

	if (objElement == null)
		objElement = this.objFrameWindow.document.getElementById(strRef);

	return objElement;
}

function Form_getFieldByRef(p_strRef)
{
	for (var n = 0, intLen = this.fields.length; n < intLen; n++)
	{
		if (String(this.fields[n].strRef) == String(p_strRef))
		{
			return this.fields[n];
		}
	}
	return null;
}

function Form_getFieldByElement(objElement)
{
	// Causes the form to initialise itself if not already done so.
	// Coded this way for performance.
	if (this.fields[0].HTMLElement == null)
		this.fields[0].getHTMLElement();

	for (var n = 0, intLen = this.fields.length; n < intLen; n++)
	{
		if (this.fields[n].getHTMLElement() == objElement)
		{
			return this.fields[n];
		}
	}
	return null;
}

// The following two methods allow the actual form to be hidden / made visible.
function Form_hide()
{
	this.formGroup.style.display = "none";
	this.isVisible = false;
}

function Form_show()
{
	this.formGroup.style.display = "inline";
	this.isVisible = true;
}

function Form_setXMLDataLocation(objNode, strXPath)
{
	this.DOM = objNode;
	this.XPath = strXPath;
	this.objXMLNode = this.DOM.selectSingleNode(strXPath);
}

/**
 * Loads a form into it's IFrame.
 *
 * @param The form URL to be loaded.
 */
function Form_loadFromFile(strPath) 
{
	this.strSrc = strPath;
	this.fields = new Array();

	var strSchemaName = this.schemaName;
	if (isBlank(strSchemaName))
		strSchemaName = "none";

	var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/servlet/FormProcessorServlet" +
		"?formID=" + replaceForURL(b64Encode(this.id)) +
		"&schemaName=" + replaceForURL(b64Encode(strSchemaName.toLowerCase())) +
		"&xsltURL=" + replaceForURL(b64Encode("http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/XSLT/xsltFormTranslator.xslt")) +
		"&formURL=" + replaceForURL(b64Encode("http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Forms/" + this.strSrc)) +
		"&languageLocation=" + replaceForURL(b64Encode("http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory)) +
		"&sessionString=" + replaceForURL(b64Encode(objApplication.Connection.strConnectionString)) +
		"&localeid=" + replaceForURL(b64Encode(objApplication.User.localeid));

	if (this.objWindow.document.body.mobileApp == "true")
		strURL += "&mobileApp=true";

	this.formGroup.src = strURL;
}

/**
 * Sets the cursor focus on the first editable field on this form.
 * If no fields are editable then return false to indicate the
 * focus was not set.
 *
 * @return True if an editable field was found to set focus on - false if not.
 */
function Form_setInitialFocus() {

	// Make sure the form has been post processed.
	if (this.fields.length > 0 && this.fields[0].HTMLElement == null)
		this.postProcess();
	
	for (var n = 0, intLen = this.fields.length; n < intLen; n++)
	{
		var objField = this.fields[n];

		if (objField.HTMLElement.blnIsDisabled == "false" && objField.isVisible() == true)
		{
			objField.focus();
			return true;
		}
	}
	
	return false;
}

// Iterate through all fields on the form and build up array of form controls.
function Form_createFields() 
{
	if (this.objWindow["formCreateFields_" + this.id])
		this.objWindow["formCreateFields_" + this.id](this);
}

// Set up any special field attributes that are required...
function Form_postProcess()
{
	objApplication.Debug.writeTime("POST PROCESS BEGIN - " + this.id, "file-name=ssForm.js");
	eval("this.objWindow.frames(\"" + this.id + "_iframe\").formPostProcess_" + this.id + "(this)");

	if (m_strCOMBOBOX == null)
	{
		m_strCOMBOBOX = fl("COMBOBOX");
		m_strTEXTBOX = fl("TEXTBOX");
		m_strCHECKBOX = fl("CHECKBOX");
		m_strTEXTAREA = fl("TEXTAREA");
		m_strDATETIMEBOX = fl("DATETIMEBOX");
	}
	
	objApplication.Debug.writeTime("POST PROC - called formPostProcess_" + this.id + "()", "file-name=ssForm.js");

	for (var n = 0, intLen = this.fields.length; n < intLen; n++)
	{
		if (this.editMode == "filter")
			this.fields[n].HTMLElement.removeAttribute("maxLength");
	}

	objApplication.Debug.writeTime("POST PROCESS DONE - " + this.id, "file-name=ssForm.js");
}

function Form_refresh()
{
	objApplication.Debug.writeTime("FORM REFRESH BEGIN - " + this.id, "file-name=ssForm.js");

	if (this.fields.length > 0 && this.fields[0].HTMLElement == null)
		this.fields[0].getHTMLElement();

	objApplication.Debug.writeTime("FORM REFRESH - got HTMLElement", "file-name=ssForm.js");

	this.setFieldsFromXML(this.FCurrent);
	
	objApplication.Debug.writeTime("FORM REFRESH - set fields from xml", "file-name=ssForm.js");

	// Need to check for critical error - setFieldsFromXML may have failed with system parameter requests.
	if (objApplication.hadCriticalError == true)
		return;

	this.setPrimaryKeyStates();	

	if (this.flgFiredOnload == false)
	{
		// Form_onLoad - Fire ADAPT script if present - fires on first form refresh.
		// not ideal but will do for now - MCB.
		this.flgFiredOnload = true;
		var strOnload = this.id + "_onLoad";
		if (typeof(this.objWindow[strOnload]) != "undefined") {
			this.objWindow[strOnload](this);
		}
	}
	else
	{
		// onRefresh - Fire ADAPT script if present.
		var strRefresh = this.id + "_onRefresh";
		if (typeof(this.objWindow[strRefresh]) != "undefined") {
			this.objWindow[strRefresh](this);
		}
	}

	objApplication.Debug.writeTime("FORM REFRESH DONE - " + this.id, "file-name=ssForm.js");
}

function Form_reset()
{
	this.setFieldsFromXML(this.FDefault);

	// Form_onRefresh - Fire ADAPT script if present.
	var strRefresh = this.id + "_onRefresh";
	if (typeof(this.objWindow[strRefresh]) != "undefined") {
		this.objWindow[strRefresh](this);
	}
}

function Form_clear()
{
	this.reset();
}

function Form_validate()
{
	if (this.editMode != "update" || this.isInteractivelyDirty() == true)
	{
		for (var n = 0, intLen = this.fields.length; n < intLen; n++)
		{
			var objFormField = this.fields[n];
			
			// Causes the form to initialise itself if not already done so.
			// Coded this way for performance.
			if (objFormField.HTMLElement == null)
			{
				objFormField.getHTMLElement();
				// Also need to perform a refresh to map data from XML island to the html.
				this.refresh();
			}

			if (objFormField.HTMLElement.parentElement.style.display == "none")
				continue;

			if (objFormField.validate() == false)
				return false;

			// If a previous processLookups() call, has made the field invalid
			// then validate should return false.
			if (objFormField.lastLookupSuccessful == false && objFormField.processLookups() == false) 
				return false;
		}
	}

	// This field is valid, so the status bar may be cleared of any message
	this.objWindow.objStatusBar.clear();

	return true;
}

function Form_disable()
{
	for (var n = 0, intLen = this.fields.length; n < intLen; n++)
		this.fields[n].disable();
}
/**
 * Enable individual fields on the form.
 */
function Form_enable() {
	for (var n = 0, intLen = this.fields.length; n < intLen; n++)
	{
		var objField = this.fields[n];
		if (objField.HTMLElement.isAlwaysDisabled != "true" && objField.HTMLElement.isprimary != "true" || (objField.HTMLElement.isprimary == "true" && objField.objForm.editMode == "add")) {
			objField.enable();
		}
	}
}

/**
 * Hide all field on the form
 */
function Form_hideAllFields()
{
	for (var n = 0, intLen = this.fields.length; n < intLen; n++)
		this.fields[n].hide();

	var objHTMLElement;
	var objHTMLElements = this.objFrameWindow.document.getElementsByTagName("label");

	for (var intCtr = 0, intLen = objHTMLElements.length; intCtr < intLen; intCtr++)
	{
		objHTMLElement = objHTMLElements.item(intCtr);
		if (objHTMLElement.className == "group-legend-caption")
			objHTMLElement.style.display = "none";
	}
}

function Form_processLookups()
{
	for (var n = 0, intLen = this.fields.length; n < intLen; n++)
		this.fields[n].processLookups(this);
}

function Form_isInvalid()
{
	var intInvalidFields = 0;
	for (var n = 0, intLen = this.fields.length; n < intLen; n++)
	{
		if (this.fields[n].isInvalid == true)
		{
			intInvalidFields ++;
		}
	}
	return intInvalidFields > 0 ? true : false;			
}

function Form_onchange(objElement, objEvent, objForm)
{
	var strValue;
	
	if (objForm == null)
		objForm = Form_getFormObject(objElement);

	// MCB HACK - this can be removed when microsoft fix the automation error
	// caused when focus goes to an applet and an onchange event is pending.
	if (typeof(objForm.getFieldByElement) == "unknown")
	{
		m_objChangeElement = objElement;
		return;
	}

	// Get the FormField object for this reference...
	objFormField = objForm.getFieldByElement(objElement);
	if (objFormField == null)
		return;

	if (objFormField.selectOne != null && objFormField.selectOne.HTMLElement != null)
	{
		if (objFormField.selectOne.HTMLElement.hasFocus == true)
			return;
	}

    if (objFormField.HTMLElement.isTimeFormat == "true")
    {
        var timeValue = objFormField.getHTMLElement().value;

        if (timeValue.length == 4)
        {
            var strHours = timeValue.substring(0, 2);
            var strMinutes = timeValue.substring(2);
            var intHours = Number(strHours);
            var intMinutes = Number(strMinutes);

            if (! isNaN(intHours) && ! isNaN(intMinutes) && intHours >= 0 && intHours <= 23 && intMinutes >= 0 && intMinutes <= 59)
            {
                timeValue = strHours + ":" + strMinutes;

                objFormField.getHTMLElement().value = timeValue;
            }
        }
    }

	if (objFormField.getHTMLElement().tagName.toLowerCase() == "textarea")
		strValue = objFormField.getHTMLElement().value;
	else if (objFormField.getHTMLElement().type == "checkbox")
	{
		if (objFormField.getHTMLElement().checked == true)
			strValue = "true";
		else
			strValue = "false";
	}
	else
		strValue = objFormField.getHTMLElement().value;

	// Removed code to replace 2 blank spaces with a single space for primary key field.

	if (objForm.objWindow.m_objFunctionalTest != null && 
		objForm.objWindow.m_objFunctionalTest.isFunctionalTestRecording() &&
		objFormField.HTMLElement.type != "checkbox" && objFormField.HTMLElement.type != "radio")
	{
		objForm.objWindow.m_objFunctionalTest.recordEvent(objEvent, objForm.objFrameWindow.document.body.compId);
	}
	
	objFormField.isInteractivelyDirty = true;
	objFormField.setValueWithEvents(strValue, FORMFIELD_FROMONCHANGEEVENT);

	if (objForm.userOnChange != null) {
		eval(objForm.userOnChange);
	}

	if (objFormField.onBlur != null) {
		objFormField.objForm.objWindow[objFormField.onBlur](objFormField);
	}
}

function Form_onfocus(objElement, objEvent)
{
	try {

		// MCB HACK - this can be removed when microsoft fix the automation error
		// caused when focus goes to an applet and an onchange event is pending.
		if (m_objChangeElement != null)
		{
			Form_onchange(m_objChangeElement);
			m_objChangeElement = null;
		}
		if (objElement == null)
			return;

		var objForm = Form_getFormObject(objElement);
		
		objFormField = objForm.getFieldByElement(objElement);
		if (objFormField == null)
			return;

		Form_doFocus(true);

		if (objFormField.overwriteValidate)
			return;
			
		if (objFormField.getHTMLElement().tagName == "TEXTAREA")
			return;

		if (objFormField.strDataType == "xsd:float" ||
			objFormField.strDataType == "xsd:double" ||
			objFormField.strDataType == "xsd:integer" ||
			objFormField.strDataType == "xsd:short" ||
			objFormField.strDataType == "xsd:smallint" ||
			objFormField.strDataType == "xsd:decimal")
		{

			var strCurrentXMLValue = objFormField.getCurrentXMLValue();
			
			if (strCurrentXMLValue.indexOf(".") != -1)//The decimal symbol is always held as '.'  in the xml. The display decimal place however can be different.
			{		
				var prevDPAccuracy = strCurrentXMLValue.substring(strCurrentXMLValue.indexOf(".")).length -1;
				strCurrentXMLValue = objApplication.getNumberFormatter().getLocaleNumber(strCurrentXMLValue, prevDPAccuracy);
			}
			else
				strCurrentXMLValue = objApplication.getNumberFormatter().getLocaleNumber(strCurrentXMLValue, objFormField.HTMLElement.proPoint);
			
			if (objFormField.getCurrentXMLValue() != null && !isBlank(strCurrentXMLValue))
				objFormField.getHTMLElement().value = strCurrentXMLValue;
			else if (objFormField.HTMLElement.unformattedHTMLValue != null)
			{
				if (!isNaN(objFormField.HTMLElement.unformattedHTMLValue * objFormField.HTMLElement.unformattedHTMLValue))
				{
					if (!isBlank(objFormField.HTMLElement.unformattedHTMLValue))
						objFormField.getHTMLElement().value = Number(objFormField.HTMLElement.unformattedHTMLValue);
				}
			}
		}

		objFormField.getHTMLElement().select();

		/* LJP - Only display the help comments if there is NOT an error message in the status-bar */

		var bUpdateStatusBar = true;
		
		for (var i = 0; i<objApplication.arrForms.length; i++)
		{
			if (objApplication.arrForms[i].objWindow == objForm.objWindow)
			{
				if (objApplication.arrForms[i].isInvalid())
				{
					bUpdateStatusBar = false;
					break;
				}
			}
		}

		if (bUpdateStatusBar)
		{
			if (objFormField.HTMLElement.comments == null)
				objStatusBar.clear();
			else
				objStatusBar.message(objFormField.HTMLElement.comments);
		}
		
		if (objFormField.onFocus != null) {
			objFormField.objForm.objWindow[objFormField.onFocus](this);
		}

	} catch (error) {
	}
}

function Form_onblur(objElement, objEvent)
{
	try {
		var objForm = Form_getFormObject(objElement);

		var strRef = objForm.strRef;

		// Does this field have any lookups that need performing...
		objFormField = objForm.getFieldByElement(objElement);

		if (objFormField == null || objFormField.isInvalid == true)
			return;

		Form_doFocus(false);

		if (objFormField.strDataType == "xsd:float" ||
			objFormField.strDataType == "xsd:double" ||
			objFormField.strDataType == "xsd:integer" ||
			objFormField.strDataType == "xsd:short" ||
			objFormField.strDataType == "xsd:smallint" ||
			objFormField.strDataType == "xsd:decimal")
		{
			// Perform any format for this field...
			objFormField.processFormat();
		}

		/* LJP - Only clear the help comments if there is NOT an error message in the status-bar */

		if (objFormField.HTMLElement.comments != null && objForm.isInvalid() == false)
			objStatusBar.clear();

	} catch (error) {
		return;
	}
}

/**
 * Process on-key-down event
 * @param objElement Form element object
 * @param objEvent Event object
 */
function Form_onkeydown(objElement, objEvent) 
{
	var objForm = Form_getFormObject(objElement);
	var objFormField = objForm.getFieldByElement(objElement);

	if (objFormField == null) return;

	if (objFormField.HTMLElement.blnIsDisabled == "true")
		return;

	// Function key F9 recalls previous field class values.
 	if (objEvent.keyCode == 120)
	{
		objFormField.recall();

		// Prevent this keypress from being entered into the textbox.
		objEvent.cancelBubble = true;
		objEvent.returnValue = false;
		return;
	}

	// CTRL space fires combo or datetime picker.
	if (objEvent.keyCode == 32 && objEvent.ctrlKey == true)
	{
		var objElem = objFormField.HTMLElement.nextSibling;
		if (objElem.tagName == "BUTTON" && objElem.className == "ComboBoxButton" && objElem.style.display != "none")
		{
			objElem.hasFocus = true
			objElem.click();
		}

		if (objElem.tagName == "BUTTON" && objElem.className == "DatePickerButton" && objElem.style.display != "none")
			objFormField.fireDatePicker(objEvent);

		// Prevent this keypress from being entered into the textbox.
		objEvent.cancelBubble = true;
		objEvent.returnValue = false;
		return;
	}
}

/**
 * Internal function fired when a keyup is made in a formfield.
 * This supports the ADAPT onAfterKeypress event.
 *
 * @param objElement The HTML element for the formfield where a keypress was made.
 * @param objEvent The window event object.
 */
function Form_onkeyup(objElement, objEvent)
{
	var objForm = Form_getFormObject(objElement);
	var objFormField = objForm.getFieldByElement(objElement);

	if (objForm.flgFiringExternalEvent == false)
	{
		if (objFormField.objForm.strSrc.indexOf("dynamic_") == -1)
		{
			objForm.flgFiringExternalEvent = true;
			objFormField.performADAPTScript(null, ADAPT_ONAFTERKEYPRESS);
			objForm.flgFiringExternalEvent = false;
		}
	}
}

function Form_onkeypress(objElement, objEvent) {

	var objForm = Form_getFormObject(objElement);
	var objField = objForm.getFieldByElement(objElement);

	if (objField == null) return;
	
	// max length less than zero means no maximum set.
	if (objField.getMaxLength() < 0)
		return;

	var intSelectedTextLength = 0;

	if (document.selection)
		intSelectedTextLength = document.selection.createRange().text.length;

	if ((objField.getHTMLElement().value.length - intSelectedTextLength) >= objField.getMaxLength())
	{
		if (objElement.tagName.toLowerCase() == "textarea")
			objEvent.returnValue = false;

		objApplication.EfacsApplet.beep();
	}

	// Cancel event for ENTER keypresses as these cause a BEEP in an INPUT tag.
	// Do not cancel the event bubble however as this is needed by the queries.	
	if (objEvent.keyCode == 13 && objElement.tagName.toLowerCase() != "textarea")
		objEvent.returnValue = false;
}

function Form_setFieldsFromXML(mode)
{
	var objNodes, objNode;
	var strBusinessProperty;
	var objXMLNode;
	var strFullXPath = this.XPath;

	if (this.DOM == null)
	{
		for (var i = 0, intLen = this.fields.length; i < intLen; i++)
		{
			var objField = this.fields[i];
			objField.setValue(objField.getDefaultXMLValue(), FORMFIELD_WITHOUTLOOKUPS | FORMFIELD_WITHOUTVALIDATION | FORMFIELD_WITHOUTRECALLSAVE | FORMFIELD_WITHOUTADAPT);

			// Need to check for critical error - set value may have failed with system parameter requests.
			if (objApplication.hadCriticalError == true)
				return;
		}
		return;
	}

	// Set the form to point to the data in the XML island...
	this.objXMLNode = this.DOM.selectSingleNode(strFullXPath);

	// copy data from passed XML into data-entry form.
	// This function loops around all controls in the current document, and refreshes
	// the fields which have a business property with the data within the XML island.
	for (var n = 0, intLen = this.fields.length; n < intLen; n++)
	{
		var objField = this.fields[n];

		// Causes the form to initialise itself if not already done so.
		// Coded this way for performance.
		if (objField.HTMLElement == null)
			objField.getHTMLElement();

		if (mode == this.FCurrent)
		{
			var strVal = objField.getCurrentXMLValue();
			if (strVal != null)
			{
				if (objField.getHTMLElement().type == "checkbox")
				{
					if(strVal.toLowerCase() == "true")
					{
						objField.getHTMLElement().checked = true;
					}
					else
					{
						objField.getHTMLElement().checked = false;
					}

				}
				objField.setValue(strVal, FORMFIELD_WITHOUTVALIDATION | FORMFIELD_WITHOUTRECALLSAVE | FORMFIELD_WITHOUTADAPT | FORMFIELD_FROMREFRESH);
			}
		}
		else
			objField.setValue(objField.getDefaultXMLValue(), FORMFIELD_WITHOUTVALIDATION | FORMFIELD_WITHOUTRECALLSAVE | FORMFIELD_WITHOUTADAPT | FORMFIELD_FROMREFRESH);

		// Need to check for critical error - set value may have failed with system parameter requests.
		if (objApplication.hadCriticalError == true)
			return;
	}
}

function Form_applyDefaultFormValues()
{
	var objField;
	
	if (this.fields.length > 0)
	{
		objField = this.fields[0];
		if (objField.HTMLElement == null)
			objField.getHTMLElement();
	}
	
	for (var n = 0, intLen = this.fields.length; n < intLen; n++)
	{
		objField = this.fields[n];	
		if (!isBlank(objField.HTMLElement.defaultFormValue))
		{
			switch (objField.HTMLElement.defaultFormValue) {
				case "YESTERDAY":
					var objCalendar = objApplication.getCalendarParser();
					objCalendar.addDays (-1);
					objField.setValueWithEvents(objCalendar.getDateTimeInISO(), FORMFIELD_WITHOUTRECALLSAVE);
					break;
				
				case "TOMORROW":
					var objCalendar = objApplication.getCalendarParser();
					objCalendar.addDays (+1);
					objField.setValueWithEvents(objCalendar.getDateTimeInISO(), FORMFIELD_WITHOUTRECALLSAVE);
					break;
				
				case "TODAY":
				case "NOW":
					var objCalendar = objApplication.getCalendarParser();
					objField.setValueWithEvents(objCalendar.getDateTimeInISO(), FORMFIELD_WITHOUTRECALLSAVE);
					break;
					
				case "USERID":
					objField.setValueWithEvents(objApplication.User.userID, FORMFIELD_WITHOUTRECALLSAVE);
					break;
					
				case "USERNAME":
					objField.setValueWithEvents(objApplication.User.userName, FORMFIELD_WITHOUTRECALLSAVE);
					break;
					
				case "COMPANYID":
					objField.setValueWithEvents(objApplication.User.company, FORMFIELD_WITHOUTRECALLSAVE);
					break;
					
				case "COMPANYNAME":
					objField.setValueWithEvents(objApplication.User.companyName, FORMFIELD_WITHOUTRECALLSAVE);
					break;
					
				case "HOMECURRENCY":
					objField.setValueWithEvents(objApplication.User.homeCurrency, FORMFIELD_WITHOUTRECALLSAVE);
					break;

				default:
					objField.setValueWithEvents(objField.HTMLElement.defaultFormValue, FORMFIELD_WITHOUTRECALLSAVE);
					break;
			}
		}
		
		if (objField.isRequiredField() == true &&
			objField.selectOne && objField.selectOne.listValueOnly == true && 
			objField.selectOne.getComboItemValue(objField.getValue()) == null)
		{
			if (objField.selectOne.Values.length > 0)
				objField.setValueWithEvents(objField.selectOne.Values[0], FORMFIELD_WITHOUTVALIDATION | FORMFIELD_WITHOUTRECALLSAVE | FORMFIELD_WITHOUTADAPT);
			else
				objField.setValueWithEvents("", FORMFIELD_WITHOUTVALIDATION | FORMFIELD_WITHOUTRECALLSAVE | FORMFIELD_WITHOUTADAPT);
		}

	}
}

/*--------------------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------------------- PRIVATE UTILITY FUNCTIONS  ---------------------------------------------------*/

// Returns a reference to the current "Form" object. Passed the event element from the HTML table.
function Form_getFormObject(objElement)
{
	var objParent;

	objParent = getParentElement(objElement, "FORM");
	if (objParent == null) 
		objParent = getParentElement(objElement, "TR", "editableGridForm");

	var strID = objParent.id.replace("frm", "");
	return window[strID];
}

function Form_doFocus(flgMode)
{
	if (flgMode == true) { // Show focus
		switch (objFormField.getHTMLElement().className) {
			case "EfacsField" :
				objFormField.getHTMLElement().className = "EfacsFieldHasFocus";
				break;
				
			case "EfacsFieldRequired" :
				objFormField.getHTMLElement().className = "EfacsFieldRequiredHasFocus";
				break;
				
			case "TextBox" :
				objFormField.getHTMLElement().className = "TextBoxHasFocus";
				break;
				
			case "InvalidTextBox" :
				objFormField.getHTMLElement().className = "InvalidTextBoxHasFocus";
				break;
			
			default :
				break;
		}
	}
	else { // Remove focus
		switch (objFormField.getHTMLElement().className) {
			case "EfacsFieldHasFocus" :
				objFormField.getHTMLElement().className = "EfacsField";
				break;
				
			case "EfacsFieldRequiredHasFocus" :
				if (objFormField.getHTMLElement().value == "")
					objFormField.getHTMLElement().className = "EfacsFieldRequired";
				else
					objFormField.getHTMLElement().className = "EfacsField";
				break;
				
			case "TextBoxHasFocus" :
				objFormField.getHTMLElement().className = "TextBox";
				break;
				
			case "InvalidTextBoxHasFocus" :
				objFormField.getHTMLElement().className = "InvalidTextBox";
				break;
				
			default :
				break;
		}
	}
}
/**
 * Internal function to see if any of the fields on the form have been changed by the user.
 *
 */
function Form_isInteractivelyDirty()
{
	for (var n = 0, intLen = this.fields.length; n < intLen; n++)
	{
		if (this.fields[n].isInteractivelyDirty == true)
			return true;
	}

	return false;
}

/**
 * Set the revision information
 * @param strVersion The form version
 * @param strRevision The form revision
 * @param strModified When the form was last modified
 */
function Form_setRevisionInfo(strVersion, strRevision, strModified)
{
	this.strVersion = strVersion;
	this.strRevision = strRevision;
	this.strModified = strModified;
}

/**
 * Set primary key states such as infopanel visiblity, enabled/disabled.
 */
function Form_setPrimaryKeyStates()
{
	// Make sure the form has been post processed.
	if (this.fields.length > 0 && this.fields[0].HTMLElement == null)
		this.postProcess();

	for (var i = 0, intLen = this.fields.length; i < intLen; i++)
	{
		var objField = this.fields[i];

		if (objField.HTMLElement.isprimary == "true")
		{
			if (this.editMode != "add" && objField.HTMLElement.schemaField == "true")
			{
				//Disable all primary keys.
				objField.disable();
			}
			else if (objField.HTMLElement.isAlwaysDisabled != "true")
			{
				if (objField.HTMLElement.blnIsDisabled == "true")
					objField.enable();

				if (objField.HTMLElement.schemaField == "true" && objField.HTMLElement.hasForeignKey != "true")
				{
					//Disable queries for primary keys
					objField.disableQuery();
					if (objField.selectOne != null && objField.DataEngine != null)
						objField.disableComboBox();
				}
			}
		}
	}
}

/**
 * Permanently disables and sets as not required all fields on a form.
 */
function Form_permanentlyDisable()
{
	for (var i = 0, intLen = this.fields.length; i < intLen; i++)
	{
		var objField = this.fields[i];
		objField.disable();
		objField.HTMLElement.isAlwaysDisabled = "true";
		objField.setRequiredField(false);
	}
}

/** 
 * Loops up to see if form is on a tabbed dialog
 * If it is then passes the keydown event to TabbedDialog.doOnKeyDown method.
 *
 * @param objBody The iframe body content.
 */
function Form_checkTDonkeydown(objBody)
{
	var objWindow = objBody.ownerDocument.parentWindow.parent;
	var objIFrame = objWindow.document.getElementById("frm" + objBody.compId.replace("_iframe", ""));
	
	for (var objElement = objIFrame.parentNode; objElement != null; objElement = objElement.parentNode)
	{
		if (objElement.className == "tabbeddialog")
		{
			var objTabbedDialog = window[objElement.id.replace("tabd", "")];
			objTabbedDialog.doOnKeyDown(objBody.ownerDocument.parentWindow.event);
			break;
		}
	}
}
/** Sets the custom entity name - if one is used
 * @param strEntityName Entity name
 */
 
function Form_setCustomEntityName(strEntityName) {
	this.strCustomEntityName = strEntityName;
}

/**
 * Determines whether a for supports document management.
 *
 * @return True if form supports document management, false if not.
 */
function Form_hasDocs()
{
	if (this.flgHasDocuments == null)
	{
		var objXML = objApplication.createXMLDocument();
		objXML.loadURL(this.strSrc);
		
		if (objXML.selectSingleNode("//form").getAttribute("has-docs") == "true")
			this.flgHasDocuments = true;
		else
			this.flgHasDocuments = false;
	}
	
	return this.flgHasDocuments;
}

/**
 * Clear references to the form object
 */
function Form_destroy() {

	try {
		this.tabbedDialog   = null;
		
		this.DOM			= null;
		this.objXMLNode		= null;
		this.userOnChange	= null;
		this.objGridEdit				= null;
		this.onchange				= null;
		this.flgHasCTIModule = null;
		this.flgHasMapModule = null;
	
		for (var n = 0, intLen = this.fields.length; n < intLen; n++) {
			this.fields[n].destroy();
			this.fields[n] = null;
		}
		this.fields = new Array();
		
		if (this.objFrameWindow != null && this.objFrameWindow.document != null && this.objFrameWindow.document.body != null) {
			this.objFrameWindow.document.body.onclick = null;
			this.objFrameWindow.document.body.onfocus = null;
			this.objFrameWindow.document.body.onblur = null;
			this.objFrameWindow.document.body.onchange = null;
			this.objFrameWindow.document.body.onmousedown = null;
			this.objFrameWindow.document.body.onmouseup = null;
			this.objFrameWindow.document.body.onmouseover = null;
			this.objFrameWindow.document.body.onkeypress = null;
			this.objFrameWindow.document.body.onkeydown = null;
			this.objFrameWindow.document.body.onkeyup = null;
			this.objFrameWindow.document.body.ondblclick = null;
			this.objFrameWindow.document.body.onload = null;
			this.objFrameWindow = null;
		}

		if (this.formGroup != null) {
			this.formGroup.src = null;
			this.formGroup.onclick = null;
			this.formGroup.onfocus = null;
			this.formGroup.onblur = null;
			this.formGroup.onmousedown = null;
			this.formGroup.onmouseup = null;
			this.formGroup.onmouseover = null;
			this.formGroup.onkeypress = null;
			this.formGroup.onkeydown = null;
			this.formGroup.onkeyup = null;
			if (this.formGroup.style != null) {
				this.formGroup.style.display = "";
			}
			this.formGroup		= null;
		}

		if (this.objWindow != null && this.objWindow.document != null && this.objWindow.document.body != null) {
			this.objWindow.document.body.onclick = null;
			this.objWindow.document.body.onfocus = null;
			this.objWindow.document.body.onblur = null;
			this.objWindow.document.body.onchange = null;
			this.objWindow.document.body.onmousedown = null;
			this.objWindow.document.body.onmouseup = null;
			this.objWindow.document.body.onmouseover = null;
			this.objWindow.document.body.onkeypress = null;
			this.objWindow.document.body.onkeydown = null;
			this.objWindow.document.body.onkeyup = null;
			this.objWindow		= null;
		}

		this.id 			= null;		
	} catch(error) {
	}
}

/**
 * Check if either of the map modules are present.
 * (Store this against the form for performance.)
 */
function Form_hasMapModule() {
	if (this.flgHasMapModule != null) {
		return this.flgHasMapModule;
	}

	this.flgHasMapModule = false;	
	if (objApplication.Modules("0036a-mapsm") || objApplication.Modules("0035a-mapmulti")) {
		this.flgHasMapModule = true;
	}
	
	return this.flgHasMapModule;
}

/**
 * Check if the CTI module is present.
 * (Store this against the form for performance.)
 */
function Form_hasCTIModule() {
	if (this.flgHasCTIModule != null) {
		return this.flgHasCTIModule;
	}
	
	this.flgHasCTIModule = false;
	if (objApplication.Modules("0071a-cti")) {
		this.flgHasCTIModule = true;
	}
	
	return this.flgHasCTIModule;
}


	

// General public constants.
var FORMFIELD_WITHEVENTS = 0x1;
var FORMFIELD_WITHOUTVALIDATION = 0x2;
var FORMFIELD_WITHOUTLOOKUPS = 0x4;
var FORMFIELD_WITHOUTFORMAT = 0x8;
var FORMFIELD_WITHOUTRECALLSAVE = 0x10;
var FORMFIELD_WITHOUTADAPT = 0x20;
var FORMFIELD_FROMONCHANGEEVENT = 0x40;
var FORMFIELD_FROMREFRESH = 0x80;

/** 
 * Constructor for the FormField object
 *
 * @param p_objForm A reference to the form on which this field exists.
 * @param p_strRef The form field reference.
 * @param p_strDataType The form field data type.
 * @param p_strAliasedColumn The form field aliased column name - used in Query_buildWhereClause.
 */
function FormField(p_objForm, p_strRef, p_strDataType, p_strAliasedColumn) {

// Properties
	this.objForm = p_objForm;
	this.HTMLElement = null;
	this.strDataType = p_strDataType;
	this.strAliasedColumn = p_strAliasedColumn;
	this.isInvalid = false;
	this.strRef = p_strRef;
	this.lookup = null;
	this.blnIsInfoPanelEnabled = false;
	this.blnIsMapEnabled = false;
	this.blnIsCTIEnabled = false;
	this.queryInputs = new Array();
	this.queryResults = new Array();
	this.UOMLookups = new Array();
	this.infoPanelInputs = new Array();
	this.mapInputs = new Array();
	this.ctiInputs = new Array();
	this.lookupInputs = new Array();
	this.strQueryResultsXML = null;
	this.formOnChange = "";
	this.onFocus = null;
	this.onBlur = null;
	this.externalValidate = null;
	this.overwriteValidate = null;
	this.overwriteProcessFormat = null;
	this.intRecallItem = 0;
	this.previousValue = null;
	this.permanentDateDisable = null;
	this.permanentMapDisable = null;
	this.permanentAddressDisable = null;
	this.permanentCTIDisable = null;
	this.permanentInfoDisable = null;
	this.lastLookupSuccessful = false;
	this.flgFiringExternalEvent = false;
	this.arrCurrencyDependentFields = new Array();
	this.isInteractivelyDirty = false;
	this.arrFieldActions = new Array();
	this.arrLookupDependents = new Array();
	this.flgHasMapModule = null;
	this.flgHasCTIModule = null;
			
	// Combo box.
	this.selectOne			= null;
	this.DataEngine			= null;
	this.isDynamicCombo     = false;
	this.dynamicComboMethod = null;
	this.strComboFilter		= null; // Holds a method name that gives details of extra SQL to be added to the where clause of the combo
		
// Methods	
	this.processLookups			= FormField_processLookups;
	this.processUOMLookups		= FormField_processUOMLookups;
	this.setEditStatus			= FormField_setEditStatus;
	this.setValue				= FormField_setValue;
	this.setValueWithEvents		= FormField_setValueWithEvents;
	this.getValue				= FormField_getValue;
	this.disable				= FormField_disable;
	this.enable					= FormField_enable;
	this.validate				= FormField_validate;
	this.setInvalid				= FormField_setInvalid;
	this.setValid				= FormField_setValid;
	this.getDefaultXMLValue		= FormField_getDefaultXMLValue;
	this.getCurrentXMLValue		= FormField_getCurrentXMLValue;
	this.getOriginalXMLValue	= FormField_getOriginalXMLValue;
	this.setCurrentXMLValue		= FormField_setCurrentXMLValue;
	this.addLookup				= FormField_addLookup;
	this.processFormat			= FormField_processFormat;
	this.getLabel				= FormField_getLabel;
	this.setLabelText			= FormField_setLabelText;
	this.disableQuery			= FormField_disableQuery;
	this.enableQuery			= FormField_enableQuery;
	this.disableInfoPanel		= FormField_disableInfoPanel;
	this.disableMap				= FormField_disableMap;
	this.disableAddressLookup	= FormField_disableAddressLookup;
	this.disableCTI				= FormField_disableCTI;
	this.disableDatePicker		= FormField_disableDatePicker;
	this.disableComboBox		= FormField_disableComboBox;
	this.disableFileDialog		= FormField_disableFileDialog;
	this.enableInfoPanel		= FormField_enableInfoPanel;
	this.enableMap				= FormField_enableMap;
	this.enableAddressLookup	= FormField_enableAddressLookup;
	this.enableCTI				= FormField_enableCTI;
	this.enableDatePicker		= FormField_enableDatePicker;
	this.enableComboBox			= FormField_enableComboBox;
	this.enableFileDialog		= FormField_enableFileDialog;
	this.error					= FormField_error;
	this.fireQuery				= FormField_fireQuery;
	this.fireInfoPanel			= FormField_fireInfoPanel;
	this.fireMap				= FormField_fireMap;
	this.fireAddressLookup		= FormField_fireAddressLookup;
	this.fireCTI				= FormField_fireCTI;
	this.fireDatePicker			= FormField_fireDatePicker;
	this.fireComboBox			= FormField_fireComboBox;
	this.fireFileDialog			= FormField_fireFileDialog;
	this.moveDIVControl			= FormField_moveDIVControl;
	this.clearLookup			= FormField_clearLookup;
	this.addQueryInput			= FormField_addQueryInput;
	this.addQueryResult			= FormField_addQueryResult;
	this.addUOMLookup			= FormField_addUOMLookup;
	this.setUOMValue			= FormField_setUOMValue;
	this.getUOMValue			= FormField_getUOMValue;
	this.addInfoPanelInput		= FormField_addInfoPanelInput;
	this.addMapInput			= FormField_addMapInput;
	this.addCTIInput			= FormField_addCTIInput;
	this.setInfoPanelVisibility	= FormField_setInfoPanelVisibility;
	this.setMapVisibility		= FormField_setMapVisibility;
	this.setCTIVisibility		= FormField_setCTIVisibility;
	this.addLookupInput			= FormField_addLookupInput;
	this.recall					= FormField_recall;
	this.writeRecall			= FormField_writeRecall;
	this.hide					= FormField_hide;
	this.show					= FormField_show;
	this.getHTMLElement			= FormField_getHTMLElement;
	this.performADAPTScript		= FormField_performADAPTScript;
	this.toXML					= FormField_toXML;
	this.getControlType			= FormField_getControlType;
	this.doContextMenu			= FormField_doContextMenu;
	this.setDefaultXMLValue		= FormField_setDefaultXMLValue;
	this.setCurrencyDependentFields = FormField_setCurrencyDependentFields;
	this.isRequiredField		= FormField_isRequiredField;
	this.setRequiredField		= FormField_setRequiredField;
	this.getMinLength			= FormField_getMinLength;
	this.getMaxLength			= FormField_getMaxLength;
	this.getMinValue			= FormField_getMinValue;
	this.getMaxValue			= FormField_getMaxValue;
	this.isReservedWord			= FormField_isReservedWord;
	this.focus					= FormField_focus;
	this.validatePrimaryKey		= FormField_validatePrimaryKey;
	this.isVisible				= FormField_isVisible;
	this.addAction				= FormField_addAction;
	this.triggerAction			= FormField_triggerAction;		
	this.doSystemValidation		= FormField_doSystemValidation;
	this.interpretDate			= FormField_interpretDate;
	this.setComboFilter			= FormField_setComboFilter;
	this.destroy				= FormField_destroy;
	this.hasMapModule			= FormField_hasMapModule;
	this.hasCTIModule			= FormField_hasCTIModule;
}

/** 
 * Used by ADAPT - returns an tree formatted xml representation of this object.
 *
 * @return The tree formatted xml representation of this object.
 */
function FormField_toXML()
{
	var objLabel = this.getLabel();

	if (objLabel == null || isBlank(objLabel.innerHTML))
		return null;

	var strUID = this.objForm.id + "_" + this.strRef;
	
	var strXML = "<node uid='" + strUID + "' level='4' tooltip='" + escapeXML(objLabel.innerHTML) + "'>";
	strXML += "<vals>";
	strXML += "<val id='label'>" + this.strRef + "</val>";
	strXML += "<val id='name'>" + escapeXML(objLabel.innerHTML) + "</val>";
	strXML +=" <val id='value'>" + this.getValue() + "</val>";
	strXML +=" <val id='data-type'>" + fl(this.strDataType) + "</val>";
	strXML +=" <val id='control-type'>" + this.getControlType() + "</val>";
	strXML += "<val id='event1' parameter-name='objField'>onBeforeChange</val>";
	strXML += "<val id='event2' parameter-name='objField'>onAfterChange</val>";
	strXML += "<val id='event3' parameter-name='objField'>onAfterKeypress</val>";
    strXML += "<val id='event4' parameter-name='objField'>validate</val>";
	strXML += "</vals>";
	strXML += "</node>";

	return strXML;
}

function FormField_doContextMenu(objElement, objEvent)
{
	window.parent.document.getElementById("ContextMenuElement2").style.display = "none";
	window.parent.document.getElementById("ContextMenuElement3").style.display = "none";
	
	if (! objEvent) objEvent = window.event; // Get event details for IE

	var objParentElement = getParentElement(objElement, "FORM");
	if (objParentElement == null) 
		objParentElement = getParentElement(objElement, "TR", "editableGridForm");
	if (objParentElement == null) 
		return;
	
	var strFormID = objParentElement.id.replace("frm", "");

	if (strFormID == "") return;
	
	var objForm = objApplication.Forms(strFormID);

	if (objForm == null) return;
	
	var found = false;
	var i = 0;
	var objField = null;

	var intLen = objForm.fields.length;
	while (!found && i < intLen)
	{
		if (objElement == objForm.fields[i].getHTMLElement())
		{
			objField = objForm.fields[i];
			found = true;
		}
		i++;
	}

	if (objField == null) return;
	
	if (objField.getHTMLElement().type != "checkbox" && objField.getHTMLElement().type != "radio" && objField.getHTMLElement().type != "select-one")
	{
		var contextMenu  = new ContextMenu();
		var objClipboard = new Clipboard();

		if (isBlank(objField.getValue()) || objField.HTMLElement.blnIsDisabled == "true")
			contextMenu.addOption(fl("CONTEXTCUT"), "Cut", FormField_cutText, new Array(objClipboard, objField), null, null, null, false, null, true);
		else
			contextMenu.addOption(fl("CONTEXTCUT"), "Cut", FormField_cutText, new Array(objClipboard, objField), null, null, null, false, null, false);
			
		if (isBlank(objField.getValue()))
			contextMenu.addOption(fl("CONTEXTCOPY"), "Copy", FormField_copyText, new Array(objClipboard, objField), null, null, null, false, null, true);
		else
			contextMenu.addOption(fl("CONTEXTCOPY"), "Copy", FormField_copyText, new Array(objClipboard, objField), null, null, null, false, null, false);
		
		if (objClipboard.getData("Text") == null || objClipboard.getData("Text") == "" || objField.HTMLElement.blnIsDisabled == "true")
			contextMenu.addOption(fl("CONTEXTPASTE"), "Paste", FormField_pasteText, new Array(objClipboard, objField), null, null, null, false, null, true);
		else
			contextMenu.addOption(fl("CONTEXTPASTE"), "Paste", FormField_pasteText, new Array(objClipboard, objField), null, null, null, false, null, false);
		
		if (isBlank(objField.getValue()) || objField.HTMLElement.blnIsDisabled == "true")
			contextMenu.addOption(fl("CONTEXTCLEAR"), "clear", FormField_clearText, objField, null, null, null, false, null, true);
		else
			contextMenu.addOption(fl("CONTEXTCLEAR"), "clear", FormField_clearText, objField, null, null, null, false, null, false);
		
		
		if (objField.getValue() != "" && objField.blnIsInfoPanelEnabled)
		{
			contextMenu.addOption("--------");
			contextMenu.addOption(fl("CONTEXTINFO"), "InfoPanel", FormField_displayInfoPanel, objField);
		}

		if (objField.getValue() != "" && objField.isInvalid != true && objField.arrFieldActions.length  > 0) {
			contextMenu.addOption("--------");
			var intLen = objField.arrFieldActions.length;
			
			for (var intCtr = 0; intCtr < intLen; intCtr++) {
				var objFieldAction = objField.arrFieldActions[intCtr];
				if (objFieldAction.strAppName == "appCallMan")
					contextMenu.addOption(objFieldAction.strLabel, objFieldAction.strImage, FormField_triggerAction, new Array(objFieldAction.strLabel, objField), objFieldAction.strMode, objFieldAction.strLabel, null, true, 1);
				else
					contextMenu.addOption(objFieldAction.strLabel, objFieldAction.strImage, FormField_triggerAction, new Array(objFieldAction.strLabel, objField));
			}
		}

		if (objField.HTMLElement.blnIsDisabled == "false")
		{
			for (i=0; i<5; i++)
			{
				var strValue = objApplication.FieldHistory.getClassValue(objField.HTMLElement.strClass, i);
				if (strValue == null)
					break;

				if (i == 0)
					contextMenu.addOption("--------");

				contextMenu.addOption(strValue, null, FormField_displayRecallValue, new Array(strValue, objField));
			}	

		}

		contextMenu.show(getOffsetLeftFromElement(objForm.formGroup, "mainBodyTag") + getPosX(objEvent), 
						 getOffsetTopFromElement(objForm.formGroup, "mainBodyTag") + getPosY(objEvent));
	}
	
	objEvent.cancelBubble = true;
	objEvent.returnValue = false;
}

function FormField_displayRecallValue(objContextMenuOption)
{
	var strValue = objContextMenuOption.params[0];
	var objField = objContextMenuOption.params[1];

	objField.getHTMLElement().value = strValue;
	objField.getHTMLElement().fireEvent("onchange");
}

function FormField_cutText(objContextMenuOption)
{
	FormField_copyText(objContextMenuOption);
	
	var objField = objContextMenuOption.params[1];
	FormField_clearSelectedText(objField);
}

function FormField_copyText(objContextMenuOption)
{
	var objClipboard = objContextMenuOption.params[0];
	var objField = objContextMenuOption.params[1];
	
	objClipboard.setData("Text", FormField_getSelectedText(objField));
}

function FormField_getSelectedText(objField)
{
	if (objField.objForm.objFrameWindow.document.getSelection) 
		return objField.getValue();
	else if (objField.objForm.objFrameWindow.document.selection) 
		return objField.objForm.objFrameWindow.document.selection.createRange().text;
	else 
		return null;
}

function FormField_clearSelectedText(objField)
{
	if (objField.objForm.objFrameWindow.document.getSelection) 
		objField.setValue("", FORMFIELD_WITHEVENTS | FORMFIELD_FROMONCHANGEEVENT);
	else if (objField.objForm.objFrameWindow.document.selection) 
		objField.objForm.objFrameWindow.document.selection.createRange().text = "";
	else
		objField.setValue("", FORMFIELD_WITHEVENTS | FORMFIELD_FROMONCHANGEEVENT);
}

/**
 * Clears all text in a field - called from right click context menu.
 *
 * @param objField The form field reference.
 */
function FormField_clearText(objContextMenuOption)
{
	var objField = objContextMenuOption.params;
	objField.setValue("", FORMFIELD_WITHEVENTS | FORMFIELD_FROMONCHANGEEVENT);
}

function FormField_pasteText(objContextMenuOption)
{
	var objClipboard = objContextMenuOption.params[0];
	var objField = objContextMenuOption.params[1];
	
	if (objField.objForm.objFrameWindow.document.getSelection) 
		objField.setValue(objClipboard.getData("Text"), FORMFIELD_WITHEVENTS | FORMFIELD_FROMONCHANGEEVENT);
	else if (objField.objForm.objFrameWindow.document.selection) 
	{
		objField.objForm.objFrameWindow.document.selection.createRange().text = objClipboard.getData("Text");
		objField.objForm.onchange(objField.getHTMLElement(), null, objField.objForm);
	}
	else
		objField.setValue(objClipboard.getData("Text"), FORMFIELD_WITHEVENTS | FORMFIELD_FROMONCHANGEEVENT);
	
}

function FormField_displayInfoPanel(objField)
{
	objField.params.objForm.onchange(objField.params.getHTMLElement(), null, objField.params.objForm);
		
	if (objField.params.blnIsInfoPanelEnabled)
		objField.params.fireInfoPanel();
}

function FormField_getControlType()
{
	var objHTMLElement = this.getHTMLElement();
	
	var strControlType = m_strTEXTBOX;
	if (objHTMLElement.type == "checkbox")
		strControlType = m_strCHECKBOX;
	else if (objHTMLElement.tagName.toLowerCase() == "textarea")
		strControlType = m_strTEXTAREA;
	else if (this.strDataType == "xsd:dateTime")
		strControlType = m_strDATETIMEBOX;
	else
	{
		for (var objElement = objHTMLElement.nextSibling; objElement != null; objElement = objElement.nextSibling)
		{
			if (objElement.tagName == "BUTTON" && objElement.className == "ComboBoxButton")
			{
				if (objElement.style.display == "inline")
				{
					strControlType = m_strCOMBOBOX;
					break;
				}
			}
		}	
	}
	return strControlType;
}

function FormField_getHTMLElement()
{
	if (this.HTMLElement == null)
	{
		this.objForm.postProcess();
		this.objForm.isInitialised = true;
	}
	
	return this.HTMLElement;
}

function FormField_getLabel()
{
	if (this.HTMLElement == null)
		this.getHTMLElement();

	return this.objForm.objFrameWindow.document.getElementById("lbl_" + this.HTMLElement.id);
}

/**
 *	Sets the label text for this field.
 *	@param	strLabel - the new label text.
 */
function FormField_setLabelText(strLabel)
{
	if (this.HTMLElement == null)
		this.getHTMLElement();

	var objLabel = this.objForm.objFrameWindow.document.getElementById("lbl_" + this.HTMLElement.id);
	objLabel.innerHTML = strLabel;
}

function FormField_error(strMessage) 
{
	var flgAlreadyInvalid = this.isInvalid;
	var objHTMLElement = this.objForm.formGroup;
	var objWindow = this.objForm.objWindow;
	var strLabel = this.getLabel().innerHTML;

	if (flgAlreadyInvalid == true)
		objWindow.objStatusBar.flgDoBeep = false;
	objWindow.objStatusBar.error(strLabel + " : " + objWindow.objDict.getString(strMessage));
	objWindow.objStatusBar.flgDoBeep = true;

	// Setting this field as invalid - 
	// See if this field is on a tabbed dialog. If it is then select the tab containing this field.
	// There's a possibility here for an ifinite loop so set a loop counter to no more than 1000 times.
	var i = 0	;
	while (objHTMLElement != null && i++ < 1000)
	{
		if (objHTMLElement.name == "TabRow")
		{
			var objTabStrip = objWindow[objHTMLElement.parentNode.parentNode.id.replace("tabd", "")];
			
			if (objTabStrip.arrTabs[objHTMLElement.rowIndex - 1].hasFocus() == false)
				objTabStrip.arrTabs[objHTMLElement.rowIndex - 1].select();

			break;
		}
		objHTMLElement = objHTMLElement.parentNode;
	}

	this.setInvalid();
	
	return false;
}

function FormField_addLookup(p_blnIsRequired) {
	this.lookup = new FormFieldLookup(p_blnIsRequired);
	return this.lookup;
}

function FormField_addQueryInput(strRef, strQueryColumnName, strValue)
{
	var intNewCtr = this.queryInputs.length;
	this.queryInputs[intNewCtr] = new QueryInputItem(strRef, strQueryColumnName, strValue);
}

function FormField_addQueryResult(strRef, strQueryColumnName)
{
	var intNewCtr = this.queryResults.length;
	this.queryResults[intNewCtr] = new QueryResultItem(strRef, strQueryColumnName);
}

function FormField_addUOMLookup(strRef, strLookupType)
{
	var intNewCtr = this.UOMLookups.length;
	this.UOMLookups[intNewCtr] = new UOMLookupItem(strRef, strLookupType);
}

function FormField_addInfoPanelInput(strRef)
{
	var intNewCtr = this.infoPanelInputs.length;
	this.infoPanelInputs[intNewCtr] = new InfoPanelInputItem(strRef);
}

function FormField_addMapInput(strRef, strMapColumnName)
{
	var intNewCtr = this.mapInputs.length;
	this.mapInputs[intNewCtr] = new MapInputItem(strRef, strMapColumnName);
}

function FormField_addCTIInput(strRef, strCTIColumn) {
	var intNewCtr = this.ctiInputs.length;
	this.ctiInputs[intNewCtr] = new CTIInputItem(strRef, strCTIColumn);
}

function FormField_addLookupInput(strRef, strQueryColumnName)
{
	var intNewCtr = this.lookupInputs.length;
	this.lookupInputs[intNewCtr] = new LookupInputItem(strRef, strQueryColumnName);
}

function FormField_processLookups()
{
	var flgPopulateLookup = false;

	if (this.lookup != null)
	{
		this.setValid();

		var objDataEngine = this.lookup.DataEngine;
		if (objDataEngine != null)
		{
			objDataEngine.caseSensitive = true;
			objDataEngine.clearInputParameters();

			for (var intCtr = 0, intLen = this.lookupInputs.length; intCtr < intLen; intCtr++)
			{
				var strInputVal = this.objForm.getFieldByRef(this.lookupInputs[intCtr].strRef).getValue();

				// if one of the input params is blank, abort the lookup to avoid a NoSuchMethodException caused by the null parameter.
				if (isBlank(strInputVal))
				{
					if (objDataEngine.type == "class" || intCtr == 0) {
						flgPopulateLookup = false;
						break;
					}
				}
				else 
				{
					flgPopulateLookup = true;
					objDataEngine.addInputParameter("PM" + intCtr, strInputVal, null, this.lookupInputs[intCtr].strQueryColumnName, this.objForm.getFieldByRef(this.lookupInputs[intCtr].strRef).strDataType);
				}
			}

			var objDataEngineXML=null;
			var intRowCount=0;

			if (flgPopulateLookup == true)
			{
				objDataEngineXML = objApplication.createXMLDocument();

				objDataEngine.showDataEngineErrors = false;
				var strDEXML = objDataEngine.populateEngine();

				if (objApplication.hadCriticalError)
					return;

				objDataEngineXML.loadXML(strDEXML);
				intRowCount = objDataEngineXML.selectNodes("/dataengine/data/row").length();
			}			

			if (this.lookup.isRequired == true && intRowCount != 1 && this.HTMLElement.blnIsDisabled == "false")
			{
				if (!isBlank(this.getValue()))
				{
					this.lastLookupSuccessful = false;				
					if (this.lookup.strInvalidMessage != null) 
						this.error(this.lookup.strInvalidMessage);
					else	
						this.error("VALUENOTONDATABASE");
					return false;
				}
			}

			//  if a look up is not required and this value is not found on the database, return TRUE and do 
			// not perform the lookup, and do not overwrite the calling fields value. Clear any dependent fields.
			if (intRowCount !=1) {
				this.clearLookup();
				return true;
			}

			var strLookupVal;

			for (var j = 0, intLen = this.lookup.fields.length; j < intLen; j++)
			{
				var strRef = this.lookup.fields[j].strFieldRef;
				var objField = this.objForm.getFieldByRef(strRef);

				var objNode = objDataEngineXML.selectSingleNode("/dataengine/data/row/column[@ref = '" + this.lookup.fields[j].strPropertyName + "']");

				if (objNode == null || intRowCount != 1 || !flgPopulateLookup)
					strLookupVal = "";
				else
					strLookupVal = objNode.getText();
			
				if (strRef != this.strRef)
					objField.setValueWithEvents(strLookupVal, FORMFIELD_WITHOUTRECALLSAVE);
				objField.setInfoPanelVisibility();
				objField.setMapVisibility();
				objField.setCTIVisibility();
			}
		}
	}

	this.processUOMLookups();
	this.lastLookupSuccessful = true;

	return true;
}

function FormField_processUOMLookups() {
	var objUOMLookup;
	var objField;
	var strUOM;

	if (this.UOMLookups.length == 0)
		return;
	
	if (isBlank(this.getValue()))
		strUOM = "";
	else
		strUOM = objApplication.Data.getQuantityUOMLookup(this.getValue());

	for (var intCtr = 0, intLen = this.UOMLookups.length; intCtr < intLen; intCtr++)
	{
		objUOMLookup = this.UOMLookups[intCtr];
		objField = this.objForm.getFieldByRef(objUOMLookup.strRef);
		
		if (objUOMLookup.strLookupType == "quantity")
			objField.setUOMValue(strUOM);
	}
}

function FormField_setUOMValue(strUOM) 
{
	if (this.objForm.objGridEdit != null)
		return;

	var objLabel = this.HTMLElement.parentElement.lastChild;

	if (objLabel == null || objLabel.tagName != "LABEL")
	{
		objLabel = this.objForm.objFrameWindow.document.createElement("LABEL");
        objLabel.className = "uom";
		this.HTMLElement.parentElement.appendChild(objLabel);
	}

	objLabel.innerHTML = strUOM;
}

function FormField_getUOMValue() 
{
	var objLabel = this.HTMLElement.parentElement.lastChild;

	if (objLabel != null && objLabel.tagName == "LABEL")
		return objLabel.innerHTML;
}

function FormField_setEditStatus() {
	if (this.getHTMLElement().readOnly == true)
		this.disable();
}

function FormField_setValueWithEvents(strValue)
{
	if (arguments[1] != null)
		this.setValue(strValue, arguments[1] | FORMFIELD_WITHEVENTS);
	else
		this.setValue(strValue, FORMFIELD_WITHEVENTS);
}

function FormField_setValue(strValue)
{
	strValue = String(strValue);
	var intArgVal = parseInt(arguments[1]);
	var flgFromOnchangeEvent = ((intArgVal & FORMFIELD_FROMONCHANGEEVENT) != 0);

	if (this.HTMLElement == null)
	{
		// Causes the form to initialise itself if not already done so.
		// Coded this way for performance.
		this.getHTMLElement();
		
		// Check to see if ADAPT onload has been fired - fire it if not called yet.
		if (this.objForm.flgFiredOnload == true)
			return;

		var strOnload = this.objForm.id + "_onLoad";
		if (typeof(this.objForm.objWindow[strOnload]) != "undefined") {
			this.objForm.objWindow[strOnload](this.objForm);
		}

		this.objForm.flgFiredOnload = true;
	}

	var objHTMLElement = this.HTMLElement;

	if (flgFromOnchangeEvent == false)
	{
		if (this.HTMLElement.unformattedHTMLValue == strValue)
		{
			if (this.arrCurrencyDependentFields.length > 0)
				this.setCurrencyDependentFields();

			// If edit mode has changed then may need to enable/disable info panels.
			// e.g. on the save of key details information.
			this.setInfoPanelVisibility();
			this.setMapVisibility();
			this.setCTIVisibility();

			return;
		}
	}

	strValue = unescapeXML(strValue);
		
	// If overloaded parameter exists then check to see if events should be fired
	if (arguments.length > 1)
	{
		var flgWithEvents = ((intArgVal & FORMFIELD_WITHEVENTS) != 0);
		var flgWithoutValidation = ((intArgVal & FORMFIELD_WITHOUTVALIDATION) != 0);
		var flgWithoutLookups = ((intArgVal & FORMFIELD_WITHOUTLOOKUPS) != 0);
		var flgWithoutRecallSave = ((intArgVal & FORMFIELD_WITHOUTRECALLSAVE) != 0);
		var flgWithoutAdapt = ((intArgVal & FORMFIELD_WITHOUTADAPT) != 0);
		var flgFromRefresh = ((intArgVal & FORMFIELD_FROMREFRESH) != 0);
	}
	else
	{
		var flgWithEvents = false;
		var flgWithoutValidation = false;
		var flgWithoutLookups = false;
		var flgWithoutRecallSave = false;
		var flgWithoutAdapt = false;
		var flgFromRefresh = false;
	}

	if (flgFromOnchangeEvent && this.objForm.editMode != "filter" &&
		(this.strDataType == "xsd:float" ||	this.strDataType == "xsd:double" ||
		this.strDataType == "xsd:integer" || this.strDataType == "xsd:short" ||
		this.strDataType == "xsd:smallint" || this.strDataType == "xsd:decimal"))
	{
		// convert the number to the server's locale format.
		if (!isBlank(strValue))
			strValue = util_parseNumber(strValue);
	}

	if (flgWithEvents == true && flgWithoutAdapt == false)
	{
		if (this.objForm.strSrc.indexOf("dynamic_") == -1)
		{
			var retVal = this.performADAPTScript(strValue, ADAPT_ONBEFORECHANGE);
			if (retVal == null)
				return;
			strValue = retVal;
		}
	}

	if (objHTMLElement.tagName == "TEXTAREA" || objHTMLElement.tagName.toLowerCase() == "textarea")
		objHTMLElement.value = strValue;
	else
	{
		if (objHTMLElement.type == "checkbox")
		{
			if (strValue == "true" || strValue == "-1" || strValue == "1")
			{
				objHTMLElement.checked = true;
				strValue = "true";
			}
			else
			{
				objHTMLElement.checked = false;
				strValue = "false";
			}
		}

		if (this.selectOne && this.selectOne.listValueOnly == true && this.selectOne.Values.length != 0)
		{
			var strHTMLValue = this.selectOne.getComboItemCaption(strValue);
			if (strHTMLValue == null)
			{
				strHTMLValue = strValue;
				if (this.selectOne.getComboItemValue(strValue) != null)
					strValue = this.selectOne.getComboItemValue(strValue);
			}
			objHTMLElement.value = strHTMLValue;
		}
		else
			objHTMLElement.value = strValue;
	}

	// All okay, so put the value into the XML data island...
	if (!flgFromRefresh)
		this.setCurrentXMLValue();

	// Take a copy of the previous value for this field.
	this.previousValue = objHTMLElement.unformattedHTMLValue;
	objHTMLElement.unformattedHTMLValue = strValue;

	this.processFormat(strValue);

	// Need to check for critical error - process format may have failed with system parameter requests.
	if (objApplication.hadCriticalError == true)
		return;

	var flgValidateFailed = false;
	if (flgWithoutValidation == false)
	{
		if (this.validate(flgFromOnchangeEvent, flgWithoutLookups) == false)
			flgValidateFailed = true;
	}
	else
		this.setValid();

	//If validate fails, move onto the onchange event.
	if (!flgValidateFailed)
	{
		if (this.arrCurrencyDependentFields.length > 0)
			this.setCurrencyDependentFields();
			
		// Everything is okay, so write the current value into the FieldHistory sub-system.
		if (flgWithoutRecallSave == false && flgFromOnchangeEvent == true)
			this.writeRecall(strValue);
	}
	
	// If formOnChange function is set then call it.
	if (flgWithEvents == true)
	{	
		if (this.flgFiringExternalEvent == false)
		{
			this.flgFiringExternalEvent = true;
			if (this.formOnChange != "") {
				this.objForm.objWindow[this.formOnChange.replace(/(\(\));*/, "")](this, flgFromOnchangeEvent);
			}
			this.flgFiringExternalEvent = false;

			if (flgWithoutAdapt == false)
			{
				if (this.objForm.strSrc.indexOf("dynamic_") == -1)
				{
					retVal = this.performADAPTScript(strValue, ADAPT_ONAFTERCHANGE);

					if (retVal != null && retVal != strValue)
						this.setValueWithEvents(retVal, FORMFIELD_WITHOUTADAPT | FORMFIELD_WITHOUTRECALLSAVE);
				}
			}
		}
	}
}

/** 
 * Fires any attached ADAPT javascript.
 *
 * @param strValue The value trying to be set in the formfield.
 * @param flgEventType Binary operator parameter determines which event to fire.
 * @return Returns the new formfield value - but if event was cancelled returns null.
 */
function FormField_performADAPTScript(strValue, flgEventType)
{
	var strMethodName;
	var strOldValue = this.HTMLElement.unformattedHTMLValue;
	
	if (flgEventType & ADAPT_ONBEFORECHANGE) {
		strMethodName = this.strRef + "_onBeforeChange";
	} else if (flgEventType & ADAPT_ONAFTERCHANGE) {
		strMethodName = this.strRef + "_onAfterChange";
	} else if (flgEventType & ADAPT_ONAFTERKEYPRESS) {
		strMethodName = this.strRef + "_onAfterKeypress";
	} else if (flgEventType & ADAPT_VALIDATE) {
		strMethodName = this.strRef + "_validate";
	} else {
		alert("FormField event type not supported");
		return null;
	}

	if (typeof(strMethodName) != "undefined" && this.objForm.objWindow[strMethodName] != null) {
		if (flgEventType & ADAPT_ONBEFORECHANGE || flgEventType & ADAPT_ONAFTERCHANGE)
			this.setValue(strValue, FORMFIELD_WITHOUTADAPT | FORMFIELD_WITHOUTVALIDATION | FORMFIELD_WITHOUTLOOKUPS | FORMFIELD_WITHOUTRECALLSAVE);
		
		for (var intCtr = 0, intLen = this.objForm.fields.length; intCtr < intLen; intCtr++)
		{
			var objField = this.objForm.fields[intCtr];
			if (!this.isReservedWord(objField.strRef) && objField.HTMLElement.tagName != "TEXTAREA") {
				var strFieldValue;
				
				if (flgEventType & ADAPT_ONAFTERKEYPRESS) {
					strFieldValue = "" + objField.HTMLElement.value;
				} else {
					strFieldValue = "" + objField.getValue();
				}
				
				this.objForm.objWindow[objField.strRef] = strFieldValue;
				this.objForm.objWindow[objField.strRef + "_original"] = strFieldValue;
			}
		}
		
		if (this.objForm.objWindow[strMethodName](this) == false) {
			strValue = strOldValue;
			this.setValue(strValue, FORMFIELD_WITHOUTADAPT | FORMFIELD_WITHOUTVALIDATION | FORMFIELD_WITHOUTLOOKUPS | FORMFIELD_WITHOUTRECALLSAVE);
			return null;
		}

		for (var intCtr = 0, intLen = this.objForm.fields.length; intCtr < intLen; intCtr++)
		{
			var objField = this.objForm.fields[intCtr];
			if (!this.isReservedWord(objField.strRef))	{
				var strNewValue = this.objForm.objWindow[objField.strRef];
				var strOriginalValue = this.objForm.objWindow[objField.strRef + "_original"];
				if (strNewValue != strOriginalValue)
				{
					if (objField.strRef == this.strRef)
						strValue = strNewValue;
					else
						objField.setValueWithEvents(strNewValue, FORMFIELD_WITHOUTRECALLSAVE);
				}
			}
		}
	}
	
	return strValue;
}

/**
 * Check whether the field strRef is a window property
 * @param strRef The reference being checked
 * @return true if a property otherwise false.
 */
function FormField_isReservedWord(strRef) {
	if (strRef == "status" || strRef == "clientInformation" || strRef == "closed" || strRef == "defaultStatus" || strRef == "dialogArguments" ||
		strRef == "dialogHeight" || strRef == "dialogLeft" || strRef == "dialogTop" || strRef == "dialogWidth" || strRef == "document" ||
		strRef == "event" || strRef == "history" || strRef == "innerHeight" || strRef == "innerWidth" || strRef == "length" || strRef == "location" ||
		strRef == "locationbar" || strRef == "menubar" || strRef == "name" || strRef == "navigator" || strRef == "offscreenBuffering" ||
		strRef == "opener" || strRef == "outerHeight" || strRef == "outerWidth" || strRef == "pageXOffset" || strRef == "pageYOffset" ||
		strRef == "parent"  || strRef == "personalbar" || strRef == "returnValue" || strRef == "screen" || strRef == "scrollbars" || strRef == "self" ||
		strRef == "statusbar" || strRef == "toolbar" || strRef == "top")
		return true;
	return false;
}

function FormField_getValue()
{
	var objHTMLElement = this.getHTMLElement();

	if (this.overwriteValidate != null) 
	{
		if (this.selectOne && this.selectOne.listValueOnly == true && this.selectOne.Values.length != 0)
			return (objHTMLElement.unformattedHTMLValue == null) ? "" : this.HTMLElement.unformattedHTMLValue;
		else
			return objHTMLElement.value;
	}

	if (objHTMLElement.tagName.toLowerCase() == "textarea")
		return objHTMLElement.innerHTML;
	else
	{
		if (objHTMLElement.unformattedHTMLValue != null && (this.strDataType == "xsd:float" ||
		                                          this.strDataType == "xsd:double" ||
		                                          this.strDataType == "xsd:integer" ||
		                                          this.strDataType == "xsd:short" ||
		                                          this.strDataType == "xsd:smallint" ||
		                                          this.strDataType == "xsd:decimal" ||
		                                          (this.selectOne && this.selectOne.listValueOnly == true && this.selectOne.Values.length != 0)))
			return objHTMLElement.unformattedHTMLValue;
		else	
			return objHTMLElement.value;
	}
}

function FormField_getCurrentXMLValue()
{
	if (this.strRef == "")
		return null;

	if (this.objForm.objXMLNode == null)
		return null;
		
	var objValueNode = this.objForm.objXMLNode.selectSingleNode(this.strRef);
	return objValueNode == null ? null : objValueNode.selectSingleNode("value").getText();
}

function FormField_getOriginalXMLValue()
{
	if (this.strRef == "")
		return null;

	var objValueNode = this.objForm.objXMLNode.selectSingleNode(this.strRef);
	return objValueNode == null ? null : objValueNode.selectSingleNode("original").getText();
}

function FormField_setCurrentXMLValue()
{
	var strChecked;
	var objDate;
	var objHTMLElement = this.getHTMLElement();

	// User may be calling setValue before a form refresh has set up the DOM.
	// Initialise the DOM if this is the case.
	if (this.strRef == "" || this.objForm.objXMLNode == null)
	{
		if (this.objForm.DOM != null)
		{
			var objNode = this.objForm.DOM.selectSingleNode(this.objForm.XPath);
			if (objNode != null)
				this.objForm.setFieldsFromXML(this.objForm.FCurrent);
			else
				return;
		}
		else
			return;
	}

	var objValueNode = this.objForm.objXMLNode.selectSingleNode(this.strRef);

	if (objValueNode == null) {
		if (this.objForm.objXMLNode.ownerDocument().documentElement() != null)
			var objValueNode = this.objForm.objXMLNode.ownerDocument().documentElement().selectSingleNode(this.strRef);
		
		if (objValueNode == null) {
			return;
		}
	}

	if (objHTMLElement.type == "checkbox")
	{
		if (objHTMLElement.checked == true)
			objHTMLElement.value = "true";
		else
			objHTMLElement.value = "false";
	}

	// Check if date is already in ISO format, if not then change it using a new date object. Then populate XML.
	if (this.strDataType == "xsd:dateTime")
	{
		if (isISODate(objHTMLElement.value) == true || isBlank(objHTMLElement.value))
			objValueNode.selectSingleNode("value").setText(objHTMLElement.value);
		else {
			var objEfacsCalendar=objApplication.getCalendarParser();
			try {
				objEfacsCalendar.setDateTimeInLocaleFormat (objHTMLElement.value);
				objValueNode.selectSingleNode("value").setText(objEfacsCalendar.getDateTimeInISO());
			}	
			catch (error) {
				// if the date is invalid and isnt ISO either. 
				objValueNode.selectSingleNode("value").setText(objHTMLElement.value);
			}
		}	
	}
	else if (this.selectOne && this.selectOne.listValueOnly == true && this.selectOne.Values.length != 0)
	{
		var strValue = this.selectOne.getComboItemValue(objHTMLElement.value);
		if (strValue == null)
			objValueNode.selectSingleNode("value").setText(objHTMLElement.value);
		else
			objValueNode.selectSingleNode("value").setText(strValue);
	}
	else
	{
		objValueNode.selectSingleNode("value").setText(objHTMLElement.value);
	}
		
	if (isBlank (objHTMLElement.value))
		objValueNode.selectSingleNode("value").setAttribute("xsi:nil", "true");
	else {
		objValueNode.selectSingleNode("value").removeAttribute("xsi:nil");
		
		// Need to handle null bit values on the database, for checkboxes null equates to false
		// so to stop emerald thinking that the value has changed we will also update the original value.
		// Note - we cannot remove the xsl:nil attribute though as if we did and we then checked the check box
		// the backend architecture would think that the record has been updated since we last loaded it.
		if (objHTMLElement.type == "checkbox" && objHTMLElement.value == "false" &&
			objValueNode.selectSingleNode("original").getAttribute("xsi:nil") == "true") {
			objValueNode.selectSingleNode("original").setText(objHTMLElement.value);
		}
	}
}

function FormField_getDefaultXMLValue()
{
	if (this.HTMLElement == null)
		this.getHTMLElement();

	var strdefaultEValue = this.HTMLElement.defaultEValue;
	
	if (strdefaultEValue == null)
		strdefaultEValue = "";
	else if (strdefaultEValue == "getdate()") {
		var objEfacsCalendar=objApplication.getCalendarParser();
		objEfacsCalendar.setCurrentDateTime();
		strdefaultEValue = objEfacsCalendar.getDateTimeInISO();
		}

	return strdefaultEValue;
}

function FormField_disable()
{
	var objHTMLElement = this.getHTMLElement();
	
	if (objHTMLElement.blnIsDisabled == "true")
		return;

	if (objHTMLElement.type == "checkbox" || objHTMLElement.type == "radio")
	{
		objHTMLElement.className = "CheckRadio";
		objHTMLElement.disabled = true;
		objHTMLElement.tabIndex = "-1";
	}
	else if (objHTMLElement.type == "select-one")
	{
		objHTMLElement.disabled = true;
	}
	else
	{
		objHTMLElement.className = "ReadBox";
		objHTMLElement.readOnly = true;
		objHTMLElement.tabIndex = "-1";
	}
	objHTMLElement.blnIsDisabled = "true";
	this.disableQuery();

	if(this.strDataType == "xsd:dateTime")
		this.disableDatePicker();
		
	if (this.selectOne != null)
		this.disableComboBox();
		
	if (objHTMLElement.addressLookupColumn == "postcode")
		this.disableAddressLookup();

	this.setInfoPanelVisibility();
	this.setMapVisibility();
	this.setCTIVisibility();
}

function FormField_enable()
{
	var objHTMLElement = this.getHTMLElement();

	if (objHTMLElement.blnIsDisabled == "false")
		return;

	if (objHTMLElement.type == "checkbox" || objHTMLElement.type == "radio")
	{
		if (this.isInvalid)
			objHTMLElement.className = "InvalidCheckRadio";
		else
			objHTMLElement.className = "CheckRadio";
		objHTMLElement.disabled = false;
		objHTMLElement.tabIndex = "";
	}
	else if (objHTMLElement.type == "select-one")
	{
		objHTMLElement.disabled = false;
	}
	else
	{
		if (this.isInvalid)
			objHTMLElement.className = "InvalidTextBox";
		else
			objHTMLElement.className = "TextBox";
		
		objHTMLElement.readOnly = false;
		objHTMLElement.tabIndex = "";
	}
	objHTMLElement.blnIsDisabled = "false";
	this.enableQuery();

	if(this.strDataType == "xsd:dateTime")
		this.enableDatePicker();
	
	if (this.selectOne != null)
		this.enableComboBox();

	if (objHTMLElement.addressLookupColumn == "postcode")
		this.enableAddressLookup();

	if (this.isRequiredField() || (objHTMLElement.schemaField == "true" && this.getMinLength() > 0 && this.objForm.editMode != "filter"))
	{
		if (objHTMLElement.value == "")
			objHTMLElement.className = "EfacsFieldRequired";
	}

	this.setInfoPanelVisibility();
	this.setMapVisibility();
	this.setCTIVisibility();
}

function FormField_disableQuery() 
{
	if (this.HTMLElement == null)
		this.getHTMLElement();

	if (this.HTMLElement.strQuery == null || this.HTMLElement.blnIsQueryEnabled == "false")
		return;

	var objLabelElement = this.getLabel();
	if (objLabelElement != null) {
		objLabelElement.title = "";
		objLabelElement.className = "EfacsLabel";
		removeEvent(objLabelElement, "onclick", this.objForm.objFrameWindow.fireQuery);
		objLabelElement.onclick = "";
		this.HTMLElement.blnIsQueryEnabled = "false";
	}
}

function FormField_enableQuery() 
{
	var objHTMLElement = this.getHTMLElement();

	if (objHTMLElement.strQuery == null || objHTMLElement.blnIsQueryEnabled == "true")
		return;

	if (objHTMLElement.isprimary == "true" && this.objForm.editMode == "add" && objHTMLElement.schemaField == "true")
	{
		if (objHTMLElement.hasForeignKey != "true")
			return;
	}

	var objLabelElement = this.getLabel();
	if (objLabelElement != null) {
		objLabelElement.title = fl("EXECUTEQUERY") + " " + objLabelElement.innerHTML;
		objLabelElement.className = "SearchLink";
		removeEvent(objLabelElement, "onclick", this.objForm.objFrameWindow.fireQuery);
		addEvent(objLabelElement, "onclick", this.objForm.objFrameWindow.fireQuery);
		objHTMLElement.blnIsQueryEnabled = "true";	
	}
}

function FormField_fireQuery() {
	var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Queries_HTML/" + this.HTMLElement.strQuery + ".html?selectionmode=single&formid=" + this.objForm.id + "&fieldref=" + this.strRef;

	if (this.HTMLElement.autoExecuteQuery == "true")
		strURL += "&autosearch=true";

	if (!isBlank(objApplication.appID))
	{
		strURL += "&appid=" + objApplication.appID;
		strURL += "&menuid=" + objApplication.menuID;
	}

	objApplication.openChildWindow(this.objForm.objWindow, strURL);
}

function FormField_disableInfoPanel(permanent)
{
	if (this.HTMLElement == null)
		this.getHTMLElement();

	if (permanent)
		this.permanentInfoDisable = true;

	if (this.blnIsInfoPanelEnabled == false || isBlank(this.HTMLElement.strInfoPanelName))
		return;

	for (var objInfoElement = this.getHTMLElement().nextSibling; objInfoElement != null; objInfoElement = objInfoElement.nextSibling)
	{
		if (objInfoElement.tagName == "BUTTON" && objInfoElement.className == "InfoPanelButton")
		{
			objInfoElement.style.display = "none";
			this.blnIsInfoPanelEnabled = false;
			return;
		}
	}	
}

function FormField_disableMap(permanent) {
	if (! this.hasMapModule())
		return; // No mapping modules
		
	if (permanent)
		this.permanentMapDisable = true;
	
	for (var objMapElement = this.getHTMLElement().nextSibling; objMapElement != null; objMapElement = objMapElement.nextSibling) {
		if (objMapElement.tagName == "BUTTON" && objMapElement.className == "MapButton") {
			objMapElement.style.display = "none";
			this.blnIsMapEnabled = false;
			return;
		}
	}	
}

function FormField_disableCTI(permanent) {
	if (! this.hasCTIModule())
		return;
	
	if (permanent)
		this.permanentCTIDisable = true;

	for (var objCTIElement = this.getHTMLElement().nextSibling; objCTIElement != null; objCTIElement = objCTIElement.nextSibling) {
		if (objCTIElement.tagName == "BUTTON" && objCTIElement.className == "CTIButton") {
			objCTIElement.style.display = "none";
			this.blnIsCTIEnabled = false;
			return;
		}
	}	
}

function FormField_disableAddressLookup(permanent) {
	if (! objApplication.Modules("0003a-addlk"))
		return; // No address lookup module
		
	if (this.HTMLElement == null)
		this.getHTMLElement();

	if (this.HTMLElement.addressLookupColumn != "postcode" && this.HTMLElement.strClass != "POSTCODE")
		return;
	
	if (permanent)
		this.permanentAddressDisable = true;
	
	for (var objAddressElementElement = this.getHTMLElement().nextSibling; objAddressElementElement != null; objAddressElementElement = objAddressElementElement.nextSibling) {
		if (objAddressElementElement.tagName == "BUTTON" && objAddressElementElement.className == "AddressLookupButton") {
			objAddressElementElement.style.display = "none";
			return;
		}
	}	
}

function FormField_disableDatePicker(permanent)
{
	if (permanent)
		this.permanentDateDisable = true;
	
	if (this.strDataType != "xsd:dateTime")
		return;
	
	for (var objElement = this.getHTMLElement().nextSibling; objElement != null; objElement = objElement.nextSibling)
	{
		if (objElement.tagName == "BUTTON" && objElement.className == "DatePickerButton")
		{
			objElement.style.display = "none";
			return;
		}
	}	
}

function FormField_disableComboBox()
{
	for (var objElement = this.getHTMLElement().nextSibling; objElement != null; objElement = objElement.nextSibling)
	{
		if (objElement.tagName == "BUTTON" && objElement.className == "ComboBoxButton")
		{
			objElement.style.display = "none";
			return;
		}
	}
	if (this.HTMLElement.tagName == "SELECT")
		this.HTMLElement.disabled = true;
}

/**
 * Hides fileDialog's browse button
 */
function FormField_disableFileDialog()
{
	for (var objElement = this.getHTMLElement().nextSibling; objElement != null; objElement = objElement.nextSibling)
	{
		if (objElement.tagName == "BUTTON" && objElement.className == "FileDialogButton")
		{
			objElement.style.display = "none";
			return;
		}
	}
}

function FormField_enableInfoPanel()
{
	if (this.HTMLElement == null)
		this.getHTMLElement();

	if (this.blnIsInfoPanelEnabled == true)
		return;

	for (var objInfoElement = this.getHTMLElement().nextSibling; objInfoElement != null; objInfoElement = objInfoElement.nextSibling)
	{
		if (objInfoElement.tagName == "BUTTON" && objInfoElement.className == "InfoPanelButton")
		{
			objInfoElement.style.display = "inline";
			if (objApplication.bMobile == true)
				objInfoElement.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifMobileInfoPanel.gif)";
			else
				objInfoElement.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/Sapphire_PNG/Info_Bubble_16_n_p.png)";
			removeEvent(objInfoElement, "onclick", this.objForm.objWindow.fireInfoPanel);
			addEvent(objInfoElement, "onclick", this.objForm.objWindow.fireInfoPanel);
			this.blnIsInfoPanelEnabled = true;
			return;
		}
	}
}

/**
 * Enable the Map lookup
 */
function FormField_enableMap() {
	if (! this.hasMapModule())
		return; // No mapping modules
		
	if (this.HTMLElement == null)
		this.getHTMLElement();

	if (this.HTMLElement.mapLookup != "true" || this.blnIsMapEnabled == true || this.permanentMapDisable == true)
		return;

	for (var objMapElement = this.getHTMLElement().nextSibling; objMapElement != null; objMapElement = objMapElement.nextSibling) {
		if (objMapElement.tagName == "BUTTON" && objMapElement.className == "MapButton") {
			objMapElement.style.display = "inline";
			objMapElement.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifmap.gif)";
			removeEvent(objMapElement, "onclick", this.objForm.objWindow.fireMap);
			addEvent(objMapElement, "onclick", this.objForm.objWindow.fireMap);
			this.blnIsMapEnabled = true;
			return;
		}
	}
}

/**
 * Enable the CTI lookup
 */
function FormField_enableCTI() {
	if (! this.hasCTIModule())
		return; // No CTI module

	if (this.HTMLElement == null)
		this.getHTMLElement();

	if (this.HTMLElement.ctiLookup != "true" || this.permanentCTIDisable == true)
		return;
	
	// Only add the CTI icon if it a number that CTI can actually use (i.e not a fax number...)
	for (var intCtr=0, intLen = this.ctiInputs.length; intCtr < intLen; intCtr++) {
		var objCTI = this.ctiInputs[intCtr];
		
		// If a cti "type" input is defined against the field then the field must be able to hold none callable telephone 
		// numbers (fax for example) and so we need to switch on/off the icon as we only want it for callable numbers
		if (objCTI.strCTIColumn == "type") {
			var strCTIType = this.objForm.getFieldByRef(objCTI.strRef).getValue();
			
			if (strCTIType != "Telephone") {
				if (this.blnIsCTIEnabled == true) {
					// CTI was enabled (icon shows) for the previous record and so we need to remove the icon
					for (var objCTIElement = this.getHTMLElement().nextSibling; objCTIElement != null; objCTIElement = objCTIElement.nextSibling) {
						if (objCTIElement.tagName == "BUTTON" && objCTIElement.className == "CTIButton") {
							objCTIElement.style.display = "none";
							this.blnIsCTIEnabled = false;
							break;
						}
					}
				}
				return;
			}
			break;
		}
	}

	for (var objCTIElement = this.getHTMLElement().nextSibling; objCTIElement != null; objCTIElement = objCTIElement.nextSibling) {
		if (objCTIElement.tagName == "BUTTON" && objCTIElement.className == "CTIButton") {
			objCTIElement.style.display = "inline";
			objCTIElement.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcalldial.gif)";
			removeEvent(objCTIElement, "onclick", this.objForm.objWindow.fireCTI);
			addEvent(objCTIElement, "onclick", this.objForm.objWindow.fireCTI);
			this.blnIsCTIEnabled = true;
			return;
		}
	}
}

function FormField_enableAddressLookup() {
	if (! objApplication.Modules("0003a-addlk"))
		return; // No address lookup module
		
	var objHTMLElement = this.getHTMLElement();

	if (objHTMLElement.addressLookupColumn != "postcode" || objHTMLElement.blnIsDisabled == "true" || this.permanentAddressDisable == true)
		return;

	for (var objAddressLookupElement = objHTMLElement.nextSibling; objAddressLookupElement != null; objAddressLookupElement = objAddressLookupElement.nextSibling) {
		if (objAddressLookupElement.tagName == "BUTTON" && objAddressLookupElement.className == "AddressLookupButton") {
			objAddressLookupElement.style.display = "inline";
			objAddressLookupElement.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifAddressLookup.gif)";
			removeEvent(objAddressLookupElement, "onclick", this.objForm.objWindow.fireAddressLookup);
			addEvent(objAddressLookupElement, "onclick", this.objForm.objWindow.fireAddressLookup);
			return;
		}
	}
}

function FormField_enableDatePicker()
{
	if(this.strDataType != "xsd:dateTime" || this.permanentDateDisable == true)
		return;
		
	for (var objElement = this.getHTMLElement().nextSibling; objElement != null; objElement = objElement.nextSibling)
	{
		if (objElement.tagName == "BUTTON" && objElement.className == "DatePickerButton")
		{
			objElement.style.display = "inline";

			return;
		}
	}	
}

function FormField_enableComboBox()
{
	if (this.HTMLElement == null)
		this.getHTMLElement();

	if (this.HTMLElement.isprimary == "true" && this.objForm.editMode == "add" && this.HTMLElement.schemaField == "true")
	{
		if (this.HTMLElement.hasForeignKey != "true")
			return;
	}

	for (var objElement = this.getHTMLElement().nextSibling; objElement != null; objElement = objElement.nextSibling)
	{
		if (objElement.tagName == "BUTTON" && objElement.className == "ComboBoxButton")
		{
			objElement.style.display = "inline";
			return;
		}
	}	

	if (this.HTMLElement.tagName == "SELECT")
		this.HTMLElement.disabled = false;
}

/**
 * Shows fileDialog's browse button
 */
function FormField_enableFileDialog()
{
	for (var objElement = this.getHTMLElement().nextSibling; objElement != null; objElement = objElement.nextSibling)
	{
		if (objElement.tagName == "BUTTON" && objElement.className == "FileDialogButton")
		{
			objElement.style.display = "inline";
			return;
		}
	}	
}

function FormField_fireInfoPanel()
{
	var strKeyValues = "";
	var objInputField;
	var strTitle;

	if (this.infoPanelInputs.length == 0){
		strKeyValues = "&value0=" + replaceForURL(b64Encode(this.getValue()));
	}
	else
	{
		for (var intCtr=0, intLen = this.infoPanelInputs.length; intCtr < intLen; intCtr++)
		{
			objInputField = this.objForm.getFieldByRef(this.infoPanelInputs[intCtr].strRef);
			strKeyValues += "&value" + intCtr + "=" + replaceForURL(b64Encode(objInputField.getValue()));
		}
	}
	strTitle = replaceForURL(b64Encode(this.getLabel().innerHTML));
	
	var objTopWindow = window;
	for (var objWindow = window.parent; objWindow != null; objWindow = objWindow.opener)
	{
		objTopWindow = objWindow;

		var objApplet = objTopWindow.document.getElementById(objApplication ? (objApplication.browser == APPLICATION_IE ? "EfacsApplet" : "EfacsAppletNN") : (navigator.appName == "Netscape" ? "EfacsAppletNN" : "EfacsApplet"));
		if (objApplet != null)
			break;
	}
	
	var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/InfoPanels_HTML/" + this.HTMLElement.strInfoPanelName + ".html?panel=" + this.HTMLElement.strInfoPanelName + "&" + strKeyValues + "&title=" + strTitle;
	
	objApplication.openChildWindow(objTopWindow, strURL, objApplication.User.company.replace(" ", "_") + objApplication.User.userID + this.HTMLElement.strInfoPanelName);
}

/**
 * Fire the date picker control
 * @param objEvent Event object
 */
function FormField_fireDatePicker(objEvent) {
	var objDatePicker = this.objForm.objWindow.document.getElementById("ctlDatePicker");

	if (objDatePicker.src == "") {
		var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Applications_HTML/appDateTimePicker.html?mobile=" + objApplication.bMobile;
		if (!isBlank(objApplication.appID)) {
			strURL += "&appid=" + objApplication.appID;
			strURL += "&menuid=" + objApplication.menuID;
		}
		objDatePicker.src = strURL;

		if (objApplication.bMobile == true)	{
			objDatePicker.style.height = "280";
			objDatePicker.style.width = "240";
		}
		else {
			objDatePicker.style.height = "262";
			objDatePicker.style.width = "170";
		}
	}

	objDatePicker.style.display = "inline";
	var x = getOffsetLeftFromElement(this.objForm.formGroup, "mainBodyTag") + getOffsetLeftFromElement(this.getHTMLElement(), "mainBodyTag");
	var y = getOffsetTopFromElement(this.objForm.formGroup, "mainBodyTag") + getOffsetTopFromElement(this.getHTMLElement(), "mainBodyTag");

	this.moveDIVControl(x, y, "ctlDatePicker");
	
	FormField_waitForDPContent(this.strRef, this.objForm.id, this.objForm.objWindow.name);
}

/**
 * Fire the combo box control
 * @param objEvent Event object
 */
function FormField_fireComboBox(objEvent) {

	objApplication.comboFormFieldObjectRef = this;
	
	var x = getOffsetLeftFromElement(this.objForm.formGroup, "mainBodyTag") + getOffsetLeftFromElement(this.getHTMLElement(), "mainBodyTag");
	var y = getOffsetTopFromElement(this.objForm.formGroup, "mainBodyTag") + getOffsetTopFromElement(this.getHTMLElement(), "mainBodyTag");

	this.moveDIVControl(x, y, "ctlComboBox");
	
	var objForm;
	for (var intCtr = 0, intLen = objApplication.arrForms.length; intCtr < intLen; intCtr++) {
		objForm = objApplication.arrForms[intCtr];
		if (objForm.id == this.objForm.id && objForm.objWindow.name == this.objForm.objWindow.name)
			break;
	}

	var objField = objForm.getFieldByRef(this.strRef);
	
	if (objApplication.hadCriticalError)
		return;

	var objDiv = objForm.objWindow.document.getElementById("ctlComboBox");
	var objComboFrame = objForm.objWindow.document.getElementById("ctlComboBoxFrame");
	objDiv.style.visibility = "visible";
	objDiv.style.display = "inline";
	
	if (objField.DataEngine != null)
		FormField_setUpDataEngine(objForm, objField);

	objField.selectOne.setFieldRef(objField, objDiv);
	
	if (objApplication.hadCriticalError) {
		objForm.objWindow.close();
		return;
	}

	// If user has received handled EFACS error - then exit.
	if (objField.DataEngine != null) {
		if (objField.DataEngine.FAILED)
			return;
	
		if (objField.DataEngine.sqlOriginalCriteria != null) {
			// Restore original sql criteria if was changed to include current field value.
			objField.DataEngine.sqlCriteria = objField.DataEngine.sqlOriginalCriteria;
			objField.DataEngine.sqlOriginalCriteria = null;
		}
	}

	objForm.objWindow.document.getElementById("ctlComboBox").style.display = "inline";
	objComboFrame.style.width = objDiv.offsetWidth;
	objComboFrame.style.height = objDiv.offsetHeight;
	objComboFrame.style.top = objDiv.style.top;
	objComboFrame.style.left = objDiv.style.left;
	objComboFrame.style.display = "inline";

	objField.selectOne.setFocus();
}

/**
 * Set up the data engine for the field
 * @param objForm Form object
 * @param objField Field object
 */
function FormField_setUpDataEngine(objForm, objField) {
	objField.DataEngine.clearInputParameters();

	// If query inputs specifically defined then use them as the input parameters.
	if (objField.queryInputs.length > 0) {
		for (var intCtr = 0, intLen = objField.queryInputs.length; intCtr < intLen; intCtr++) {
			var strInputVal = objForm.getFieldByRef(objField.queryInputs[intCtr].strRef).getValue();
			
			if (!isBlank(strInputVal)) {
				objField.DataEngine.addInputParameter("PM" + intCtr, 
											strInputVal, 
											null,
											objField.queryInputs[intCtr].strQueryColumnName, 
											objForm.getFieldByRef(objField.queryInputs[intCtr].strRef).strDataType);
			}
		}
	}

	// Use the current field value in the WHERE clause - if it is not blank.
	var strInputVal = objField.getValue();
	if (!isBlank(strInputVal) &&
		objField.strDataType == "xsd:string" &&
		!isBlank(objField.DataEngine.sqlCommand))
	{
		var strColumnName = "";
		var regEx = /\*/g;
		strInputVal = strInputVal.replace(regEx, "%");
		objField.DataEngine.sqlOriginalCriteria = objField.DataEngine.sqlCriteria;
		
		if (isBlank(objField.DataEngine.sqlCriteria))
			objField.DataEngine.sqlCriteria = " WHERE ";
		else
			objField.DataEngine.sqlCriteria += " AND ";


		var strSQLWord = "";
		for (var intStartPos = 0, intLen = objField.DataEngine.sqlCommand.length; intStartPos < intLen; intStartPos++) {
			var strChar = objField.DataEngine.sqlCommand.charAt(intStartPos);
			if (strChar == "{")	{
				strColumnName = objField.DataEngine.sqlCommand.substring(intStartPos, objField.DataEngine.sqlCommand.indexOf("}") + 1);
				break;
			}
			
			// Ignore tabs and spaces.
			if (strChar == " " || strChar == "," || String.fromCharCode("9") == strChar) {
				if (!isBlank(strSQLWord)) {
					if (strSQLWord.toUpperCase() == "SELECT" ||
						strSQLWord.toUpperCase() == "DISTINCT" ||
						strSQLWord.toUpperCase() == "TOP" ||
						strSQLWord.toUpperCase() == "ALL" ||
						strSQLWord.toUpperCase() == "PERCENT" ||
						!isNaN(Number(strSQLWord)))
					{
						strSQLWord = "";
						continue;
					}

					strColumnName = strSQLWord;
					break;
				}
				else
					continue;
			}
						
			strSQLWord += strChar;
		}
		
		objField.DataEngine.sqlCriteria += strColumnName + " LIKE '" + strInputVal + "%'";
	}
	// The application might specify extra information to include in the where clause
	if (!isBlank(objField.strComboFilter)) {
		if ((isBlank(strInputVal) || objField.strDataType != "xsd:string") && !isBlank(objField.DataEngine.sqlCommand))
			objField.DataEngine.sqlOriginalCriteria = objField.DataEngine.sqlCriteria;

		var strExtraFilter;
		
		if (objField.strComboFilter.indexOf(".") == -1) {
			strExtraFilter = objForm.objWindow[objField.strComboFilter](objForm.id);
		} else {
			var evalFunction = new Function("objForm", "return objForm.objWindow." + objField.strComboFilter + "(objForm.id);");
			strExtraFilter = evalFunction(objForm);
		}
	
		if (!isBlank(strExtraFilter) && !isBlank(objField.DataEngine.sqlCommand)) {
			if (isBlank(objField.DataEngine.sqlCriteria))
				objField.DataEngine.sqlCriteria = " WHERE " + strExtraFilter;
			else
				objField.DataEngine.sqlCriteria += " AND " + strExtraFilter;
		}
	}
}

/**
 * Opens 'browse to file window and inputs the chosen path into the field
 * @param objEvent The event object
 * @param fileDialogType whether folder or not
 * @param strOnFileSelectMethod The method to be called ater getting the filename
 */
function FormField_fireFileDialog(objEvent, fileDialogType, strOnFileSelectMethod)
{
	if (m_objFunctionalTest.isFunctionalTestPlaying())
		return;

	objWindow = objEvent.srcElement.ownerDocument.parentWindow;
	var path = objWindow.document.getElementById("filechooser").showFileDialog(fileDialogType, this.getValue());
	this.setValue(path);
	if (!isBlank(strOnFileSelectMethod)) {
		var evalFunction = new Function("objForm", "path", "objForm.objWindow." + strOnFileSelectMethod + "(path)");
		evalFunction(this.objForm, path);
	}
}

/**
 * Fire the date picker control
 * @param strFieldId Field ID
 * @param strFormId Form ID
 * @param strWindowName Window name
 */
function FormField_waitForDPContent(strFieldId, strFormId, strWindowName) {
	var objForm;
	for (var intCtr = 0, intLen = objApplication.arrForms.length; intCtr < intLen; intCtr++) {
		objForm = objApplication.arrForms[intCtr];
		if (objForm.id == strFormId && objForm.objWindow.name == strWindowName)
			break;
	}

	var objField = objForm.getFieldByRef(strFieldId);
	
	if (objApplication.hadCriticalError)
		return;

	var frame = objForm.objWindow.frames["ctlDatePicker"];
	if (frame.m_flgInitialised != true)
		objForm.objWindow.setTimeout("FormField_waitForDPContent('" + strFieldId + "', '" + strFormId + "', '" + strWindowName + "')", 10);
	else {
		frame.setFieldRef(objField);
		
		if (objApplication.hadCriticalError) {
			objForm.objWindow.close();
			return;
		}
		
		var objDate;
		// get a java date object from EfacsApplet based on the field's content.
		try {
			objDate = objApplication.getDateParser().parse(objField.getValue());
		} catch (objError) {
		}
		// if what is returned is a Date object
		if ((objDate != null) && ((typeof (objDate.setMinutes))!= "undefined"))
			// pass a java date object for the datepicker
			frame.setDate(objDate);
		else
			// datepicker will use the server date
			frame.setDate();

		frame.document.getElementById("btnOK").focus();
	}
}

/**
 * Sets the combo filter.
 * The combo filter is to allow applications to add extra information to the where clause 
 * that is used when a combo box is displayed.
 * @param strMethod - the method in the calling application that generates the extra SQL
 */
function FormField_setComboFilter(strMethod) {
	this.strComboFilter = strMethod;
}

/**
 * Position the control on the page
 * @param x x co-ordinate
 * @param y y co-ordinate
 * @param strControlId Control id
 */
function FormField_moveDIVControl(x, y, strControlId) {
	var objControl = this.objForm.objWindow.document.getElementById(strControlId);
	var objWindow = this.objForm.objWindow;

	x += 2;
	y += this.getHTMLElement().offsetHeight;

	// Check that the frame lies within the page
	var doch = objWindow.document.body.clientHeight;
	var dh = objControl.offsetHeight + y - doch;
	if (dh > 0) {
		// The element will run off the page
		objControl.style.top = y - dh;
	} else {
		objControl.style.top = y;
	}

	var docw = objWindow.document.body.clientWidth;
	var dw = objControl.offsetWidth + x - docw;
	if (dw > 0) {
		// The element will run off the page
		objControl.style.left = x - dw;
	} else {
		objControl.style.left = x;
	}
}

/**
 *
 */
function FormField_fireAddressLookup() {
	var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Applications_HTML/appAddressLookup.html?formid=" + this.objForm.id;
	strURL += "&postcode=" + this.getValue() + "&apptitle=" + fl("ADDRESSLOOKUP");
	if (!isBlank(objApplication.appID))
	{
		strURL += "&appid=" + objApplication.appID;
		strURL += "&menuid=" + objApplication.menuID;
	}
	
	objApplication.openChildWindow(this.objForm.objWindow, strURL);
}

/**
 * Fire CTI
 */
function FormField_fireCTI() {
	var strKeyValues = "";
	var strCTIColumn;
	var strVal;
	var strRef;
	var varAMP = "";

	if (getCTIObject().callState == CTI_CALLSTATUS_ANSWERED) {
		return eMsgBox(fl("CTICALLACTIVE"), 0, msg_Critical, window);
	}
			
	for (var intCtr=0, intLen = this.ctiInputs.length; intCtr < intLen; intCtr++) {
		
		strCTIColumn = this.ctiInputs[intCtr].strCTIColumn;
			
		if (strCTIColumn != "fixednumber" && strCTIColumn != "traderid" && strCTIColumn != "tradertype" && 
			strCTIColumn != "contactid" && strCTIColumn != "type" && strCTIColumn != "ismobile") {
			return this.objForm.objWindow.alert(fl("CTITYPEERROR", strCTIColumn));
		}
		else {
			strRef = this.ctiInputs[intCtr].strRef;
			strVal = this.objForm.getFieldByRef(strRef).getValue();
			strKeyValues +=  varAMP + strCTIColumn + "=" + replaceForURL(b64Encode(strVal));
		}
		
		varAMP = "&";
	}

	var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Applications_HTML/appCallMan.html?" + strKeyValues;
	if (!isBlank(objApplication.appID))	{
		strURL += "&appid=" + objApplication.appID;
		strURL += "&menuid=" + objApplication.menuID;
	}
	
	objApplication.openChildWindow(getTopWindow(), strURL);
	
}

function FormField_fireMap()
{
	var strKeyValues = "", strValue = "", strMapColumnName = "";
	var objInputField;

	// 0 = addressid
	objInputField = this.objForm.getFieldByRef(this.mapInputs[0].strRef);
	var strAddressID = objInputField.getValue();
	
	var strTraderID, strTraderType, strTraderName, strValue;
			
	for (var intCtr=1, intLen = this.mapInputs.length; intCtr < intLen; intCtr++) {
		strMapColumnName = this.mapInputs[intCtr].strMapColumnName;
		
		if (strMapColumnName == "tradertype") {
			strKeyValues +=  "&tradertype=" + this.mapInputs[intCtr].strRef;
			strTraderType = this.mapInputs[intCtr].strRef;
			continue;
		}
		
		objInputField = this.objForm.getFieldByRef(this.mapInputs[intCtr].strRef);
		strValue = objInputField.getValue();
		
		if (strMapColumnName == "traderid") {
			strTraderID = strValue;
			strKeyValues +=  "&traderid=" + strTraderID;
		}
		else if (strMapColumnName == "tradername")
			strKeyValues +=  "&tradername=" + strValue;
		else {
			if (strMapColumnName == "postcode" && strValue.length == 0) {
				// No postcode passed. Lets try and get the postcode from the database for
				// the trader/addressid.
				// NOTE: traderid & tradertype must be known by this stage for RPC call
				
				var objRPCObject, strPostCode;
				
				if (strTraderType.length == 0)
					return this.objForm.objWindow.alert(fl("MAPINPUTPARAMATERTYPE"));
				
				if (strTraderID.length == 0)
					return this.objForm.objWindow.alert(fl("MAPINPUTPARAMATERID"));
				
				if (strTraderType == "C")
					objRPCObject = new RPCObject("CustomerAddress");
				else
					objRPCObject = new RPCObject("SupplierAddress");
				
				objRPCObject.execute("load", objApplication.Connection.strConnectionString, strTraderID, strAddressID);
				
				if (objRPCObject.isEmpty())
					return this.objForm.objWindow.alert(fl("MAPPOSTCODEFORADDRESS"));

				// OK, we have a record. Now check that the postcode is not blank
				var objXML = objRPCObject.getReturnedXMLDom();
				
				if (strTraderType == "C") {
					strPostCode = objXML.selectSingleNode("/customeraddresses/customeraddress/postcode/value").getText();
					if (strPostCode.length == 0)
						return this.objForm.objWindow.alert(fl("MAPPOSTCODEFORADDRESS"));
						
					strKeyValues = "postcode=" + strPostCode;
					strKeyValues += "&street=" + objXML.selectSingleNode("/customeraddresses/customeraddress/street/value").getText();
					strKeyValues += "&city=" + objXML.selectSingleNode("/customeraddresses/customeraddress/city/value").getText();
					strKeyValues += "&county=" + objXML.selectSingleNode("/customeraddresses/customeraddress/county/value").getText();
					strKeyValues += "&countryid=" + objXML.selectSingleNode("/customeraddresses/customeraddress/countryid/value").getText();
				}
				else {
					strPostCode = objXML.selectSingleNode("/supplieraddresses/supplieraddress/postcode/value").getText();
					if (strPostCode.length == 0) 
						return this.objForm.objWindow.alert(fl("MAPPOSTCODEFORADDRESS"));

					strKeyValues = "postcode=" + strPostCode;
					strKeyValues += "&street=" + objXML.selectSingleNode("/supplieraddresses/supplieraddress/street/value").getText();
					strKeyValues += "&city=" + objXML.selectSingleNode("/supplieraddresses/supplieraddress/city/value").getText();
					strKeyValues += "&county=" + objXML.selectSingleNode("/supplieraddresses/supplieraddress/county/value").getText();
					strKeyValues += "&countryid=" + objXML.selectSingleNode("/supplieraddresses/supplieraddress/countryid/value").getText();
				}
				
				// OK, we have a valid(?) postcode on the database, now get the trader name
				if (strTraderType == "C")
					objRPCObject = new RPCObject("Customer");
				else 
					objRPCObject = new RPCObject("Supplier");
				
				objRPCObject.execute("load", objApplication.Connection.strConnectionString, strTraderID);
				
				if (objRPCObject.isEmpty()) // Should never occur
					return this.objForm.objWindow.alert(fl("Load map: Cannot find trader"));
				
				objXML = objRPCObject.getReturnedXMLDom();

				if (strTraderType == "C")
					strKeyValues += "&tradername=" + objXML.selectSingleNode("/customers/customer/name/value").getText();
				else
					strKeyValues += "&tradername=" + objXML.selectSingleNode("/suppliers/supplier/name/value").getText();
				
				break;
			}
			strKeyValues +=  "&" + strMapColumnName + "=" + strValue;
		}
	}

	var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Applications_HTML/appMap.html?" + strKeyValues;
	if (!isBlank(objApplication.appID))
	{
		strURL += "&appid=" + objApplication.appID;
		strURL += "&menuid=" + objApplication.menuID;
	}
	
	objApplication.openChildWindow(this.objForm.objWindow, strURL);
}

/**
 * Formats the field value according to datatype.
 *
 * @param strCurrentXMLValue Contains the current field value. 
 *        If not passed then fetch current XML value manually.
 */
function FormField_processFormat(strCurrentXMLValue)
{
	var objHTMLElement = this.getHTMLElement();
	
	if (objHTMLElement.tagName == "TEXTAREA")	// Cannot format a textarea control...
		return;

	if (strCurrentXMLValue == null)
		strCurrentXMLValue = this.getCurrentXMLValue();

	if (strCurrentXMLValue == null)
		strCurrentXMLValue = objHTMLElement.value;

    if (objHTMLElement.isTimeFormat == "true")
    {
        if (strCurrentXMLValue.length == 4)
        {
            var intHours = Number(strCurrentXMLValue.substring(0, 2));
            var intMinutes = Number(strCurrentXMLValue.substring(2));

            if (! isNaN(intHours) && ! isNaN(intMinutes) && intHours >= 0 && intHours <= 23 && intMinutes >= 0 && intMinutes <= 59)
            {
                strCurrentXMLValue = strHours + ":" + strMinutes;

                objHTMLElement.value = strCurrentXMLValue;
            }
        }
    }

	// For all date types, the displayed date should be in locale format.
	if (this.strDataType == "xsd:dateTime")
	{
		if (this.overwriteValidate != null && 
			this.overwriteProcessFormat != null) {
			
		var evalFunction = new Function("objForm", "strCurrentXMLValue", "objThisObj", "return objForm.objWindow." + this.overwriteProcessFormat + "(strCurrentXMLValue, objThisObj);");
		var strData = evalFunction(this.objForm, strCurrentXMLValue, this);
			
			if (strData != "")
				objHTMLElement.value = strData;
		}
		else {

			if (strCurrentXMLValue != "")
			{
				var strDate
				try {
					strDate=this.interpretDate(strCurrentXMLValue);
				} catch (error) {
					// exit if the date wasnt parseable
					return;
				}	

				// is the field date only ?		
				if (objHTMLElement.isDateFormat == "true")
				{
					var objDateParser=objApplication.getDateParser();
					
					var objDate = objDateParser.parse(strDate);
					// if the datetime can be parsed correctly, ask for the date only. 
					if (objDate != null)
						objHTMLElement.value = objDateParser.formatLocaleDate(objDate);
					else
						objHTMLElement.value = strDate;
				}
				else
					objHTMLElement.value = strDate;
			}
		}
	}
	else {
		if (this.overwriteValidate != null) {
			return;
		}

		else if (objHTMLElement.proPoint != null && !isBlank(strCurrentXMLValue))
		{
			if (! isNaN(strCurrentXMLValue * strCurrentXMLValue))
			{
				var strSymbol = null;
				var strUOMCurrency = null;
				var iDisplayDP = null;

				if (objHTMLElement.currencyFormatLookup != null)
				{
					var strCurrencyId = String(this.objForm.getFieldByRef(objHTMLElement.currencyFormatLookup).getValue());
					
					if (!isBlank(strCurrencyId))
					{
						var objCurrencyNode = objApplication.Data.getRootNode().selectSingleNode("cached-currencies/currency[currid/value = '" + strCurrencyId + "']");
						
						if (objCurrencyNode == null)
						{
							var objRPCObject = new RPCObject("Currency");
							objRPCObject.execute("load", objApplication.Connection.strConnectionString, strCurrencyId);
							
							if (!objRPCObject.isEmpty())
							{
								var objXML = objRPCObject.getReturnedXMLDom();
								objCurrencyNode = objXML.selectSingleNode("/currencies/currency");
								
								if (objApplication.Data.getRootNode().selectSingleNode("cached-currencies") == null)
								{
									var objCacheNode = objApplication.Data.DOM.createElement("cached-currencies");
									objApplication.Data.getRootNode().appendChild(objCacheNode);
								}
								objApplication.Data.getRootNode().selectSingleNode("cached-currencies").appendChild(objCurrencyNode);

								strSymbol = objCurrencyNode.selectSingleNode("symbol/value").getText();
								strUOMCurrency = strCurrencyId;
							}
							else
							{
								strUOMCurrency = "";
								strSymbol = "";
							}
						}
						else
						{
							strUOMCurrency = strCurrencyId;
							strSymbol = objCurrencyNode.selectSingleNode("symbol/value").getText();
							
							if (objHTMLElement.isUnitPrice)
								iDisplayDP = objCurrencyNode.selectSingleNode("currunitvaldp/value").getText();
							else
								iDisplayDP = objCurrencyNode.selectSingleNode("currvaldp/value").getText();
							
						}
					}
					else
					{
						strUOMCurrency = "";
						strSymbol = "";
					}
				}

				var strValue = objApplication.getNumberFormatter().getLocaleNumber(strCurrentXMLValue, objHTMLElement.proPoint);

				if (objHTMLElement.isPriceFormat == "true")
				{
					if (strUOMCurrency == null)
						strUOMCurrency = objApplication.User.homeCurrency;

					this.setUOMValue(strUOMCurrency);

					if (strSymbol == null)
						strSymbol = objApplication.User.getHomeCurrencySymbol();
					
					if (strSymbol != "" && !isBlank(strValue) && !isNaN(objHTMLElement.unformattedHTMLValue))
						objHTMLElement.value = strSymbol + " " + strValue;
					else
						objHTMLElement.value = strValue;
					
					if (!isBlank(iDisplayDP))
						objHTMLElement.proPoint = iDisplayDP;
						
				}
				else
					objHTMLElement.value = strValue;
			}
			else
				objHTMLElement.value = strCurrentXMLValue;
		}
		else if (isBlank(strCurrentXMLValue))
		{
			objHTMLElement.value = strCurrentXMLValue;
		}
		else if (this.strDataType == "xsd:float" ||
				this.strDataType == "xsd:double" ||
				this.strDataType == "xsd:decimal")
		{
			if (! isNaN(strCurrentXMLValue * strCurrentXMLValue))
				objHTMLElement.value = util_localeNumber(strCurrentXMLValue, null);
			else
				objHTMLElement.value = strCurrentXMLValue;
		}
		else if (this.strDataType == "xsd:integer" ||
				this.strDataType == "xsd:short" ||
				this.strDataType == "xsd:smallint")
		{
			if (objHTMLElement.isSerialFormat != "true" && ! isNaN(strCurrentXMLValue * strCurrentXMLValue)) {
				// the content has not yet been validated. Ensure its an integer before we format it or "1.23" would become "1"
				if (isInteger(strCurrentXMLValue)) {
					objHTMLElement.value = formatInteger(strCurrentXMLValue);
				} else {
					objHTMLElement.value = strCurrentXMLValue;
				}
			}
			else
				objHTMLElement.value = strCurrentXMLValue;
		}
	}
}

/**
 * Formats the field value according to datatype of the input
 *
 * @param objDate contains a long number, an ISO string, a locale date String or a java Date object.
 * @return strDate  a string containing the locale formatted date
 *  
 * @throws parseException if unknown type or unparseable.
 */
function FormField_interpretDate(objCurrentXMLValue) {
	var objDateParser=objApplication.getDateParser();

	// is it a java Date object? 
	if (typeof (objCurrentXMLValue)=="object") {
		var strClassName=objCurrentXMLValue.getClass().getName();
		if (strClassName == "java.util.Date") {
			return (objDateParser.formatLocaleDateTime(objCurrentXMLValue));			
		}
	} 
	
	// is it a millisecond time?
	if (!isNaN (Number (objCurrentXMLValue))) {
		var objDate=objDateParser.parseMillis (Number (objCurrentXMLValue));
		return objDateParser.formatLocaleDateTime(objDate);
	}

	// is it an ISO string ?
	if (isISODate(objCurrentXMLValue) == true) {
		var objDate=objDateParser.convertFromISOFormat(objCurrentXMLValue);
		return objDateParser.formatLocaleDateTime(objDate);
	} 

	// is it in locale format ?
	var objDate=objDateParser.parse (objCurrentXMLValue);
	// already in localeFormat or one of the other shorter forms.
	return objDateParser.formatLocaleDateTime(objDate);
}

function FormField_setInvalid()
{
	var objHTMLElement = this.getHTMLElement();
	
	if (objHTMLElement.type == "checkbox" || objHTMLElement.type == "radio")
	{
		objHTMLElement.className = "InvalidCheckRadio";
	}
	else
	{
		objHTMLElement.className = "InvalidTextBox";
	}
	this.isInvalid = true;
	this.disableInfoPanel();
	this.disableMap();
	this.disableCTI();
	this.clearLookup();
}

function FormField_setValid()
{
	var objHTMLElement = this.getHTMLElement();
	
	if (this.isInvalid == false && this.isRequiredField() == false && !(objHTMLElement.schemaField == "true" && this.getMinLength() > 0))
	{
		this.setInfoPanelVisibility();
		this.setMapVisibility();
		this.setCTIVisibility();
		return;
	}

	if (objHTMLElement.blnIsDisabled == "true")
	{
		if (objHTMLElement.type == "checkbox" || objHTMLElement.type == "radio")
		{
			objHTMLElement.className = "CheckRadio";
		}
		else
		{
			objHTMLElement.className = "ReadBox";
		}
	}
	else
	{
		if (objHTMLElement.type == "checkbox" || objHTMLElement.type == "radio")
		{
			objHTMLElement.className = "CheckRadio";
		}
		else
		{			
			if (objHTMLElement.value == "" &&
				(this.isRequiredField() || (objHTMLElement.schemaField == "true" && this.getMinLength() > 0 && this.objForm.editMode != "filter")))
			{
				objHTMLElement.className = "EfacsFieldRequired";
			}
			else
				objHTMLElement.className = "TextBox";
		}
	}
	this.isInvalid = false;
	this.setInfoPanelVisibility();
	this.setMapVisibility();
	this.setCTIVisibility();
}

function FormField_setInfoPanelVisibility()
{
	var objHTMLElement = this.HTMLElement;
	
	if (objHTMLElement == null)
		objHTMLElement = this.getHTMLElement();

	if ((objHTMLElement.hasForeignKey != "true" && objHTMLElement.isprimary == "true" && 
		 objHTMLElement.schemaField == "true" && this.objForm.editMode == "add") ||
		objHTMLElement.strInfoPanelName == null || this.permanentInfoDisable == true || objHTMLElement.value == "")
	{
		this.disableInfoPanel();
	}
	else
 		this.enableInfoPanel();
}

function FormField_setMapVisibility()
{
	if (isBlank(this.getValue()))
		this.disableMap();
	else
 		this.enableMap();
}

/**
 *
 */
function FormField_setCTIVisibility() {
	if (isBlank(this.getValue()) || this.isInteractivelyDirty == true || this.objForm.editMode == "add")
		this.disableCTI();
	else
 		this.enableCTI();
}

/**
 * Validates a form field according to datatype
 * and any external validation (such as lookups etc).
 * @param flgFromOnchangeEvent true if this call to validate comes from the 
 * user changing the field, false if it comes from a database population 
 * of the field. 
 * @param flgWithoutLookups True if lookups are NOT to be performed.
 * @param flgWithoutLookupDependencyCheck True if lookup dependents are NOT to be checked.
 * @return True if field validates ok, false if not.
 */
function FormField_validate(flgFromOnchangeEvent, flgWithoutLookups, flgWithoutLookupDependencyCheck)
{
	var objForm = this.objForm;

	if (this.HTMLElement == null)
		this.getHTMLElement();
	
	var objHTMLElement = this.HTMLElement;
	
	// If do not have a data-type, cannot validate...
	if (this.strDataType == null || this.strDataType == "")
		return true;

	// If the value is the same as the last time it was validated then
	// no need to do the validate again.
	if (flgFromOnchangeEvent != true &&
		objHTMLElement.lastValidatedValue != null &&
		objHTMLElement.lastValidatedValue == objHTMLElement.unformattedHTMLValue &&
		this.isInvalid == false)
	{
		return true;
	}

	// This section is for Query by example - keep before base validation
	// Call any external validate functions declared in the app for this field.
	if (this.overwriteValidate && !(this.selectOne != null && this.selectOne.listValueOnly == true))
	{
		var evalFunction = new Function("objForm", "objThisObj", "return objForm.objWindow." + this.overwriteValidate + "(objThisObj);");
		var flgValid = evalFunction(this.objForm, this);

		if (flgValid == false) {
			this.error("INVALIDVALUE");
			return false;
		}
		
		this.setValid();
		
		if (flgFromOnchangeEvent)
			objForm.objWindow.objStatusBar.clear();

		return true;
	}

	if (objHTMLElement.blnIsDisabled != "true" && this.objForm.editMode != "filter" && this.doSystemValidation(flgFromOnchangeEvent, flgWithoutLookups) == false)
		return false;

	// only perform validation routine from the calling app if the content has been verified as valid above. 
    if (this.performADAPTScript(this.getValue(), ADAPT_VALIDATE) == null)
        return false;

	// Process any lookups.
	if (flgWithoutLookups != true)
	{
		if (this.processLookups() == false)
			return false;

		if (flgFromOnchangeEvent)
			objForm.objWindow.objStatusBar.clear();
		
		// Check any other fields dependent on this field are still valid.
		if (flgWithoutLookupDependencyCheck != true && !isBlank(this.getValue()))
		{
			for (var i = 0, intLen = this.arrLookupDependents.length; i < intLen; i++)
			{
				var objRefField = objForm.getFieldByRef(this.arrLookupDependents[i]);
				if (!isBlank(objRefField.getValue()) && objRefField.validate(flgFromOnchangeEvent, flgWithoutLookups, true) == false)
					break;
			}
		}
	}

	// Call any external validate functions declared in the app for this field.
	if (this.externalValidate)
	{
		var evalFunction = new Function("objForm", "objThisObj", "flgFromOnchangeEvent", "return objForm.objWindow." + this.externalValidate + "(objThisObj, flgFromOnchangeEvent);");
		var flgValid = evalFunction(this.objForm, this, flgFromOnchangeEvent);
		if (flgValid == false)
			return false;
	}

	objHTMLElement.lastValidatedValue = objHTMLElement.unformattedHTMLValue;

	// Everything okay, so data must be valid...
	this.setValid();
	return true;
}

/**
 * Validates datatypes, max min values and other basic system level validation.
 * @param flgFromOnchangeEvent true if this call to validate comes from the 
 *		  user changing the field, false if it comes from a database population 
 * @param flgWithoutLookups true if lookups are NOT to be performed.
 * @return True if field validates ok, false if not.
 */
function FormField_doSystemValidation(flgFromOnchangeEvent, flgWithoutLookups)
{
	var strCurrentValue;
	var objForm = this.objForm;
	var objHTMLElement = this.HTMLElement;

	if (this.strDataType == "xsd:float" ||
		this.strDataType == "xsd:double" ||
		this.strDataType == "xsd:integer" ||
		this.strDataType == "xsd:short" ||
		this.strDataType == "xsd:smallint" ||
		this.strDataType == "xsd:decimal")
	{
		strCurrentValue = this.getCurrentXMLValue();
		if (strCurrentValue == null)
			strCurrentValue = objHTMLElement.unformattedHTMLValue;
		if (strCurrentValue == null)
			strCurrentValue = objHTMLElement.value;

		if (this.getMinValue() != null && Number(strCurrentValue) < this.getMinValue())
		{
			this.error(fl("VALUEBELOWMIN", this.getMinValue()));
			return false;
		}
		if (this.getMaxValue() != null && Number(strCurrentValue) > this.getMaxValue())
		{
			this.error(fl("VALUEABOVEMAX", this.getMaxValue()));
			return false;
		}
	}
	else if (this.strDataType == "xsd:dateTime")
	{
		strCurrentValue = this.getCurrentXMLValue();
		if (strCurrentValue == null)
			strCurrentValue = objHTMLElement.unformattedHTMLValue;
		if (strCurrentValue == null)
			strCurrentValue = objHTMLElement.value;

		if (!isBlank(strCurrentValue)) {
			var objDateParser=objApplication.getDateParser();
			var objCurrentValue;
			// the date that comes here may be an ISO or locale format/
			if (isISODate(strCurrentValue)==true) 
				objCurrentValue=objDateParser.convertFromISOFormat(strCurrentValue);
			else {
				try {
					objCurrentValue=objDateParser.parse (strCurrentValue);
				} catch (objError) {
			        this.error("INVALIDDATEVALUE");	
			        return false;
				}
			}
			if (objCurrentValue==null) {
		        this.error("INVALIDDATEVALUE");	
		        return false;
			}
			
			var objMinValue=this.getMinValue();
			var objMaxValue=this.getMaxValue();
			if (objMinValue != null && objCurrentValue.getTime() < objMinValue.getTime())
			{
				this.error(fl("VALUEBELOWMIN", objApplication.getCalendarParser().formatLocaleDateTime (objMinValue)));
				return false;
			}
			if (objMaxValue != null && objCurrentValue.getTime() > objMaxValue.getTime())
			{
				this.error(fl("VALUEABOVEMAX", objApplication.getCalendarParser().formatLocaleDateTime (objMaxValue)));
				return false;
			}
		}
	}
	else
		strCurrentValue = this.getValue();

	if (isBlank(strCurrentValue) && (this.isRequiredField() || (objForm.editMode != "filter" && objHTMLElement.schemaField == "true" && this.getMinLength() > 0)))
	{
		this.error("FIELDREQUIRESVALUE");
		return false;
	}

    if (objHTMLElement.isTimeFormat == "true")
    {
        var validTime = true;

        if (strCurrentValue.length == 5)
        {
            var intHours = Number(strCurrentValue.substring(0, 2));
            var intMinutes = Number(strCurrentValue.substring(3));

            if (strCurrentValue.substring(2, 3) != ":")
                validTime = false;
            else
            if (isNaN(intHours) || isNaN(intMinutes))
                validTime = false;
            else
            if (intHours < 0 || intHours > 23 || intMinutes < 0 || intMinutes > 59)
                validTime = false;
        }
        else
            validTime = false;

        if (! validTime)
        {
            this.error("INVALIDTIMEVALUE");

            return false;
        }
    }
		
	if (this.strDataType == "xsd:integer" || this.strDataType == "xsd:short" || this.strDataType == "xsd:smallint") {
		if (!isBlank(strCurrentValue) && (isNaN(strCurrentValue * strCurrentValue) || !isInteger(strCurrentValue))) {
			this.error("INVALIDNUMERICVALUE");
			return false;
		} 
	} 
	else if (this.strDataType == "xsd:float" || this.strDataType == "xsd:decimal" || this.strDataType == "xsd:double") 
	{
		if (!isBlank(strCurrentValue) && isNaN(strCurrentValue * strCurrentValue)) {
			this.error("INVALIDFLOATVALUE");
			return false;
		}
	}
	else if (this.strDataType == "xsd:dateTime" && !isBlank(strCurrentValue)) 
	{
		if (! isISODate(strCurrentValue)) {
			// Not an ISO date - is it still valid though ?
			// REVIEW
			var tmpDate = new Date(strCurrentValue);
			if (isNaN(tmpDate))
			{
				var objDate = null;
				try {
					objDate = objApplication.getDateParser().parse(strCurrentValue);
				} catch(error) {
				}
				
				if (objDate == null)
				{
					this.error("INVALIDDATEVALUE");
					return false;
				}
			}
		}
	}

	if (this.selectOne != null && this.selectOne.listValueOnly == true && (objForm.editMode != "filter" || this.isRequiredField() == true))
	{
		var flgFound = false;
		var objSelectOne = this.selectOne;
		for (var intCtr = 0, intLen = objSelectOne.Captions.length; intCtr < intLen; intCtr ++)
		{
			var strCompareString = objSelectOne.Values[intCtr];

			if ((strCompareString == String(strCurrentValue)) ||
				isBlank(strCompareString) && isBlank(strCurrentValue)) {
				flgFound = true;
				break;
			}
		}
		if (flgFound == false)
		{
			this.error("MUSTSELECTVALUEFROMLIST");
			return false;
		}			
	}
	
	// Validate primary key in add mode.	
	if (flgFromOnchangeEvent == true && 
		objHTMLElement.isprimary == "true" && 
		objForm.editMode == "add" && 
		objForm.schemaName != null &&
		objForm.flgPreparedDataChanges == false &&
		objForm.strCustomEntityName == null)
	{
		if (this.validatePrimaryKey() == false)
			return false;
	}

	return true;
}

function FormField_clearLookup() 
{
	if (this.lookup == null)
		return;

	for (var j = 0, intLen = this.lookup.fields.length; j < intLen; j++)
	{
		var strRef = this.lookup.fields[j].strFieldRef;
		if (this.strRef != strRef)
		{
			var objField = this.objForm.getFieldByRef(strRef);
			if (objField.getValue() != "")
				objField.setValue("", FORMFIELD_WITHOUTRECALLSAVE | FORMFIELD_WITHOUTVALIDATION);

			objField.disableInfoPanel();
			objField.disableMap();
			objField.disableCTI();
		}
	}
}

// Constructor for FormFieldLookup Object.
function FormFieldLookup(blnIsRequired) {
	this.intFields = 0;
	this.strInvalidMessage=null;
	this.isRequired = blnIsRequired;
	this.fields = new Array();
	this.DataEngine = null;

	this.addLookupOutput = FormFieldLookup_addLookupOutput;
	this.destroy = FormFieldLookup_destroy;
}

function FormFieldLookup_addLookupOutput(p_strFieldRef, p_strPropertyName) {
	this.fields[this.intFields++] = new FormFieldLookupRef(p_strFieldRef, p_strPropertyName);
}

/**
 * Clear references to the lookup objects
 */
function FormFieldLookup_destroy() {

	try {
		this.strInvalidMessage = null;
		if (this.DataEngine != null) {
			this.DataEngine.destroy();
			this.DataEngine = null;
		}
		for (var i = 0, len = this.fields.length; i < len; i++) {
			this.fields[i] = null;
		}
		this.fields = new Array();
	} catch (error) {
	}
}

function FormFieldLookupRef(p_strFieldRef, p_strPropertyName) {
	this.strFieldRef = p_strFieldRef;
	this.strPropertyName = p_strPropertyName;
	this.destroy = FormFieldLookupRef_destroy;
}

/**
 * Clear references to the lookup ref object
 */
function FormFieldLookupRef_destroy() {
	try {
		this.strFieldRef = null;
		this.strPropertyName = null;
	} catch (error) {
	}
}

// Constructor for QueryInputItem Object.
function QueryInputItem(strRef, strQueryColumnName, strValue) {
	this.strRef = strRef;
	this.strQueryColumnName = strQueryColumnName;
	this.strValue = strValue;
	this.destroy = QueryInputItem_destroy;
}

/**
 * Clear references to the Query Input objects
 */
function QueryInputItem_destroy() {
	try {
		this.strRef = null;
		this.strQueryColumnName = null;
		this.strValue = null;
	} catch (error) {
	}
}

// Constructor for QueryResultItem Object.
function QueryResultItem(strRef, strQueryColumnName) {
	this.strRef = strRef;
	this.strQueryColumnName = strQueryColumnName;
	this.destroy = QueryResultItem_destroy;
}

/**
 * Clear references to the Query Result Item object
 */
function QueryResultItem_destroy() {
	try {
		this.strRef = null;
		this.strQueryColumnName = null;
	} catch (error) {
	}
}

// Constructor for UOMLookupItem Object.
function UOMLookupItem(strRef, strLookupType) {
	this.strRef = strRef;
	this.strLookupType = strLookupType;
	this.destroy = UOMLookupItem_destroy;
}

/**
 * Clear references to the UOMLookup item objects
 */
function UOMLookupItem_destroy() {
	try {
		this.strRef = null;
		this.strLookupType = null;
	} catch (error) {
	}
}

// Constructor for InfoPanelInputItem Object.
function InfoPanelInputItem(strRef)
{
	this.strRef = strRef;
	this.destroy = InfoPanelInputItem_destroy;
}

/**
 * Clear references to the infor panel input object
 */
function InfoPanelInputItem_destroy() {
	try {
		this.strRef = null;
	} catch (error) {
	}
}

// Constructor for MapInputItem Object.
function MapInputItem(strRef, strMapColumnName)
{
	this.strRef = strRef;
	this.strMapColumnName = strMapColumnName;
	this.destroy = MapInputItem_destroy;
}

/**
 * Clear references to the Map input objects
 */
function MapInputItem_destroy() {
	try {
		this.strRef = null;
		this.strMapColumnName = null;
	} catch (error) {
	}
}

// Constructor for CTIInputItem Object.
function CTIInputItem(strRef, strCTIColumn)
{
	this.strRef = strRef;
	this.strCTIColumn = strCTIColumn;
}

/**
 * Clear references to the CTI input objects
 */
function CTIInputItem_destroy() {
	try {
		this.strRef = null;
		this.strCTIColumn = null;
	} catch (error) {
	}
}

// Constructor for LookupInputItem Object.
function LookupInputItem(strRef, strQueryColumnName) {
	this.strRef = strRef;
	this.strQueryColumnName = strQueryColumnName;
	this.destroy = LookupInputItem_destroy;
}

/**
 * Clear references to the Lookup input item objects
 */
function LookupInputItem_destroy() {
	try {
		this.strRef = null;
		this.strQueryColumnName = null;
	} catch (error) {
	}
}

function FormField_recall()
{
	if (this.objForm.objWindow.objStatusBar != null)
		this.objForm.objWindow.objStatusBar.clear();

	var strValue = objApplication.FieldHistory.getClassValue(this.HTMLElement.strClass, this.intRecallItem);

	if (strValue == null) {
		// Failed, may have exceeded list, so change to first and re-attempt fetch.
		this.intRecallItem = 0;
		strValue = objApplication.FieldHistory.getClassValue(this.HTMLElement.strClass, this.intRecallItem);
		if (strValue == null)
			return;
	}

	this.setValueWithEvents(strValue, FORMFIELD_WITHOUTRECALLSAVE);
		
	if (++this.intRecallItem == 5)
		this.intRecallItem = 0;
}

function FormField_writeRecall(strValue) {
	if (isBlank(strValue))
		return;
		
	if (this.HTMLElement.strClass != null) {
		objApplication.FieldHistory.addClassValue(this.HTMLElement.strClass, strValue);
		this.intRecallItem = 0;
	}
}

function FormField_hide(bHideInLine) 
{
	var objHTMLElement = this.getHTMLElement();
	
	// Hide <TD> container - this will hide the <INPUT> field plus any other TD child tags such as infopanels, map icons etc.

	if (bHideInLine == true)
		getParentElement(objHTMLElement, "TD").style.visibility = "hidden";
	else
		getParentElement(objHTMLElement, "TD").style.display = "none";
	
	var objLabel = this.getLabel();
	if (objLabel != null)
	{
		if (bHideInLine == true)
			objLabel.style.visibility = "hidden";
		else
			objLabel.style.display = "none";
	}
}

/**
 * Gets a reference to the parent TD and sets as display inline.
 * If TR is hidden (by FormTranslator) - then display that too.
 * Also displays the label.
 */
function FormField_show() {
	var objTD = getParentElement(this.getHTMLElement(), "TD");
	var objTR = objTD.parentElement;
	objTR.style.display = "inline";
	objTD.style.display = "inline";
	objTR.style.visibility = "visible";
	objTD.style.visibility = "visible";

	var objLabel = this.getLabel();
	if (objLabel != null){
		objLabel.style.display = "inline";
		objLabel.style.visibility = "visible";
	}

	if (!this.HTMLElement.blnIsDisabled == "true")
		this.setValid();
}

function FormField_setDefaultXMLValue()
{
	this.setValue(this.getDefaultXMLValue());
}

/**
 * Internal function that sets the currency UOM values for all currency lookup
 * fields depending on this currency field.
 */
function FormField_setCurrencyDependentFields()
{
	for (var intCtr = 0, intLen = this.arrCurrencyDependentFields.length; intCtr < intLen; intCtr++)
		this.objForm.getFieldByRef(this.arrCurrencyDependentFields[intCtr]).processFormat();
}

/**
 * Determines whether a field is required.
 *
 * @return True if required - false if not.
 */
function FormField_isRequiredField()
{
	// Causes the form to initialise itself if not already done so.
	// Coded this way for performance.
	if (this.HTMLElement == null)
		this.getHTMLElement();

	return (this.HTMLElement.isRequired == "true");
}

/**
 * Sets whether a field is required.
 *
 * @param flgRequired True if required - false if not.
 */
function FormField_setRequiredField(flgRequired)
{
	// Causes the form to initialise itself if not already done so.
	// Coded this way for performance.
	if (this.HTMLElement == null)
		this.getHTMLElement();

	this.HTMLElement.isRequired = (flgRequired ? "true" : "false");

	if (this.HTMLElement.blnIsDisabled == "true")
		return;
		
    // If the field is now required then change the class to provide a visual
    // indication to the user that the field cannot be left blank.
	if (flgRequired && isBlank(this.getValue()))
        this.HTMLElement.className = "EfacsFieldRequired";
    else
    {
        if (! this.isInvalid)
            this.HTMLElement.className = "TextBox";
    }
}

/**
 * Returns minimum required length of the field.
 *
 * @return the minimum length.
 */
function FormField_getMinLength()
{
	if (this.HTMLElement.minLength == null)
		return 0;
	else
		return Number(this.HTMLElement.minLength);
}

/**
 * Returns maximum allowed length of the field.
 * max length less than zero means no maximum set.
 *
 * @return the maximum length.
 */
function FormField_getMaxLength()
{
	if (this.HTMLElement.maxLength == null)
		return -1;
	else
		return Number(this.HTMLElement.maxLength);
}

/**
 * Returns minimum allowed value of the field.
 * null indicates no min value set.
 *
 * @return the minimum value.
 */
function FormField_getMinValue()
{
	if (this.HTMLElement.minValue == null)
		return null;
	else
	{
		if (this.strDataType == "xsd:dateTime")
		{
			if (this.HTMLElement.minValue == "getdate()")
				return objApplication.getCalendarParser().getDateTime();
			else
				return objApplication.getCalendarParser().setDateTimeInISO(this.HTMLElement.minValue);
		}
		else
			return Number(this.HTMLElement.minValue);
	}
}

/**
 * Returns maximum allowed value of the field.
 * null indicates no max value set.
 *
 * @return the maximum value.
 */
function FormField_getMaxValue()
{
	if (this.HTMLElement.maxValue == null)
		return null;
	else
	{
		if (this.strDataType == "xsd:dateTime")
		{
			if (this.HTMLElement.maxValue == "getdate()")
				return objApplication.getCalendarParser().getDateTime();
			else
				return objApplication.getCalendarParser().setDateTimeInISO(this.HTMLElement.maxValue);
		}
		else
			return Number(this.HTMLElement.maxValue);
	}
}

/**
 * Attempts to set current focus on this field.
 * Need try catch as field may not be visible which would throw javascript error.
 */
function FormField_focus()
{
	try {
		this.getHTMLElement().focus();
	} catch (objError) {
	}
}

/**
 * Check for unique primary key already existing
 *
 * @return true if primary key is valid - false if not.
 */
function FormField_validatePrimaryKey()
{
	var arrKeys = new Array();
	for (var i = 0, intLen = this.objForm.fields.length; i < intLen; i++)
	{
		var objPrimField = this.objForm.fields[i];
		objHTMLElement = objPrimField.HTMLElement;
		if (objHTMLElement.isprimary == "true" && 
			objHTMLElement.schemaField == "true")
		{
			var strValue = objPrimField.getValue();
			if (isBlank(strValue)) {
				// Only check if the record already exists if we have all the primary key values.
				// Blank indicates that all the key values have not yet been set (cannot have empty strings in primary key fields)
				return true;
			}
				
			if (objPrimField.strDataType == "xsd:dateTime") {
				// Primary key date values need to be passed in ISO format.
				var objEfacsCalendar=objApplication.getCalendarParser();
				objEfacsCalendar.setDateTimeInLocaleFormat(strValue);
				if (objPrimField.HTMLElement.isDateFormat == "true")
					objEfacsCalendar.setTimeToStartOfDay();
				strValue = objEfacsCalendar.getDateTimeInISO();
			}
			
			arrKeys[Number(objHTMLElement.primarykeyno) - 1] = strValue;
		}
	}

	if (arrKeys.length == 0)
		return true;

	var objRPCObject = new RPCObject(this.objForm.schemaName);
	objRPCObject.handleRPCError = false;
	
	var strCommand = "objRPCObject.execute('Load', objApplication.Connection.strConnectionString";
	for (var i = 0, intLen = arrKeys.length; i < intLen; i++)
	{
		if (!isBlank(arrKeys[i]))
			strCommand += ", '" + arrKeys[i] + "'"
	}
	strCommand += ")";
	
	try {
		var evalFunction = new Function("objRPCObject", strCommand);
		evalFunction(objRPCObject);
	} catch (objError) {
	}

	if (objRPCObject.isEmpty() == false)
	{
		this.error("CANNOTINSERTDUPLICATERECORD");
		return false;
	}
	
	return true;
}

/**
 * Is the Form field visible
 * return boolean true if visible - otherwise false 
 */
function FormField_isVisible()
{
	// Get reference to field container cell.
	var objTD = this.getHTMLElement().parentNode;

	if (objTD.style.display == "none")
		return false;
	else
		return true;
}

/** Adds a new action and application to the field action list
 * @param label Action label
 * @param application Application to launch
 * @param mode parameter for the mode
 * @param image icon for the context menu
 */
function FormField_addAction(label, application, mode, image) {
	if (application == "appCallMan" && ! this.hasCTIModule())
		return;  // No CTI module
		
	var intNewCtr = this.arrFieldActions.length;
	this.arrFieldActions[intNewCtr] = new FieldAction(label, application, mode, image);
	return true;
}

/** Trigger an application associated with an action
 * @params Parameter Array - contains the application name to launch, action label and the FormField object the context menu belongs too
 */
function FormField_triggerAction(objContextMenuOption) {
	var topContextLabel = objContextMenuOption.topContextLabel;
	var objField = objContextMenuOption.params[1];
	var objAction = null;
	var intLen = objField.arrFieldActions.length;
	for (var i = 0; i < intLen; i++) {
		if (objField.arrFieldActions[i].strLabel == topContextLabel) {
			objAction = objField.arrFieldActions[i];
			break;
		}	
	}
	
	// ensure an action is picked
	if (objAction != null) {
		var appName = objAction.strAppName;

		var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Applications_HTML/" + appName + ".html?key0=" + replaceForURL(b64Encode(objField.getValue()));
		if (!isBlank(objApplication.appID))	{
			strURL += "&appid=" + objApplication.appID;
			strURL += "&menuid=" + objApplication.menuID;
		}

		if (appName == "appCallMan") {
			var traderID;
			var contactidID;
			
			var objTW = getTopWindow();
			if (objTW.objCTI.callState == CTI_CALLSTATUS_ANSWERED)
				return eMsgBox(fl("CTICALLACTIVE"), 0, msg_Critical, window);

			strURL += "&mode=CONTEXT";
			
			if (objContextMenuOption.cascadeLevel == 2) {
				traderID = objContextMenuOption.params[1].objForm.getFieldByRef("traderid").getValue()
				contactID = objContextMenuOption.params[1].getValue();
			}
			else {
				traderID = objContextMenuOption.params[1].getValue();
				contactID = objContextMenuOption.parentContextLabel;
			}
			var fixedNumber = objContextMenuOption.params[0];
			
			var traderType = this.CTIType == "CUSTOMERCONTACTNUMBERS" ? "C" : this.CTIType == "SUPPLIERCONTACTNUMBERS" ? "S" : "HQ";
			
			strURL += "&traderid=" + replaceForURL(b64Encode(traderID));
			strURL += "&tradertype=" + replaceForURL(b64Encode(traderType));
			strURL += "&contactid=" + replaceForURL(b64Encode(contactID));
			strURL += "&fixednumber=" + replaceForURL(b64Encode(fixedNumber));
			
			objApplication.openChildWindow(objTW, strURL);
		}
		else {
			strURL += "&mode=" + objAction.strMode;
			objApplication.openChildWindow(objField.objForm.objWindow, strURL);
		}
	}
}

/** FieldAction object constructor
 * @param strLabel Action label
 * @param strAppName Application name
 * @param strMode Mode Additional information for this call
 * @param strImage Context menu icon
 */
function FieldAction(strLabel, strAppName, strMode, strImage) {
	this.strLabel = strLabel;
	this.strAppName = strAppName;
	this.strMode = strMode;
	this.strImage = strImage;
	this.destroy = FieldAction_destroy;
}

/**
 * Clear references to the fieldAction object
 */
function FieldAction_destroy() {
	try {
		this.strLabel = null;
		this.strAppName = null;
		this.strMode = null;
		this.strImage = null;
	} catch (error) {
	}
}

/** 
 * Clear references to the form field objects
 */
function FormField_destroy() {
	try {
		if (this.lookup != null) {
			this.lookup.destroy();
			this.lookup = null;
		}
	
		if (this.queryInputs != null) {
			for (var i = 0, len = this.queryInputs.length; i < len; i++) {
				this.queryInputs[i].destroy();
				this.queryInputs[i] = null;
			}
			this.queryInputs = null;
		}
		if (this.queryResults != null) {
			for (var i = 0, len = this.queryResults.length; i < len; i++) {
				this.queryResults[i].destroy();
				this.queryResults[i] = null;
			}
			this.queryResults = null;
		}
		if (this.lookupInputs != null) {
			for (var i = 0, len = this.lookupInputs.length; i < len; i++) {
				this.lookupInputs[i].destroy();
				this.lookupInputs[i] = null;
			}
			this.lookupInputs = null;
		}
		this.strQueryResultsXML = null;
		if (!isBlank(this.formOnChange)) {
			this.objForm.objWindow[this.formOnChange] = null;
		}
		this.formOnChange = null;
	
		try {
			this.objForm.objWindow[this.strRef + "_onBeforeChange"] = null;
			this.objForm.objWindow[this.strRef + "_onAfterChange"] = null;
			this.objForm.objWindow[this.strRef + "_onAfterKeypress"] = null;
			this.objForm.objWindow[this.strRef + "_validate"] = null;
		} catch(objError) {
		}
	
		this.onFocus = null;
		this.onBlur = null;
		
		if (this.arrCurrencyDependentFields != null) {
			for (var i = 0, len = this.arrCurrencyDependentFields.length; i < len; i++) {
				this.arrCurrencyDependentFields[i] = null;
			}
			this.arrCurrencyDependentFields = null;
		}
		
		if (this.arrLookupDependents != null) {
			for (var i = 0, len = this.arrLookupDependents.length; i < len; i++) {
				this.arrLookupDependents[i] = null;
			}
			this.arrLookupDependents = null;
		}
					
		// Combo box.
		if (this.selectOne != null) {
			this.selectOne.destroy();
			this.selectOne = null;
		}
	
		if (this.DataEngine != null) {
			this.DataEngine.destroy();
			this.DataEngine = null;
		}
	
		if (this.HTMLElement != null) {

			var objLabelElement = this.getLabel();
			if (objLabelElement != null) {
				objLabelElement.title = "";
				objLabelElement.className = "";
				removeEvent(objLabelElement, "onclick", this.objForm.objFrameWindow.fireQuery);
			}
			objLabelElement = null;

			for (var objElement = this.HTMLElement.nextSibling; objElement != null; objElement = objElement.nextSibling) {
				if (objElement.tagName == "BUTTON") {
					if (objElement.className == "InfoPanelButton") {
						objElement.style.display = "";
						objElement.style.backgroundImage = "";
						removeEvent(objElement, "onclick", this.objForm.objWindow.fireInfoPanel);
						objElement.className = "";
						objElement = null;
						break;
					}
					if (objElement.className == "MapButton") {
						objElement.style.display = "";
						objElement.style.backgroundImage = "";
						removeEvent(objElement, "onclick", this.objForm.objWindow.fireMap);
						objElement.className = "";
						objElement = null;
						break;
					}
					if (objElement.className == "AddressLookupButton") {
						objElement.style.display = "";
						objElement.style.backgroundImage = "";
						removeEvent(objElement, "onclick", this.objForm.objWindow.fireAddressLookup);
						objElement.className = "";
						objElement = null;
						break;
					}
				}
			}

			this.HTMLElement.onchange = null;
				
			this.HTMLElement.disabled = false;
			this.HTMLElement.readonly = null;
			this.HTMLElement.strClass = null;
			this.HTMLElement.id = "";
			this.HTMLElement.name = "";
			this.HTMLElement.unformattedHTMLValue = null;
			this.HTMLElement.value = "";
			this.HTMLElement.removeAttribute("value");
			this.HTMLElement.checked = false;
			this.HTMLElement.defaultValue = "";
			this.HTMLElement.className = "";
			this.HTMLElement.onclick = null
			this.HTMLElement.onfocus = null;
			this.HTMLElement.onblur = null;
			this.HTMLElement.onkeydown = null;
			this.HTMLElement.onkeyup = null;
			this.HTMLElement.onkeypress = null;
			this.HTMLElement.oncontextmenu = null;
			this.HTMLElement.onmousedown = null;
			this.HTMLElement.onmouseup = null;
			this.HTMLElement.onmouseover = null;
			if(this.HTMLElement.style != null) {
				this.HTMLElement.style.paddingLeft = "";
				this.HTMLElement.style.paddingRight = "";
				this.HTMLElement.style.marginLeft = "";
				this.HTMLElement.style.marginRight = "";
			}
		}
	
		this.HTMLElement = null;
		this.strRef = null;
		this.flgHasCTIModule = null;
		this.flgHasMapModule = null;
		this.objForm = null;
	} catch(error) {
	}
}

/**
 * Check if either of the map modules are present.
 */
function FormField_hasMapModule() {

	if (this.flgHasMapModule != null) {
		return this.flgHasMapModule;
	}

	this.flgHasMapModule = false;	
	
	if (this.objForm != null) {
		this.flgHasMapModule = this.objForm.hasMapModule();
	} else if (objApplication.Modules("0036a-mapsm") || objApplication.Modules("0035a-mapmulti")) {
		this.flgHasMapModule = true;
	}
	
	return this.flgHasMapModule;
}

/**
 * Check if the CTI module is present.
 */
function FormField_hasCTIModule() {

	if (this.flgHasCTIModule != null) {
		return this.flgHasCTIModule;
	}
	
	this.flgHasCTIModule = false;

	if (this.objForm != null) {
		this.flgHasCTIModule = this.objForm.hasCTIModule();
	} else if (objApplication.Modules("0071a-cti")) {
		this.flgHasCTIModule = true;
	}
	
	return this.flgHasCTIModule;
}


var FT_MAXTIMEOUT = 120000;

var m_strFTFolder = "C:\\EFACSFT";
var m_objOldBGElement = null;
var m_strOldBGColour = null;

/** 
 * Constructor for the FunctionalTest object
 *
 * @param objWindow The window object.
 */
function FunctionalTest(objWindow)
{
// properties
	this.objWindow					= objWindow
	this.recordXMLDOM				= null;
	this.appletFT					= null;
	this.dialogWindowOpen			= false;
	this.dialogRecordEvent			= null;
	this.flgRealTimePlayback		= false;
	this.objFTGroupResultXML		= null;
	this.objFTUnitResultXML			= null;
	this.objFTPlayback				= null;
	this.state						= null;
	this.sleepTime					= 0;
	this.intGroupFailures			= 0;
	this.unitNumber					= 1;
	this.englishDateParser = null;
	this.localeDateParser = null;	
	this.localeNumberParser = null;

// methods
	this.initialise					= FunctionalTest_initialise;
	this.recordEvent				= FunctionalTest_recordEvent;
	this.saveRecordEvents			= FunctionalTest_saveRecordEvents;
	this.startRecording				= FunctionalTest_startRecording;
	this.endRecording				= FunctionalTest_endRecording;
	this.isFunctionalTestRecording	= FunctionalTest_isFunctionalTestRecording;
	this.isFunctionalTestPlaying	= FunctionalTest_isFunctionalTestPlaying;
	this.getWindowObject			= FunctionalTest_getWindowObject;
	this.recordInitialiseEvent		= FunctionalTest_recordInitialiseEvent;
	this.recordUnloadEvent			= FunctionalTest_recordUnloadEvent;
	this.recordTestFailure			= FunctionalTest_recordTestFailure;
	this.createFTGroupResultRecord	= FunctionalTest_createFTGroupResultRecord;
	this.addFTUnitResultRecord		= FunctionalTest_addFTUnitResultRecord;
	this.updateFTUnitResultRecord	= FunctionalTest_updateFTUnitResultRecord;
	this.updateFTGroupResultRecord	= FunctionalTest_updateFTGroupResultRecord;
	this.addFTUnitEventResult		= FunctionalTest_addFTUnitEventResult;
	this.startPlayback				= FunctionalTest_startPlayback;
	this.resetPlaybackObjects		= FunctionalTest_resetPlaybackObjects;
	this.checkForDialog				= FunctionalTest_checkForDialog;
	this.allTestPlaybacksComplete	= FunctionalTest_allTestPlaybacksComplete;
	this.waitForWindowToUnload		= FunctionalTest_waitForWindowToUnload;
	this.waitForWindowToLoad		= FunctionalTest_waitForWindowToLoad;
	this.playbackEvent				= FunctionalTest_playbackEvent;
	this.waitForDialogToUnload		= FunctionalTest_waitForDialogToUnload;
	this.moveToNextPlaybackEvent	= FunctionalTest_moveToNextPlaybackEvent;
	this.finishPlaybackEvents		= FunctionalTest_finishPlaybackEvents;
	this.processNumericInput		= FunctionalTest_processNumericInput;
	this.processDateInput			= FunctionalTest_processDateInput;
	this.formatLocaleDateOutput		= FunctionalTest_formatLocaleDateOutput;	
}

/** 
 * Gets references to the record and playback XML DOMs contained in EfacsApplet.
 * If a test is recording then an initialise event is noted.
 */
function FunctionalTest_initialise(flgRecordInitialise)
{
	this.appletFT = objApplication.EfacsApplet.getFunctionalTestObject();
	this.recordXMLDOM = this.appletFT.getFunctionalTestRecordDOM();
	
	if (flgRecordInitialise && this.isFunctionalTestRecording())
	{
		this.recordInitialiseEvent();
	
		var objElements = this.objWindow.document.getElementsByTagName("TEXTAREA");
		for (var i = 0, intLen = objElements.length; i < intLen; i++)
		{
			var objElement = objElements.item(i);
			addEvent(objElement, "onchange", FunctionalTest_recordTextAreaChange);
		}
	}
}

/** 
 * process input for a field. This may contain comparison tokens such as "!="
 * "<=3.14159"  is returned as "<=3,14159"
 * 
 * @param strValue the input stored in the functional test (english format)
 * @param strProPoint the decimal precision to use
 * @return String the localised version of the input 
 */
function FunctionalTest_processNumericInput(strValue, strProPoint)
{ 
	if (isBlank(strValue)) {
		return "";
	}
	
	if (strValue.indexOf("<>") != -1) 
     	return "<>" + this.localeNumberParser.getNumber (strValue.substring(strValue.indexOf("<>") + 2, strValue.length), strProPoint);
	else if (strValue.indexOf("!=") != -1) 
     	return "!=" + this.localeNumberParser.getNumber (strValue.substring(strValue.indexOf("!=") + 2, strValue.length), strProPoint);
	else if (strValue.indexOf(">=") != -1) 
     	return ">=" + this.localeNumberParser.getNumber (strValue.substring(strValue.indexOf(">=") + 2, strValue.length), strProPoint);
	else if (strValue.indexOf("!") != -1) 
     	return "!" + this.localeNumberParser.getNumber (strValue.substring(strValue.indexOf("!") + 1, strValue.length), strProPoint);
	else if (strValue.indexOf("<=") != -1) 
     	return "<=" + this.localeNumberParser.getNumber (strValue.substring(strValue.indexOf("<=") + 2, strValue.length), strProPoint);
	else if (strValue.indexOf(">") != -1) 
     	return ">" + this.localeNumberParser.getNumber (strValue.substring(strValue.indexOf(">") + 1, strValue.length), strProPoint);
	else if (strValue.indexOf("<") != -1)
     	return "<" + this.localeNumberParser.getNumber (strValue.substring(strValue.indexOf("<") + 1, strValue.length), strProPoint);
	else    	
		return "" + this.localeNumberParser.getNumber (strValue, strProPoint);
}

/** 
 * process input for a field. This may contain comparison tokens such as "!="
 * "<= 23 October 2004"  is returned as "<= 23 Oktober 2004"
 * "23 Oct 2004..30 Dec 2004"  is returned as "23 Okt 2004..30 Dez 2004"
 * 
 * @param strValue the input stored in the functional test (english format)
 * @param strDateType "date" if only the date should be parsed (excluding time) otherwise "datetime"
 * @return String the localised version of the input 
 */
function FunctionalTest_processDateInput(strValue, strDateType)
{
	if (isBlank(strValue)) {
		return "";
	}

	if (strValue.indexOf("..") != -1) {
		var dtDateFrom=this.englishDateParser.parse(strValue.substring(0, strValue.indexOf("..")));
		var strDateFrom=this.formatLocaleDateOutput(dtDateFrom, strDateType);
		var dtDateTo=this.englishDateParser.parse (strValue.substring(strValue.indexOf("..") + 2, strValue.length));
		var strDateTo=this.formatLocaleDateOutput(dtDateTo, strDateType);
		return strDateFrom + ".." + strDateTo;
		
	} else if (strValue.indexOf("|") != -1) {
		var from = 0;
		var to = 0;
		var strValue = "";

        for (; ;) {
            to = strValue.indexOf("|", from);

            if (from > 0)
                strValue += "|";
     			var dtDate=this.englishDateParser.parse(strValue.substring(from, (to == -1 ? strValue.length : to)));
				strValue += this.formatLocaleDateOutput(dtDate, strDateType);
            if (to == -1)
                break;

            from = to + 1;
        }

		return strValue;
		
	} else if (strValue.indexOf("<>") != -1) {
     	var dtDate=this.englishDateParser.parse(strValue.substring(strValue.indexOf("<>") + 2, strValue.length));
	    return "<>" + this.formatLocaleDateOutput(dtDate, strDateType);
	} else if (strValue.indexOf("!=") != -1) {
     	var dtDate=this.englishDateParser.parse(strValue.substring(strValue.indexOf("!=") + 2, strValue.length));
	    return "!=" + this.formatLocaleDateOutput (dtDate, strDateType);	
	} else if (strValue.indexOf(">=") != -1) {
     	var dtDate=this.englishDateParser.parse(strValue.substring(strValue.indexOf(">=") + 2, strValue.length));
	    return ">=" + this.formatLocaleDateOutput(dtDate, strDateType);	
	} else if (strValue.indexOf("!") != -1) {
     	var dtDate=this.englishDateParser.parse(strValue.substring(strValue.indexOf("!") + 1, strValue.length));
	    return "!" + this.formatLocaleDateOutput(dtDate, strDateType);
	} else if (strValue.indexOf("<=") != -1) {
     	var dtDate=this.englishDateParser.parse(strValue.substring(strValue.indexOf("<=") + 2, strValue.length));
	    return "<=" + this.formatLocaleDateOutput(dtDate, strDateType);
	} else if (strValue.indexOf(">") != -1) {
     	var dtDate=this.englishDateParser.parse(strValue.substring(strValue.indexOf(">") + 1, strValue.length));
	    return ">" + this.formatLocaleDateOutput(dtDate, strDateType);
	} else if (strValue.indexOf("<") != -1) {
     	var dtDate=this.englishDateParser.parse(strValue.substring(strValue.indexOf("<") + 1, strValue.length));
	    return "<" + this.formatLocaleDateOutput(dtDate, strDateType);
	} else {
     	var dtDate=this.englishDateParser.parse(strValue);
     	if (isBlank(dtDate))
     		return "";
     	else
			return "" + this.formatLocaleDateOutput(dtDate, strDateType);	
	}
	
}
/** 
 * @param dtDate a java date object
 * @param strDateType "date" if only the date should be parsed (excluding time) otherwise "datetime"
 * @return String the localised version of the input 
 */

function FunctionalTest_formatLocaleDateOutput (dtDate, strDateType) {

	if (strDateType=="date")
		return this.localeDateParser.formatLocaleDate (dtDate);	
	else 	
		return this.localeDateParser.formatLocaleDateTime (dtDate);	
}

function FunctionalTest_recordTextAreaChange(objEvent)
{
	if (objEvent == null)
		objEvent = window.event;

	var objWindow = objEvent.srcElement.ownerDocument.parentWindow;
	objWindow.appTrans_mainBodyFTEvent(objEvent);
}

/** 
 * Begins a functional test recording session.
 * Sets a flag in EfacsApplet which certain event triggers look for.
 *
 * @param strPath The file system location where the functional test will be stored.
 */
function FunctionalTest_startRecording(strPath)
{
	this.recordXMLDOM = this.appletFT.createFunctionalTestRecordDOM(strPath);
	this.recordXMLDOM.loadURL("../XML/xmlevc-template.xml", window.document.URL);

	var strComponentId = strPath.replace(m_strFTFolder + "\\", "");
	this.recordXMLDOM.selectSingleNode("/evc:component").setAttribute("id", strComponentId);
	this.recordXMLDOM.selectSingleNode("/evc:component").setAttribute("target", strComponentId);
	this.recordXMLDOM.selectSingleNode("/evc:component").setAttribute("code-access-level", "enterprise");
	this.recordXMLDOM.selectSingleNode("/evc:component").setAttribute("encrypted", "false");
	this.recordXMLDOM.selectSingleNode("/evc:component/version").setAttribute("id", "001");
	this.recordXMLDOM.selectSingleNode("/evc:component/source-details").setAttribute("author", objApplication.User.userID);
	this.recordXMLDOM.selectSingleNode("/evc:component/source-details").setAttribute("created-date", (objApplication.getDateParser().getCurrentLocaleDateTime()));
	this.recordXMLDOM.selectSingleNode("/evc:component/source-details/revision-control").setAttribute("revision", "$Rev" + "ision: 17 $");
	this.recordXMLDOM.selectSingleNode("/evc:component/source-details/revision-control").setAttribute("last-modified", "$Da" + "te: 24/10/03 12:03 $");
	this.recordXMLDOM.selectSingleNode("/evc:component/content").setAttribute("type", "functionaltest");
	this.recordXMLDOM.selectSingleNode("/evc:component/content").setAttribute("location", "client");

	var objNode = this.recordXMLDOM.createElement("application");
	this.recordXMLDOM.selectSingleNode("/evc:component/content").appendChild(objNode);
	objNode = this.recordXMLDOM.createElement("events");
	this.recordXMLDOM.selectSingleNode("/evc:component/content/application").appendChild(objNode);

	this.appletFT.startFunctionalTestRecord();
}

/** 
 * Ends a functional test recording session.
 */
function FunctionalTest_endRecording()
{
	this.appletFT.endFunctionalTestRecord();
}

/** 
 * Records an individual functional test event - clicking on a button etc.
 *
 * @param objEvent The window event object.
 * @param strComponentId Optional parameter used when declaring non-browser driven events
 *                       such as an application is now fully loaded or unloaded.
 *                       If not passed then uses component id from this.objWindow.
 */
function FunctionalTest_recordEvent(objEvent, strComponentId)
{
	var objElement = objEvent.srcElement;

	if (document.body.compId == "appComboBox.xml" || 
		document.body.compId == "appDateTimePicker.xml" ||
		objElement.id == "ctlComboBox" ||
		(objElement.tagName == "BUTTON" && (objElement.className == "ComboBoxButton" || objElement.className == "DatePickerButton")))
	{
		return;
	}

	var objNode = this.recordXMLDOM.selectSingleNode("/evc:component/content/application/events").appendChild(this.recordXMLDOM.createElement("event"));

	if (strComponentId == null)
		strComponentId = objElement.ownerDocument.body.compId;

	objNode.setAttribute("component-id", strComponentId);

	if (objEvent.keyCode != 0)
		objNode.setAttribute("event-key-code", objEvent.keyCode);
	if (objEvent.shiftKey == true)
		objNode.setAttribute("event-shift-key", "true");
	if (objEvent.ctrlKey == true)
		objNode.setAttribute("event-ctrl-key", "true");
	
	objNode.setAttribute("time-ms", (objApplication.getServerDate()).valueOf());
	
	// Check for toolbar-button.
	if (objElement.className == "toolbar-button")
	{
		objNode.setAttribute("event-type", objEvent.type);
		objNode.setAttribute("object-type", "simpleID");
		objNode.setAttribute("object-id", objElement.id);
		if (!isBlank(objElement.src))
		{
			var objValueNode = objNode.appendChild(this.recordXMLDOM.createElement("object-value"));
			objNode.selectSingleNode("object-value").setCDATAText(objElement.src);
		}
	}
	// Check for toolbar-button-image.
	else if (objElement.className == "toolbar-button-image")
	{
		objNode.setAttribute("event-type", objEvent.type);
		objNode.setAttribute("object-type", "simpleID");
		objNode.setAttribute("object-id", objElement.parentElement.id);
		if (!isBlank(objElement.src))
		{
			var objValueNode = objNode.appendChild(this.recordXMLDOM.createElement("object-value"));
			objNode.selectSingleNode("object-value").setCDATAText(objElement.src);
		}
	}
	// Check for toolbar-button-label.
	else if (objElement.className == "toolbar-button-label")
	{
		objNode.setAttribute("event-type", objEvent.type);
		objNode.setAttribute("object-type", "simpleID");
		objNode.setAttribute("object-id", objElement.parentElement.id);
		if (!isBlank(objElement.innerHTML))
		{
			var objValueNode = objNode.appendChild(this.recordXMLDOM.createElement("object-value"));
			objNode.selectSingleNode("object-value").setCDATAText(objElement.innerHTML);
		}
	}
	// Check for grid cell.
	else if (objElement.tagName == "TD" || 
		((objElement.tagName == "LABEL" || objElement.tagName == "IMG") &&  objElement.parentElement.tagName == "TD"))
	{
		var objHTMLTable = getParentElement(objElement, "table");
		
		if (objHTMLTable.className == "GridContainer")
		{
			var objTD;
			if (objElement.tagName == "TD")
				objTD = objElement;
			else
				objTD = objElement.parentElement;
			
			objNode.setAttribute("event-type", objEvent.type);
			
			if (objElement.tagName == "TD")
				objNode.setAttribute("object-type", "gridTD");
			else if (objElement.tagName == "LABEL")
				objNode.setAttribute("object-type", "gridLABEL");
			else
				objNode.setAttribute("object-type", "gridIMG");

			var objGrid = window[objHTMLTable.id.replace("et_grd", "")];
			objNode.setAttribute("grid-id", objGrid.id);
			objNode.setAttribute("row-id", objTD.parentElement.cells[0].innerHTML);
			objNode.setAttribute("cell-index", et_getCellIndex(objTD));
		}
		// Check for id property
		else if (!isBlank(objElement.id))
		{
			objNode.setAttribute("event-type", objEvent.type);
			objNode.setAttribute("object-type", "simpleID");
			objNode.setAttribute("object-id", objElement.id);
			if (!isBlank(objElement.value))
			{
				var objValueNode = objNode.appendChild(this.recordXMLDOM.createElement("object-value"));
				objNode.selectSingleNode("object-value").setCDATAText(objElement.value);
			}
		}
	}
	else if (objElement.tagName == "DIV" && !isBlank(objElement.id) && document.getElementsByName(objElement.id).length > 1)
	{
		var objElements = document.getElementsByName(objElement.id);
		for (var i = 0; i < objElements.length; i++)
		{
			if (objElement == objElements[i])
				break;
		}
		objNode.setAttribute("event-type", objEvent.type);
		objNode.setAttribute("object-type", "multipleID");
		objNode.setAttribute("object-id", objElement.id);
		objNode.setAttribute("object-index", i);
	}
	// Check for id property
	else if (!isBlank(objElement.id))
	{
		objNode.setAttribute("event-type", objEvent.type);
		objNode.setAttribute("object-type", "simpleID");
		objNode.setAttribute("object-id", objElement.id);
		if (!isBlank(objElement.value))
		{
			var objValueNode = objNode.appendChild(this.recordXMLDOM.createElement("object-value"));
			objNode.selectSingleNode("object-value").setCDATAText(objElement.value);
		}
	}

	if (strComponentId == "msgGeneric.xml")
	{
		if (objNode.previousSibling().getAttribute("object-id") == "lnkClose")
		{
			var objPreviousSibling = objNode.parentNode().removeChild(objNode.previousSibling());
			this.recordXMLDOM.selectSingleNode("/evc:component/content/application/events").appendChild(objPreviousSibling);
		}
	}

	if (this.dialogRecordEvent != null)
	{
		this.recordXMLDOM.selectSingleNode("/evc:component/content/application/events").appendChild(this.dialogRecordEvent);
		this.dialogRecordEvent = null;
	}
}

/** 
 * Records the fact that an application has now fully loaded.
 */
function FunctionalTest_recordInitialiseEvent()
{
	if (document.body.compId == "appComboBox.xml" || document.body.compId == "appDateTimePicker.xml")
		return;

	var objNode = this.recordXMLDOM.createElement("event");
	objNode.setAttribute("component-id", this.objWindow.document.body.compId);
	objNode.setAttribute("time-ms", (objApplication.getServerDate()).valueOf());
	objNode.setAttribute("event-type", "windowInitialise");
	this.recordXMLDOM.selectSingleNode("/evc:component/content/application/events").appendChild(objNode);
}

/** 
 * Records the fact that an application has now fully unloaded.
 */
function FunctionalTest_recordUnloadEvent()
{
	if (document.body.compId == "appComboBox.xml" || document.body.compId == "appDateTimePicker.xml")
		return;

	if (this.recordXMLDOM != null)
	{
		var objNode = this.recordXMLDOM.createElement("event");
		objNode.setAttribute("component-id", this.objWindow.document.body.compId);
		objNode.setAttribute("time-ms", (objApplication.getServerDate()).valueOf());
		objNode.setAttribute("event-type", "windowUnload");
		this.recordXMLDOM.selectSingleNode("/evc:component/content/application/events").appendChild(objNode);
	}
}

/** 
 * Constructor for the FunctionalTestPlayback object
 *
 * @param arrTestNames An array containing all tests to be played back
 * @param intPlayCount The number of playback iterations.
 * @param objFunctionalTest The functional test object.
 */
function FunctionalTestPlayback(arrTestNames, intPlayCount, objFunctionalTest)
{
	this.strPath					= null;
	this.objEventNodes				= null;
	this.objRecordDate				= null;
	this.objPlaybackDate			= null;
	this.currentEventNode			= 0;
	this.failureReason				= null;
	this.failureValue				= null;
	this.eventNodeCount				= 0;
	this.intTimer					= null;
	this.intDuration				= (objApplication.getServerDate()).valueOf();
	this.objDialogNodes				= new Array();
	this.objWindow					= null;
	this.arrTestNames				= arrTestNames;
	this.testNameCtr				= 0;
	this.intIteration				= 0;
	this.intPlayCount				= intPlayCount;
}

var FTSTATE_BEGINPLAYBACK			= 1;
var FTSTATE_RESETPLAYBACKOBJECTS	= 2
var FTSTATE_CHECKFORDIALOG			= 3;
var FTSTATE_TESTCOMPLETE			= 4;
var FTSTATE_WAITFORWINDOWUNLOAD		= 5;
var FTSTATE_WAITFORWINDOWLOAD		= 6;
var FTSTATE_PLAYBACKEVENT			= 7;
var FTSTATE_WAITFORDIALOGUNLOAD		= 8;
var FTSTATE_MOVETONEXTEVENT			= 9;
var FTSTATE_FINISHPLAYBACKEVENTS	= 10;

/** 
 * Plays back all function tests from start to finish.
 *
 * @param arrTestNames An array containing all tests to be played back
 * @param intPlayCount The number of playback iterations.
 */
function FunctionalTest_playbackEvents(arrTestNames, intPlayCount)
{
	objFunctionalTest = window.m_objFunctionalTest;
	
	if (objFunctionalTest.state == null)
		objFunctionalTest.state = FTSTATE_BEGINPLAYBACK;

	try {
		switch (objFunctionalTest.state) 
		{
			case FTSTATE_BEGINPLAYBACK:
				objFunctionalTest.startPlayback(arrTestNames, intPlayCount);
				break;

			case FTSTATE_RESETPLAYBACKOBJECTS:
				objFunctionalTest.resetPlaybackObjects();
				break;
			
			case FTSTATE_CHECKFORDIALOG:
				objFunctionalTest.checkForDialog();
				break;
			
			case FTSTATE_TESTCOMPLETE:
				objFunctionalTest.allTestPlaybacksComplete();
				return;

			case FTSTATE_WAITFORWINDOWUNLOAD:
				objFunctionalTest.waitForWindowToUnload();
				break;
			
			case FTSTATE_WAITFORWINDOWLOAD:
				objFunctionalTest.waitForWindowToLoad();
				break;
			
			case FTSTATE_PLAYBACKEVENT:
				objFunctionalTest.playbackEvent();
				break;

			case FTSTATE_WAITFORDIALOGUNLOAD:
				objFunctionalTest.waitForDialogToUnload();
				break;

			case FTSTATE_MOVETONEXTEVENT:
				objFunctionalTest.moveToNextPlaybackEvent();
				break;
				
			case FTSTATE_FINISHPLAYBACKEVENTS:
				objFunctionalTest.finishPlaybackEvents();
				break;
		}

		if (objFunctionalTest.objFTPlayback.intTimer != null && objFunctionalTest.state != FTSTATE_RESETPLAYBACKOBJECTS &&
			(objApplication.getServerDate()).valueOf() - objFunctionalTest.objFTPlayback.intTimer > (FT_MAXTIMEOUT * 4))
		{
			try {
				var objNode = objFunctionalTest.objFTPlayback.objEventNodes.item(objFunctionalTest.objFTPlayback.currentEventNode);
				
				// May have failed on last node on test.
				if (objNode == null)
					objNode = objFunctionalTest.objFTPlayback.objEventNodes.item(objFunctionalTest.objFTPlayback.currentEventNode - 1);

				objFunctionalTest.recordTestFailure("FT TIMEOUT ERROR", objNode.xml() + " - IN - " + objNode.ownerDocument().xml());
			} catch (e2) {
			}
			objFunctionalTest.objFTPlayback.intTimer = (objApplication.getServerDate()).valueOf();
			objFunctionalTest.state = FTSTATE_FINISHPLAYBACKEVENTS;
		}
	}
	catch (e) 
	{
		try {
			var objNode = objFunctionalTest.objFTPlayback.objEventNodes.item(objFunctionalTest.objFTPlayback.currentEventNode);
			objFunctionalTest.recordTestFailure("SCRIPT ERROR - " + e.number + " - " + e.description, objNode.getAttribute("component-id"));
		} catch (e2) {
		}
		objFunctionalTest.state = FTSTATE_FINISHPLAYBACKEVENTS;
	}

	window.setTimeout("window.FunctionalTest_playbackEvents()", objFunctionalTest.sleepTime);
}

/** 
 * Begins the playback session.
 *
 * @param arrTestNames An array containing all tests to be played back
 * @param intPlayCount The number of playback iterations.
 */
function FunctionalTest_startPlayback(arrTestNames, intPlayCount)
{
	this.appletFT.startFunctionalTestPlay();
	this.objFTPlayback = new FunctionalTestPlayback(arrTestNames, intPlayCount, this);

	this.createFTGroupResultRecord();

	this.intGroupFailures = 0;

	this.state = FTSTATE_RESETPLAYBACKOBJECTS;
}

/** 
 * Resets playback objects for the next test.
 */
function FunctionalTest_resetPlaybackObjects()
{
	this.objFTPlayback.strPath = this.objFTPlayback.arrTestNames[this.objFTPlayback.testNameCtr];
	this.recordXMLDOM = this.appletFT.loadFunctionalTestRecordDOM(this.objFTPlayback.strPath);
	this.objFTPlayback.objEventNodes = this.recordXMLDOM.selectNodes("/evc:component/content/application/events/event");

	if (this.objFTPlayback.objEventNodes.item(0).getAttribute("time-ms") != null)
		this.objFTPlayback.objRecordDate = new Date(Number(this.objFTPlayback.objEventNodes.item(0).getAttribute("time-ms")));
	else
		this.objFTPlayback.objRecordDate = null;

	this.objFTPlayback.objPlaybackDate = objApplication.getServerDate();
	this.objFTPlayback.currentEventNode = 0;
	this.objFTPlayback.eventNodeCount = this.objFTPlayback.objEventNodes.length();

	this.objFTPlayback.failureReason = null;
	this.objFTPlayback.failureValue = null;

	if (this.objFTUnitResultXML != null)
	{
		if (this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/ftunitresults/ftunitresult") != null)
			this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/ftunitresults").removeChild(this.objFTUnitResultXML);
	}
	
	this.addFTUnitResultRecord(this.objFTPlayback.strPath.replace(m_strFTFolder + "\\", ""));

	var strStatusMessage = "TEST (" + Number(this.objFTPlayback.testNameCtr + 1) + "/" + this.objFTPlayback.arrTestNames.length + ")";
	strStatusMessage += " : ITERATION (" + Number(this.objFTPlayback.intIteration + 1) + "/" + this.objFTPlayback.intPlayCount + ")";
	strStatusMessage += " : NAME (" + this.objFTPlayback.arrTestNames[this.objFTPlayback.testNameCtr] + ")";
	strStatusMessage += " : " + this.intGroupFailures + " FAILURES";
	this.objWindow.status = strStatusMessage;

	this.objFTPlayback.objDialogNodes = new Array();

	this.sleepTime = 500;
	this.state = FTSTATE_CHECKFORDIALOG;
}

/** 
 * Checks whether a modal dialog is about be opened.
 * Initialises dialog variables if this is the case.
 */
function FunctionalTest_checkForDialog()
{
	var objNode = this.objFTPlayback.objEventNodes.item(this.objFTPlayback.currentEventNode);
	this.objFTPlayback.objDialogNodes = new Array();

	while (objNode.getAttribute("component-id") == "htmldialog.xml" || objNode.getAttribute("component-id") == "msgGeneric.xml")
	{
		this.objFTPlayback.objDialogNodes[this.objFTPlayback.objDialogNodes.length] = objNode;
		this.objFTPlayback.currentEventNode++;

		objNode = this.objFTPlayback.objEventNodes.item(this.objFTPlayback.currentEventNode - 1);
		this.addFTUnitEventResult(objNode);
		this.objFTPlayback.intDuration = (objApplication.getServerDate()).valueOf();

		objNode = this.objFTPlayback.objEventNodes.item(this.objFTPlayback.currentEventNode);
	}
	
	this.objFTPlayback.intTimer = (objApplication.getServerDate()).valueOf();

	if (this.objFTPlayback.failureReason == null)
		this.state = FTSTATE_WAITFORWINDOWUNLOAD;
}

/** 
 * Finishes the playback session.
 */
function FunctionalTest_allTestPlaybacksComplete()
{
	this.appletFT.endFunctionalTestPlay();
	this.state = null;
	
	var objWindow = this.getWindowObject(this.objWindow, "appFTUnitRecorder.xml");
	if (objWindow != null)
		objWindow.playbackScriptsComplete();
	else
	{
		objWindow = this.getWindowObject(this.objWindow, "appFTGroupResultEdit.xml")
		if (objWindow != null)
			objWindow.playbackScriptsComplete();
	}
	
	this.updateFTGroupResultRecord();
	
	this.objWindow.status = "Ready";
}

/** 
 * Waits for any window unload events to complete.
 */
function FunctionalTest_waitForWindowToUnload() 
{
	var objNode = this.objFTPlayback.objEventNodes.item(this.objFTPlayback.currentEventNode);

	if (objNode.getAttribute("event-type") == "windowUnload")
	{
		if (this.getWindowObject(this.objWindow, objNode.getAttribute("component-id")) != null)
		{
			if ((objApplication.getServerDate()).valueOf() - this.objFTPlayback.intTimer > FT_MAXTIMEOUT)
			{
				this.recordTestFailure("Window did not close as expected", objNode.getAttribute("component-id"));
				this.sleepTime = 1000;
			}
			else
				this.sleepTime = 100;
		}
		else
		{
			this.sleepTime = 0;
			if (this.objFTPlayback.failureReason == null)
				this.state = FTSTATE_MOVETONEXTEVENT;
		}
	}
	else 
	{
		this.sleepTime = 0;
		this.objFTPlayback.intTimer = (objApplication.getServerDate()).valueOf();
		if (this.objFTPlayback.failureReason == null)
			this.state = FTSTATE_WAITFORWINDOWLOAD;
	}
}

/** 
 * Waits for any window load events to complete.
 */
function FunctionalTest_waitForWindowToLoad()
{
	var objNode = this.objFTPlayback.objEventNodes.item(this.objFTPlayback.currentEventNode);

	if (objNode.getAttribute("component-id") == null)
	{
		this.state = FTSTATE_FINISHPLAYBACKEVENTS;
		this.sleepTime = 500;
		return;
	}

	var objWindow = null;
	try {
		objWindow = this.getWindowObject(this.objWindow, objNode.getAttribute("component-id"));
	} catch (error) {
	}

	if (objWindow == null || (objWindow.m_objFunctionalTest == null && objNode.getAttribute("component-id").indexOf("_iframe") == -1))
	{
		if ((objApplication.getServerDate()).valueOf() - this.objFTPlayback.intTimer > FT_MAXTIMEOUT)
		{
			this.recordTestFailure("Timeout waiting for window to load", objNode.getAttribute("component-id"));
			this.sleepTime = 1000;
		}
		else
			this.sleepTime = 200;
	}
	else
	{
		if (objNode.getAttribute("component-id") == "appEarlRun.xml" || objNode.getAttribute("component-id") == "appEarlRun2.xml")
		{
			if (objWindow.frames["reportIframe"].document.getElementById("numberofpages") == null)
			{
				this.sleepTime = 1000;
				return;
			}
		}
		else if (objNode.getAttribute("component-id") == "appEarl.xml" || objNode.getAttribute("component-id") == "appEarl2.xml")
		{
			if (objWindow.objApplication == null ||
				objWindow.objApplication.Forms("m_objForm") == null ||
				objWindow.objApplication.Forms("m_objForm").getFieldByRef("layout") == null ||
				objWindow.objApplication.Forms("m_objForm").getFieldByRef("layout").selectOne == null ||
				objWindow.objApplication.Forms("m_objForm").getFieldByRef("layout").selectOne.Values.length == 0)
			{
				this.sleepTime = 100;
				return;
			}
		}

		this.sleepTime = 0;
		this.objFTPlayback.objWindow = objWindow;
		if (this.objFTPlayback.failureReason == null)
			this.state = FTSTATE_PLAYBACKEVENT;
	}
}

/** 
 * Plays back a single event.
 */
function FunctionalTest_playbackEvent()
{
	var objHTMLObject = null;
	var objNode = this.objFTPlayback.objEventNodes.item(this.objFTPlayback.currentEventNode);
	var blnMenuLaunch = false;

	// Handle menu events - just to launch an application
	if (objNode.getAttribute("component-id") == "appMenu.xml")
	{
		// Loop through the nodes checking if we find all the events are as expected to launch an app
		// if they are as expected then just launch the application
		for (var i = this.objFTPlayback.currentEventNode; i < this.objFTPlayback.objEventNodes.length(); i++)
		{
			var objCurrNode = this.objFTPlayback.objEventNodes.item(i);
			var strObjectType = objCurrNode.getAttribute("object-type");
			if (strObjectType == "multipleID" && objCurrNode.getAttribute("object-id") == "oDiv") {
				continue;
			} else if (objCurrNode.getAttribute("grid-id") == "grdMenuTree") {
				if (strObjectType == "gridIMG") {
					continue;
				}
				var strEventType = objCurrNode.getAttribute("event-type");
				if (strObjectType == "gridLABEL" && strEventType == "dblclick") {
					continue;
				} else if (strObjectType == "gridLABEL" && strEventType == "click") {
					// Found an application launch - load the menu record
					var objRPCMenu = new RPCObject("Menu");
					var strMenuID = objCurrNode.getAttribute("row-id");
					objRPCMenu.execute("load", objApplication.Connection.strConnectionString, strMenuID);
					var MenuXML = objRPCMenu.getReturnedXMLDom();
					var strAppID = null;
					var strTitle = null;
					if (MenuXML.selectSingleNode("//efacsappid/value") != null)
					{
						strAppID = MenuXML.selectSingleNode("//efacsappid/value").getText();
						strTitle = MenuXML.selectSingleNode("//description/value").getText();
					} else {
						strAppID = strMenuID;
						strMenuID = "FT";
					}
					var objRPCApp = new RPCObject("EfacsApp");
					objRPCApp.execute("load", objApplication.Connection.strConnectionString, strAppID);
					var AppXML = objRPCApp.getReturnedXMLDom();
					if (AppXML.selectSingleNode("//apptype/value") != null) {
						var strAppType = AppXML.selectSingleNode("//apptype/value").getText();
						var strCommand = AppXML.selectSingleNode("//command/value").getText();
					} else {
						continue;
					}
					if (strTitle == null) {
						strTitle = AppXML.selectSingleNode("//description/value").getText();
					}
					// Open the application
					var objWindow = getTopWindow();
					objWindow.openApp(strAppID, null, strTitle, strMenuID, strCommand, strAppType, true);
	
					// Launched app so now set new current node and mark it as menu launch
					this.objFTPlayback.currentEventNode = i;
					blnMenuLaunch = true;
					break;
				}
			} else {
				break;
			}
		}
	}

	if (this.objFTPlayback.objDialogNodes.length > 0)
	{
		getFunctionalTestObject().dialogWindowOpen = true;
		getFunctionalTestObject().dialogWindowCommands = this.objFTPlayback.objDialogNodes;
	}
	
	if (blnMenuLaunch == false) {
		if (objNode.getAttribute("event-type") == "windowInitialise")
		{
			// Do nothing - we just needed to force a wait while any windows finished loading.
			this.objFTPlayback.currentEventNode++;
	
			var objNode = this.objFTPlayback.objEventNodes.item(this.objFTPlayback.currentEventNode - 1);
			this.addFTUnitEventResult(objNode);
			this.objFTPlayback.intDuration = (objApplication.getServerDate()).valueOf();
	
			if (this.objFTPlayback.failureReason == null)
				this.state = FTSTATE_CHECKFORDIALOG;
			return;
		}

		// if the test is not running in English UK, create parsers to translate the input data. 
		if (objApplication.User.localeid.toLowerCase() != "en-gb") {
			if (this.englishDateParser==null)
				this.englishDateParser =objApplication.EfacsApplet.getEfacsDateParser("en-GB", "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/XML/xmlRegionalSettings.xml");
			if (this.localeDateParser==null)
				this.localeDateParser =objApplication.EfacsApplet.getEfacsDateParser(objApplication.User.localeid, "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/XML/xmlRegionalSettings.xml");
			if (this.localeNumberParser ==null)
				this.localeNumberParser=objApplication.getNumberFormatter();
		}		
	
		if (objNode.getAttribute("object-type").substring(0, 4) == "grid") // Check for grid cell
		{
			var objGrid = this.objFTPlayback.objWindow.objApplication.Grids(objNode.getAttribute("grid-id"));

			try {
				if (objGrid.isTreeGrid) {
					objGrid.Tree.loadAllChildren();
				}
				var objHTMLRow = objGrid.getRow(objNode.getAttribute("row-id")).HTMLElement;
				
				if (objHTMLRow == null)
				{
					this.recordTestFailure("Cannot get required grid row", objNode.getAttribute("component-id"));
					return;
				}
			} catch (error) {
				this.recordTestFailure("Cannot get required grid row", objNode.getAttribute("component-id"));
				return;
			}

			if (objNode.getAttribute("object-type") == "gridTD")
				objHTMLObject = objHTMLRow.cells[objNode.getAttribute("cell-index")];
			else if (objNode.getAttribute("object-type") == "gridLABEL")
				objHTMLObject = objHTMLRow.cells[1].children[objHTMLRow.cells[1].children.length - 1];
			else
			{
				var objIMGChildren = objHTMLRow.cells[1].children;
				for (var i = 0; i < objIMGChildren.length; i++)
				{
					if (objIMGChildren[i].doOnClick == "toggle")
					{
						objHTMLObject = objIMGChildren[i];
						break;
					}
				}
			}
		}
		else if (objNode.getAttribute("object-type") == "multipleID")
		{
			var intIndex = Number(objNode.getAttribute("object-index"));
			var objElements = this.objFTPlayback.objWindow.document.getElementsByName(objNode.getAttribute("object-id"));
	
			if (objElements.length < intIndex)
			{
				this.recordTestFailure("Cannot find multiple ID element array", objNode.getAttribute("component-id"));
				return;
			}
	
			objHTMLObject = objElements[intIndex];
	
			if (objNode.getAttribute("event-type") == "change")
			{
				var strValueToUse;
				if (objNode.selectSingleNode("object-value") != null)
					strValueToUse = objNode.selectSingleNode("object-value").getText();
				else if (objNode.getAttribute("object-value") != null)
					strValueToUse = objNode.getAttribute("object-value");
				else
					strValueToUse = "";
				
				// if we are working in a foreign locale, localeNumberFormatter will exist
				if ((objHTMLObject.datatype == "xsd:float" ||	
					 objHTMLObject.datatype == "xsd:double" ||
					 objHTMLObject.datatype == "xsd:decimal")
					&& this.localeNumberParser != null 
					&& !isBlank (strValueToUse)) {
					// change the numbers and preserve any comparison characters such as "!="
					strValueToUse=this.processNumericInput(String (strValueToUse), String (objHTMLObject.proPoint));
				}	
				
				// if we are working in a foreign locale, localeDateParser will exist
				// we have to take the english date, turn it into a date object then format this for the target locale as if a locale user had typed it in
				if (objHTMLObject.datatype == "xsd:dateTime"
					&& this.localeDateParser != null 
					&& !isBlank (strValueToUse)) {
					var strDateTime="datetime";
					if (objHTMLObject.isDateTimeFormat!="true")
						strDateTime="date";

					strValueToUse=this.processDateInput (strValueToUse, strDateTime);
				}
				objHTMLObject.value = strValueToUse;
			}
		}
		else if (objNode.getAttribute("object-type") == "simpleID")
		{
			objHTMLObject = this.objFTPlayback.objWindow.document.getElementById(objNode.getAttribute("object-id"));
	
			if (objHTMLObject == null)
			{
				this.recordTestFailure("Cannot find simple ID element", objNode.getAttribute("component-id") + " : " + objNode.getAttribute("object-id"));
				return;
			}
	
			if (objNode.getAttribute("event-type") == "change")
			{
				var strValueToUse;
	
				if (objNode.selectSingleNode("object-value") != null)
					strValueToUse = objNode.selectSingleNode("object-value").getText();
				else if (objNode.getAttribute("object-value") != null)
					strValueToUse = objNode.getAttribute("object-value");
				else
					strValueToUse = "";

				// if we are working in a foreign locale, localeNumberFormatter will exist
				if ((objHTMLObject.datatype == "xsd:float" ||	
					 objHTMLObject.datatype == "xsd:double" ||
					 objHTMLObject.datatype == "xsd:decimal")
					&& this.localeNumberParser != null 
					&& !isBlank (strValueToUse)) {
					// change the numbers and preserve any comparison characters such as "!="
					strValueToUse=this.processNumericInput(String (strValueToUse), String (objHTMLObject.proPoint));
				}	
				// if we are working in a foreign locale, localeDateParser will exist
				// we have to take the english date, turn it into a date object then format this for the target locale as if a locale user had typed it in
				if (objHTMLObject.datatype == "xsd:dateTime"
					&& this.localeDateParser != null 
					&& !isBlank (strValueToUse)) {
					var strDateTime="datetime";
					if (objHTMLObject.isDateTimeFormat!="true")
						strDateTime="date";

					strValueToUse=this.processDateInput (strValueToUse, strDateTime);
				}
				objHTMLObject.value = strValueToUse;	
			}
		} else if (objNode.getAttribute("object-type") == "pauseEvent") {
		    objApplication.EfacsApplet.sleep(Number(objNode.getAttribute("pause-time")));
		}

		try {
			// Un-highlight old element
			if (m_objOldBGElement != null && typeof(m_objOldBGElement.style) != "unknown")
				m_objOldBGElement.style.backgroundColor = m_strOldBGColour;
	
			// and highlight new element.
			m_objOldBGElement = objHTMLObject;
			m_strOldBGColour = objHTMLObject.currentStyle.backgroundColor;
			objHTMLObject.style.backgroundColor = "yellow";
		} catch (error) {
		}
		
		var objEvent = this.objFTPlayback.objWindow.document.createEventObject();
		if (objNode.getAttribute("event-key-code") != null)
			objEvent.keyCode = Number(objNode.getAttribute("event-key-code"));
		if (objNode.getAttribute("event-shift-key") == "true")
			objEvent.shiftKey = true;
		if (objNode.getAttribute("event-ctrl-key") == "true")
			objEvent.ctrlKey = true;

		if (this.flgRealTimePlayback == true && this.objFTPlayback.objRecordDate != null)
		{
			while ((objApplication.getServerDate()).valueOf() - this.objFTPlayback.objPlaybackDate.valueOf() < Number(objNode.getAttribute("time-ms")) - this.objFTPlayback.objRecordDate.valueOf())
				objApplication.EfacsApplet.sleep(75);
		}

		if (objNode.getAttribute("event-type") == "click")
			objHTMLObject.click();
		else if (objNode.getAttribute("event-type") != "pauseEvent")
			objHTMLObject.fireEvent("on" + objNode.getAttribute("event-type"), objEvent);
	}

	this.objFTPlayback.intTimer = (objApplication.getServerDate()).valueOf();

	if (this.objFTPlayback.failureReason == null)
		this.state = FTSTATE_WAITFORDIALOGUNLOAD;
}

/** 
 * Waits for any open modal dialogs to close.
 */
function FunctionalTest_waitForDialogToUnload()
{
	var flgDialogOpen = false;
	if (getFunctionalTestObject().dialogWindowOpen == true)
		flgDialogOpen = true;
	
	try {
		if (this.objFTPlayback.objWindow.m_objFunctionalTest.dialogWindowOpen == true)
			flgDialogOpen = true;
	} catch (error) {
	}

	if (flgDialogOpen == true)
	{
		if ((objApplication.getServerDate()).valueOf() - this.objFTPlayback.intTimer > FT_MAXTIMEOUT)
		{
			var objNode = this.objFTPlayback.objEventNodes.item(this.objFTPlayback.currentEventNode);
			this.recordTestFailure("Expected message box did not appear", objNode.getAttribute("component-id"));
			getFunctionalTestObject().dialogWindowOpen = false;
			this.sleepTime = 1000;
		}
		else
			this.sleepTime = 100;
	}
	else 
	{
		this.sleepTime = 0;
		if (this.objFTPlayback.failureReason == null)
			this.state = FTSTATE_MOVETONEXTEVENT;
	}
}

/** 
 * Moves to the next test playback event.
 */
function FunctionalTest_moveToNextPlaybackEvent()
{
	this.objFTPlayback.currentEventNode++;
	
	if (this.isFunctionalTestPlaying() == false)
	{
		this.sleepTime = 1000;
		this.finishPlaybackEvents();
		if (this.objFTPlayback.failureReason == null)
			this.state = FTSTATE_TESTCOMPLETE;
	}
	else if (this.objFTPlayback.currentEventNode >= this.objFTPlayback.objEventNodes.length())
	{
		this.sleepTime = 500;
		this.state = FTSTATE_FINISHPLAYBACKEVENTS;
	}
	else
	{
		if (this.objFTPlayback.failureReason == null)
			this.state = FTSTATE_CHECKFORDIALOG;
	}
	
	if (this.objFTPlayback.currentEventNode > 1)
	{
		var objNode = this.objFTPlayback.objEventNodes.item(this.objFTPlayback.currentEventNode - 1);
		this.addFTUnitEventResult(objNode);
	}
	
	this.objFTPlayback.intDuration = (objApplication.getServerDate()).valueOf();
}

/**
 * Finsished a single test playback and resets variables for the next test.
 */
function FunctionalTest_finishPlaybackEvents()
{
	if (this.objFTPlayback.failureReason != null)
	{
		if (this.objFTUnitResultXML.selectSingleNode("ftuniteventresults") != null)
		{
			var objFTUnitEventResult = this.objFTUnitResultXML.selectSingleNode("ftuniteventresults").lastChild();
			objFTUnitEventResult.selectSingleNode("passed/value").setText("false");
		}

		if (this.objFTPlayback != null)
		{
			var objWindow = getTopWindow();
			if (objWindow.m_arrChildWindows.length > 0 &&
				objWindow.m_arrChildWindows[0].document.body.compId != "appFTGroupResultMan.xml" &&
				objWindow.m_arrChildWindows[0].document.body.compId != "appFTUnitRecorder.xml")
			{
				objWindow.objApplication.closeAllChildWindows(objWindow);
			}
		}
	}

	this.updateFTUnitResultRecord();

	this.sleepTime = 0;

	do {
		this.objFTPlayback.testNameCtr ++;

		if (this.objFTPlayback.testNameCtr >= this.objFTPlayback.arrTestNames.length)
		{
			this.objFTPlayback.intIteration ++;
			if (this.objFTPlayback.intIteration >= this.objFTPlayback.intPlayCount)
			{
				this.state = FTSTATE_TESTCOMPLETE;
				return;
			}
			else
			{
				this.objWindow.objApplication.EfacsApplet.clearCache();
				this.objFTPlayback.testNameCtr = 0;
			}
		}
	} while (this.objFTPlayback.arrTestNames[this.objFTPlayback.testNameCtr] == null)

	this.state = FTSTATE_RESETPLAYBACKOBJECTS;
}

/** 
 * Loops through arrays of all open windows looking for the correct window
 * according to the passed parameter strComponentId.
 *
 * @param objWindow The starting window from which to drill down through.
 * @param strComponentId The component id for the requested window.
 * @return The requested window reference.
 */
function FunctionalTest_getWindowObject(objWindow, strComponentId)
{
	var objReturnWindow = null;

	if (strComponentId == objWindow.document.body.compId)
	{
		objReturnWindow = objWindow;
	}
	else if (objWindow.frames[strComponentId] != null)
	{
		objReturnWindow = objWindow.frames[strComponentId];
	}
	else
	{
		for (var i = 0; i < objWindow.m_arrChildWindows.length; i ++)
		{
			var objChildWindow = objWindow.m_arrChildWindows[i];
			objReturnWindow = null;

			try {
				if (strComponentId == objChildWindow.document.body.compId)
				{
					objReturnWindow = objChildWindow;
					break;
				}
				
				if (objChildWindow.frames[strComponentId] != null)
				{
					objReturnWindow = objChildWindow.frames[strComponentId];
					break;
				}

				if (objChildWindow.objApplication.fileName != objWindow.objApplication.fileName)
				{
					for (var j = 0; j < objChildWindow.objApplication.arrEditWindowManagers.length; j++)
					{
						var objEditWindowManager = objChildWindow.objApplication.arrEditWindowManagers[j];
					
						// A window may have unloaded during the life-cyle of this loop.
						if (objEditWindowManager == null)
							break;
					
						for (var k = 0; k < objEditWindowManager.arrEditWindows.length; k++)
						{
							var objEditWindow = objEditWindowManager.arrEditWindows[k];

							// A window may have unloaded during the life-cyle of this loop.
							if (objEditWindow == null)
								break;

							if (strComponentId == objEditWindow.AppWindow.document.body.compId)
							{
								objReturnWindow = objEditWindow.AppWindow;
								break;
							}

							if (objEditWindow.AppWindow.frames[strComponentId] != null)
							{
								objReturnWindow = objEditWindow.AppWindow.frames[strComponentId];
								break;
							}
							
							var objReturnWindow = this.getWindowObject(objEditWindow.AppWindow, strComponentId);
							if (objReturnWindow != null)
								break;
						}
					
						if (objReturnWindow != null)
							break;
					}
					if (objReturnWindow != null)
						break;

					for (var j = 0; j < objChildWindow.m_arrChildWindows.length; j++)
					{
						var objReturnWindow = this.getWindowObject(objChildWindow.m_arrChildWindows[j], strComponentId);
						if (objReturnWindow != null)
							break;
					}
					if (objReturnWindow != null)
						break;
				}
			} catch (error) {
				// Set time out will try again.
				return;
			}
		}
	}

	return objReturnWindow;	
}

/** 
 * Writes a newly recorded functional test to the file system for later playback.
 */
function FunctionalTest_saveRecordEvents()
{
	this.recordXMLDOM.save(this.appletFT.getFunctionalTestRecordPath());
}

/** 
 * Is a functional test currently being recorded.
 *
 * @return true if test is currently being recorded, false if not.
 */
function FunctionalTest_isFunctionalTestRecording()
{
	return this.appletFT.isFunctionalTestRecording();
}

/** 
 * Is a functional test currently being played back.
 *
 * @return true if test is currently being played back, false if not.
 */
function FunctionalTest_isFunctionalTestPlaying()
{
	return this.appletFT.isFunctionalTestPlaying();
}

/** 
 * During a playback, records a test failure to the functional test unit result file.
 *
 * @param strReason The reason for the failure.
 * @param strValue Any associated value - eg. the text from an unexpected error message box.
 */
function FunctionalTest_recordTestFailure(strReason, strValue)
{
	var objFunctionalTest = this;
	
	if (objFunctionalTest.objFTPlayback == null)
		objFunctionalTest = getFunctionalTestObject();

	objFunctionalTest.state = FTSTATE_FINISHPLAYBACKEVENTS;
	objFunctionalTest.sleepTime = 500;

	if (objFunctionalTest.objFTPlayback.failureReason == null)
	{
		objFunctionalTest.objFTPlayback.failureReason = strReason;
		objFunctionalTest.objFTPlayback.failureValue = strValue;
	}
}

/** 
 * Creates an FTGroupResult header record on the database.
 */
function FunctionalTest_createFTGroupResultRecord()
{
	var objNode = objApplication.Data.generateNewRow("ftgroupresult");
	var objXML = objApplication.createXMLDocument(objApplication.Data.convertToCollection(objNode).xml());

	var objDetailsXML = objApplication.createXMLDocument();
	objDetailsXML.load("../XML/xmlProductDetails.xml");

	var objShell = new ActiveXObject("WScript.Shell")
	var strClientName = objShell.ExpandEnvironmentStrings("%COMPUTERNAME%");
	var strOS = objShell.ExpandEnvironmentStrings("%OS%");

	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/passed/value").setText("false");
	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/passed/value").removeAttribute("xsi:nil");
	
	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/clientname/value").setText(strClientName);
	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/clientname/value").removeAttribute("xsi:nil");

	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/servername/value").setText(objApplication.Connection.applicationServer);
	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/servername/value").removeAttribute("xsi:nil");

	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/release/value").setText(objDetailsXML.selectSingleNode("/evc:component/content/product-details/release").getText());
	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/release/value").removeAttribute("xsi:nil");

	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/buildnumber/value").setText(objDetailsXML.selectSingleNode("/evc:component/content/product-details/build-number").getText());
	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/buildnumber/value").removeAttribute("xsi:nil");

	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/startdate/value").setText(UTCToISODate(objApplication.getServerDate()));
	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/startdate/value").removeAttribute("xsi:nil");

	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/clientos/value").setText(strOS);
	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/clientos/value").removeAttribute("xsi:nil");

	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/browser/value").setText(navigator.appName + " " + navigator.appVersion);
	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/browser/value").removeAttribute("xsi:nil");

	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/jreversion/value").setText(objApplication.EfacsApplet.getJavaVersion());
	objXML.selectSingleNode("/ftgroupresults/ftgroupresult/jreversion/value").removeAttribute("xsi:nil");

	var objRPC = new RPCObject("ftgroupresult", this.objWindow);
	objRPC.handleRPCError = false;
	try {
		objRPC.execute("save", objApplication.Connection.strConnectionString, objXML.xml());
	} catch (error) {
	}

	this.objFTGroupResultXML = objRPC.getReturnedXMLDom();
}

/** 
 * Updates the FTGroupResult header record on the database - sets whether test passed or failed.
 * Saves all child FTUnitResult and FTUnitEventResult records.
 */
function FunctionalTest_updateFTGroupResultRecord()
{
	this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/enddate/value").setText(UTCToISODate(objApplication.getServerDate()));

	if (this.intGroupFailures == 0)
		this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/passed/value").setText("true");

	var dblPercentPassed = (this.objFTPlayback.arrTestNames.length - this.intGroupFailures) / this.objFTPlayback.arrTestNames.length * 100;
	this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/percentpassed/value").setText(dblPercentPassed);
	this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/percentpassed/value").removeAttribute("xsi:nil");

	this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/enddate/value").setText(UTCToISODate(objApplication.getServerDate()));
	this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/enddate/value").removeAttribute("xsi:nil");

	objNode = this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/ftunitresults");
	if (objNode != null)
		this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult").removeChild(objNode);

	var objRPC = new RPCObject("ftgroupresult", this.objWindow);
	objRPC.handleRPCError = false;
	try {
		objRPC.execute("save", objApplication.Connection.strConnectionString, this.objFTGroupResultXML.xml());
	} catch (error) {
	}
}

/** 
 * Appends an FTUnitResult to the FTGroupResult parent record - will be saved when tests are finished.
 *
 * @param strUnitName The functional test unit name.
 */
function FunctionalTest_addFTUnitResultRecord(strUnitName)
{
	var objNode = objApplication.Data.generateNewRow("ftunitresult");
	var objXML = objApplication.createXMLDocument(objApplication.Data.convertToCollection(objNode).xml());

	var strGroupNumber = this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/groupnumber/value").getText();
	objXML.selectSingleNode("/ftunitresults/ftunitresult/groupnumber/value").setText(strGroupNumber);
	objXML.selectSingleNode("/ftunitresults/ftunitresult/groupnumber/value").removeAttribute("xsi:nil");
	
	objXML.selectSingleNode("/ftunitresults/ftunitresult/unitnumber/value").setText(this.unitNumber++);
	objXML.selectSingleNode("/ftunitresults/ftunitresult/unitnumber/value").removeAttribute("xsi:nil");
	
	objXML.selectSingleNode("/ftunitresults/ftunitresult/applicationid/value").setText(strUnitName);
	objXML.selectSingleNode("/ftunitresults/ftunitresult/applicationid/value").removeAttribute("xsi:nil");

	objXML.selectSingleNode("/ftunitresults/ftunitresult/startdate/value").setText(UTCToISODate(objApplication.getServerDate()));
	objXML.selectSingleNode("/ftunitresults/ftunitresult/startdate/value").removeAttribute("xsi:nil");

	objXML.selectSingleNode("/ftunitresults/ftunitresult/enddate/value").setText(UTCToISODate(objApplication.getServerDate()));
	objXML.selectSingleNode("/ftunitresults/ftunitresult/enddate/value").removeAttribute("xsi:nil");

	objXML.selectSingleNode("/ftunitresults/ftunitresult/passed/value").setText("false");
	objXML.selectSingleNode("/ftunitresults/ftunitresult/passed/value").removeAttribute("xsi:nil");
	
	if (this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/ftunitresults") == null)
		this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult").appendChild(objXML.selectSingleNode("/ftunitresults"));
	else
		this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/ftunitresults").appendChild(objXML.selectSingleNode("/ftunitresults/ftunitresult"));

	this.objFTUnitResultXML = this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/ftunitresults").lastChild();
}

/** 
 * Updates the FTUnitResult record on the database - sets whether test passed or failed.
 */
function FunctionalTest_updateFTUnitResultRecord()
{
	this.objFTUnitResultXML.selectSingleNode("enddate/value").setText(UTCToISODate(objApplication.getServerDate()));

	if (this.objFTPlayback.failureReason == null)
		this.objFTUnitResultXML.selectSingleNode("passed/value").setText("true");
	else
	{
		this.intGroupFailures ++;
		this.objFTUnitResultXML.selectSingleNode("failurereason/value").setText(this.objFTPlayback.failureReason);
		this.objFTUnitResultXML.selectSingleNode("failurereason/value").removeAttribute("xsi:nil");
		this.objFTUnitResultXML.selectSingleNode("failurevalue/value").setText(this.objFTPlayback.failureValue);
		this.objFTUnitResultXML.selectSingleNode("failurevalue/value").removeAttribute("xsi:nil");
	}

	var objRPC = new RPCObject("ftunitresult", this.objWindow);
	objRPC.handleRPCError = false;
	try {
		objRPC.execute("save", objApplication.Connection.strConnectionString, this.objFTUnitResultXML.xml());
	} catch (error) {
	}

	var dblPercentPassed = ((this.objFTPlayback.testNameCtr + 1) - this.intGroupFailures) / this.objFTPlayback.arrTestNames.length * 100;
	this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/percentpassed/value").setText(dblPercentPassed);
	this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/percentpassed/value").removeAttribute("xsi:nil");

	var objNode = this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/ftunitresults");
	if (objNode != null)
		this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult").removeChild(objNode);

	var objRPC = new RPCObject("ftgroupresult", this.objWindow);
	objRPC.handleRPCError = false;
	try {
		objRPC.execute("save", objApplication.Connection.strConnectionString, this.objFTGroupResultXML.xml());
	} catch (error) {
	}
}

/** 
 * Appends an FTUnitEventResult to the FTUnitResult parent record - will be saved when test is finished.
 *
 * @param objEventNode The currect functional test event node.
 */
function FunctionalTest_addFTUnitEventResult(objEventNode)
{
	var objNode = objApplication.Data.generateNewRow("ftuniteventresult");
	var objXML = objApplication.createXMLDocument(objApplication.Data.convertToCollection(objNode).xml());

	var strGroupNumber = this.objFTGroupResultXML.selectSingleNode("/ftgroupresults/ftgroupresult/groupnumber/value").getText();
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/groupnumber/value").setText(strGroupNumber);
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/groupnumber/value").removeAttribute("xsi:nil");
	
	var strUnitNumber = this.objFTUnitResultXML.selectSingleNode("unitnumber/value").getText();
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/unitnumber/value").setText(strUnitNumber);
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/unitnumber/value").removeAttribute("xsi:nil");

	var strUnitEventNumber = this.objFTUnitResultXML.selectNodes("ftuniteventresults/ftuniteventresult").length() + 1;
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/uniteventnumber/value").setText(strUnitEventNumber);
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/uniteventnumber/value").removeAttribute("xsi:nil");
	
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/windowid/value").setText(objEventNode.getAttribute("component-id"));
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/windowid/value").removeAttribute("xsi:nil");
	
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/eventtype/value").setText(objEventNode.getAttribute("event-type"));
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/eventtype/value").removeAttribute("xsi:nil");
	
	if (objEventNode.getAttribute("event-key-code"))
	{
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/eventkeycode/value").setText(objEventNode.getAttribute("event-key-code"));
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/eventkeycode/value").removeAttribute("xsi:nil");
	}
	
	if (objEventNode.getAttribute("event-shift-key"))
	{
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/eventshiftkey/value").setText("true");
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/eventshiftkey/value").removeAttribute("xsi:nil");
	}
	
	if (objEventNode.getAttribute("event-ctrl-key"))
	{
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/eventctrlkey/value").setText("true");
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/eventctrlkey/value").removeAttribute("xsi:nil");
	}

	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/objecttype/value").setText(objEventNode.getAttribute("object-type"));
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/objecttype/value").removeAttribute("xsi:nil");

	if (objEventNode.getAttribute("object-id"))
	{
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/objectid/value").setText(objEventNode.getAttribute("object-id"));
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/objectid/value").removeAttribute("xsi:nil");
	}
	
	if (objEventNode.getAttribute("object-index"))
	{
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/objectindex/value").setText(objEventNode.getAttribute("object-index"));
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/objectindex/value").removeAttribute("xsi:nil");
	}

	if (objNode.selectSingleNode("object-value") != null)
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/objectvalue/value").setCDATAText(objNode.selectSingleNode("object-value").getText());
	else if (objEventNode.getAttribute("object-value") != null)
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/objectvalue/value").setCDATAText(objEventNode.getAttribute("object-value"));
	else
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/objectvalue/value").setText("");
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/objectvalue/value").removeAttribute("xsi:nil");
	
	if (objEventNode.getAttribute("grid-id"))
	{
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/gridid/value").setText(objEventNode.getAttribute("grid-id"));
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/gridid/value").removeAttribute("xsi:nil");
	}

	if (objEventNode.getAttribute("row-id"))
	{
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/gridrowid/value").setText(objEventNode.getAttribute("row-id"));
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/gridrowid/value").removeAttribute("xsi:nil");
	}

	if (objEventNode.getAttribute("cell-index"))
	{
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/gridcellindex/value").setText(objEventNode.getAttribute("cell-index"));
		objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/gridcellindex/value").removeAttribute("xsi:nil");
	}

	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/timems/value").setText((objApplication.getServerDate()).valueOf());
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/timems/value").removeAttribute("xsi:nil");

	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/durationms/value").setText((objApplication.getServerDate()).valueOf() - this.objFTPlayback.intDuration);
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/durationms/value").removeAttribute("xsi:nil");
	
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/passed/value").setText("true");
	objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult/passed/value").removeAttribute("xsi:nil");
	
	if (this.objFTUnitResultXML.selectSingleNode("ftuniteventresults") == null)
		this.objFTUnitResultXML.appendChild(objXML.selectSingleNode("/ftuniteventresults"));
	else
		this.objFTUnitResultXML.selectSingleNode("ftuniteventresults").appendChild(objXML.selectSingleNode("/ftuniteventresults/ftuniteventresult"));
}


		


// Browser defines
var APPLICATION_IE = 0x1;
var APPLICATION_NN = 0x2;
var currentBrowser = null;

// General utility constants
var GENUTIL_INFOPANEL		= 0x1;
var GENUTIL_DATEPICKER		= 0x2;
var GENUTIL_COMBOBOX		= 0x4;
var GENUTIL_MAP				= 0x8;
var GENUTIL_ADDRESSLOOKUP	= 0x10;
var GENUTIL_FILEDIALOG		= 0x20;
var GENUTIL_CTI				= 0x40;

var GENUTIL_DOUBLETOLERANCE	= 0.000000001;

// Declare public grid Constants.
var etc_BEFORE = 2;
var etc_AFTER = 3;
var etc_HIDDEN = 4;
var etc_VISIBLE = 5;

// Declare public checkbox constants
var cb_CHECKED = -1;
var cb_UNCHECKED = 0;
var cb_READONLY = 0x0;

// Error numbers
var ERROR_RPCINVOKEERROR = 80001;
var ERROR_JAVASCRIPTERROR = 80002;

// Modal parameters
var modal_APPLICATION = 0;
var modal_FUNCTIONALTEST = 1;
var modal_WINDOW = 2;

//Other constants
var NBSP_CONSTANT = "&nbsp;";

var CTI_CALLSTATUS_RINGING		= 1;
var CTI_CALLSTATUS_ANSWERED		= 2;
var CTI_CALLSTATUS_END			= 3;

var CTI_CALLDIRECTION_OUTBOUND			= 1;
var CTI_CALLDIRECTION_INBOUNDINTERNAL	= 2;
var CTI_CALLDIRECTION_INBOUNDEXTERNAL	= 3;
var m_CTIObject = null;

/*-------------------------------------------------------- ERROR REPORTING ROUTINES ------------------------------------------------------------------------*/

/** 
 * Displays a particular message as specified in the parameters
 *
 * N.B. This has now been replaced by the new messaging subsystem
 * and should only be used to support existing code
 *
 * @param	Prompt		message text
 *			Buttons		buttons to display on the message box
 *			Title		title of the message
 *			appWindow	window to display the message in
 *
 * @return	value returned from the message box
 */
function eMsgBox(Prompt, Buttons, Title, appWindow) 
{
	var objMessage = objApplication.addMessage("EMSGBOX", Prompt, "", Buttons, Title, appWindow);
	var retVal = objApplication.Messages("EMSGBOX").show();

	objApplication.removeMessage(objMessage);
	
	return retVal;
}

/*-------------------------------------------------------- TRANSLATION  ROUTINES ------------------------------------------------------------------------*/

//	Foreign language function
//	All visible strings in script code should use the following
//	function so that the string is marked for translation...
function fl() 
{
	var objArr = arguments;
	
	objArr[0] = objDict.getString(objArr[0]);
	strMessage = processArgs(objArr);

	for ( ; strMessage.indexOf("\n") != -1 ; )
		strMessage = strMessage.replace("\n", "<br />")
	
	return strMessage;
}

/* ------------------------------------------------ DATE ROUTINES ----------------------------------------------------------------- */
/**
 * Public method to parse locale formatted date string
 * into Java Date object.
 * 
 * @param strDate The locale formatted date string.
 * @return The Java Date object representing passed date string or null if it cant be parsed.
 */
function localeStringToJavaDate(strDate)
{
	var objEfacsCalendar=objApplication.getCalendarParser();
	var objJavaDate=null;
	try {
		objJavaDate=objEfacsCalendar.setDateTimeInLocaleFormat (strDate);
	}
	catch (error){  	
	}
	
	return objJavaDate;
}

/** Returns the new date based on the given date and an interval in days
 * @param java anyDate Date object containing start date
 * @param int n  numbers of days to add or subtract
 * @return Date
 */
function dateInterval(anyDate, n){
	var objEfacsCalendar=objApplication.getCalendarParser();
	objEfacsCalendar.setDateTime(anyDate);
	objEfacsCalendar.addDays (n);
	return (objEfacsCalendar.getDateTime());
}

var m_strMouseOverBckColour;

/** Changes the button style when the mouse moves over the button
 * @param objElement Button element
 */
function ButtonMouseOver(objElement)
{
	if (objElement.srcElement != null)
		objElement = objElement.srcElement;
		
	if (m_strMouseOverBckColour == null)
	{
		// First time in - store the background colour after applying the className.
		objElement.className = "ButtonOver";
		if (objApplication && objApplication.browser == APPLICATION_IE)
			m_strMouseOverBckColour = objElement.currentStyle.backgroundColor;
	}
	else
	{
		// We have already applied the className once so we simply set the background colour.
		objElement.style.backgroundColor = m_strMouseOverBckColour;
	}
}

var m_strMouseOutBckColour;

/** Changes the button style when the mouse moves out of the button
 * @param objElement Button element
 */
function ButtonMouseOut(objElement)
{
	if (objElement.srcElement != null)
		objElement = objElement.srcElement;

	if (m_strMouseOutBckColour == null)
	{
		// First time in - store the background colour after applying the className.
		objElement.className = "button";
		if (objApplication && objApplication.browser == APPLICATION_IE)
			m_strMouseOutBckColour = objElement.currentStyle.backgroundColor;
	}
	else
	{
		// We have already applied the className once so we simply set the background colour.
		objElement.style.backgroundColor = m_strMouseOutBckColour;
	}
}

/* ------------------------------------------------ MISCELLANEOUS ----------------------------------------------------------------- */
function isValidEmail(pm_strEmailAddress)
{
	var strRegularExpression = /^(([^<>()[\]\\.,;:@\"]+(\.[^<>()[\]\\.,;:@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
	return strRegularExpression.test(pm_strEmailAddress);
}

/** Check each address in the list to ensure it is valid
 * @param strAddresses comma-seperated list of addresses
 * @return true if addresses valid, otherwise false
 */
function checkEMailAddresses(strAddresses) {
	strAddresses = util_trim(strAddresses);
	if (isBlank(strAddresses))
		return false;
	var arrAddrs = strAddresses.split(",");
	
	var intLen = arrAddrs.length; 
	for (var intCtr = 0; intCtr < intLen; intCtr++) {
		if (!isValidEmail(arrAddrs[intCtr]))
			return false;
	}
	return true;
}

function ParseStringFromURL(strParseString, strURL) {
	var strArgs;
	var arrayArgs;
	var intCtr;
	var flgFound;
		
	flgFound = false;
		
	strArgs = String(strURL).slice((String(strURL).search(/\?/g))+ 1);

	arrayArgs = String(strArgs).split(/\&/g);

	for (intCtr=0; intCtr<arrayArgs.length;intCtr++)
	{
		if (String(arrayArgs[intCtr]).search(/\=/g) > 0)
		{
			if (String(strParseString).toLowerCase() == String(String(arrayArgs[intCtr]).slice(0, String(arrayArgs[intCtr]).search(/\=/g))).toLowerCase())
			{
				return String(arrayArgs[intCtr]).slice(String(arrayArgs[intCtr]).search(/\=/g)+1);
			}
		}
	}
}

/**
 * Escapes XML characters.
 *
 * @param strXML The XML to be escaped.
 * @return The escaped XML.
 */
function escapeXML(strXML)
{
	if (typeof(strXML) != "string")
		return strXML;
 
	var regEx = /&/g;
	strXML = strXML.replace(regEx, "&amp;");

	regEx = /</g;
	strXML = strXML.replace(regEx, "&lt;");

	regEx = />/g;
	strXML = strXML.replace(regEx, "&gt;");

	regEx = /\"/g;
	strXML = strXML.replace(regEx, "&quot;");

	regEx = /'/g;
	strXML = strXML.replace(regEx, "&apos;");

	return strXML;
}

/**
 * Unescapes XML characters.
 *
 * @param strXML The XML containing the escaped characters.
 * @return The unescaped XML.
 */
function unescapeXML(strXML)
{
	if (typeof(strXML) != "string")
		return strXML;
		
	var regEx = /&lt;/g;
	strXML = strXML.replace(regEx, "<");

	regEx = /&gt;/g;
	strXML = strXML.replace(regEx, ">");

	regEx = /&quot;/g;
	strXML = strXML.replace(regEx, "\"");

	regEx = /&apos;/g;
	strXML = strXML.replace(regEx, "'");

	regEx = /&amp;/g;
	strXML = strXML.replace(regEx, "&");
	
	regEx = /&nbsp;&nbsp;/g;
	strXML = strXML.replace(regEx, "  ");

	return strXML;
}

/**
 * Unescape single quotes
 * @param strXML String to unescape
 * @return String containing actual single quotes
 */
function unescapeXMLSingleQuote(strXML) {
	if (typeof(strXML) != "string")
		return strXML;
		
	regEx = /&apos;/g;
	strXML = strXML.replace(regEx, "'");
	
	return strXML;
}

function GetCheckBoxValue(strVal) {
	if (String(strVal).toLowerCase() == "true")
		return -1;
	else
		return 0;
}

function formatInteger(strValue)
{
	var strLocStr = util_localeNumber(strValue, null);

	if (objApplication.Data.decimalSymbol == null)
	{
		objApplication.Data.decimalSymbol = objApplication.getNumberFormatter().getLocaleDecimalPointSymbol();
	}

	if (objApplication.Data.decimalSymbol != "" && strLocStr.lastIndexOf(objApplication.Data.decimalSymbol) != -1)
		return strLocStr.substring(0, strLocStr.lastIndexOf(objApplication.Data.decimalSymbol));
	else
		return strLocStr;
}

/**
 * Convert a java List into a String array
 *
 * @param objList
 * @return string array
 */
function JavaListToStringArray (objList)
{
	// gives string format "[el0, el1, el2]"
	// empty elements are shown "[,el0,el1,el2]"
	var strList=objList.toString();
	
	// empty list
	var intStartList=strList.indexOf("[");
	var intEndList=strList.indexOf("]");
	if (intStartList == -1 || (intStartList+1==intEndList) )
		return new Array();

	// split the ccentral section of the string into a comma separated sequence.
	var strElementSection=strList.substring(intStartList+1, intEndList);
	var arrElements=strElementSection.split(',');	
	
	// remove any leading spaces. 
	for (var i=0, arrLen=arrElements.length; i < arrLen; i++)
		arrElements[i]=util_trim(arrElements[i]);
		
	return arrElements;	
}

/**
 * Sets window title caption
 *
 * @param strCaption Caption string.
 */
function setWindowCaption(strCaption)
{
	window.document.title = strCaption;
}

/**
 * Recurses upwards and returns the parent HTML element of passed objElement whose tag 
 * name equals passed value.
 *
 * @param objElement The HTML element.
 * @param strTagName The HTML element tag name.
 * @param strClassName The optional HTML element class name.
 */
function getParentElement(objElement, strTagName, strClassName)
{
	if (objElement == null)
		return null;
	else if (objElement.nodeType == 1 && objElement.tagName.toLowerCase() == strTagName.toLowerCase())
	{
		if (strClassName == null || objElement.className == strClassName)
			return objElement;
		else
			return getParentElement(objElement.parentNode, strTagName, strClassName);
	}
	else
		return getParentElement(objElement.parentNode, strTagName, strClassName);
}

// Accepts an XPath string and returns the string without the bottom most element name.
function getParentXPath(strXPath) {
	for (var intCtr = strXPath.length; intCtr > 0; intCtr--)
	{
		if (strXPath.substring(intCtr - 1, intCtr) == "/")
			break;
	}
	if (intCtr > 0)
		return strXPath.substring(0, intCtr - 1);
	else
		return strXPath;
}

function fireInfoPanel(objEvent)
{
	fireControlWindow(GENUTIL_INFOPANEL, objEvent);
}

function fireDatePicker(objEvent)
{
	fireControlWindow(GENUTIL_DATEPICKER, objEvent);
}

function fireComboBox(objEvent)
{
	fireControlWindow(GENUTIL_COMBOBOX, objEvent);
}

function fireMap(objEvent)
{
	fireControlWindow(GENUTIL_MAP, objEvent);
}

/**
 *
 */
function fireCTI(objEvent) {
	fireControlWindow(GENUTIL_CTI, objEvent);
}

function fireAddressLookup(objEvent)
{
	fireControlWindow(GENUTIL_ADDRESSLOOKUP, objEvent);
}

/**
 * Fires 'browse to file' window
 *
 * @param objEvent The event object
 * @param fileDialogType Whether folder or not
 * @param strOnFileSelectMethod Method to call once the file has been selected.
 */
function fireFileDialog(objEvent, fileDialogType, strOnFileSelectMethod)
{
	fireControlWindow(GENUTIL_FILEDIALOG, objEvent, fileDialogType, strOnFileSelectMethod);
}

/**
 * Fires the control window
 * @param flgControlId The type of control
 * @param objEvent The event object
 * @param fileDialogType Whether folder or not
 * @param strOnFileSelectMethod Method to call once the file has been selected
 */
function fireControlWindow(flgControlId, objEvent, fileDialogType, strOnFileSelectMethod)
{
	var objForm;
	var strRef = "";

	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.currentTarget;
	
	// Try and get a ref to the form.
	var objHTMLForm = getParentElement(objBrowserEvent, "FORM");
	if (objHTMLForm == null)
		objHTMLForm = getParentElement(objBrowserEvent, "TR", "editableGridForm");

	// If the HTML form can't be found then the infopanel must have been fired from another infopanel.
	// If this is the case then there will only be one form for the info panel in the application object.
	if (objHTMLForm == null)
		objForm = objApplication.arrForms[0];
	else		
		objForm = window[objHTMLForm.id.replace("frm", "")];

	// Get the form field ref.
	for (var objElement = objBrowserEvent.previousSibling; objElement != null; objElement = objElement.previousSibling)
	{
		if (objApplication.browser == APPLICATION_NN)
			objElement = objElement.previousSibling;

		if (objElement.className == "EfacsField" || objElement.className == "EfacsFieldHasFocus" ||
		    objElement.className == "EfacsFieldRequired" || objElement.className == "EfacsFieldRequiredHasFocus" ||
		    objElement.className == "TextBox" || objElement.className == "TextBoxHasFocus" ||
		    objElement.className == "InvalidTextBox" || objElement.className == "InvalidTextBoxHasFocus" ||
		    objElement.className == "ReadBox")
   		{
			strRef = objElement.getAttribute("ref");
			break;
		}
	}

	// Finally get a ref to the form field object itself.	
	var objFormField = objForm.getFieldByRef(strRef);

	if (flgControlId & GENUTIL_COMBOBOX) {
		if (objFormField.getHTMLElement().blnIsDisabled == "false")
			objFormField.fireComboBox(objEvent);
	}
	else if (flgControlId & GENUTIL_DATEPICKER) {
		if (objFormField.getHTMLElement().blnIsDisabled == "false")
			objFormField.fireDatePicker(objEvent);
	}
	else if (flgControlId & GENUTIL_INFOPANEL) {
		objFormField.fireInfoPanel();
	}
	else if (flgControlId & GENUTIL_MAP) {
		objFormField.fireMap();
	}
	else if (flgControlId & GENUTIL_CTI) {
		objFormField.fireCTI();
	}
	else if (flgControlId & GENUTIL_ADDRESSLOOKUP) {
		objFormField.fireAddressLookup();
	}
	else if (flgControlId & GENUTIL_FILEDIALOG) {
		if (objFormField.getHTMLElement().blnIsDisabled == "false")
			objFormField.fireFileDialog(objEvent, fileDialogType, strOnFileSelectMethod);
	}
}

function processArgs(args) {
	var strMessage = args[0];
	for (var n = 1, intLen = args.length; n < intLen; n++)
		strMessage = String(strMessage).replace("#" + n, "<b>" + args[n] + "</b>");

	return strMessage; 
} 

var m_arrOldStyles;

function setMouseCursorWait(objWindow)
{
	if (m_arrOldStyles != null)
		return;
		
	m_arrOldStyles = new Array();

	var objHTMLElement;
	var objHTMLElements = objWindow.document.getElementsByTagName("TD");

	for (var intCtr = 0, intLen = objHTMLElements.length; intCtr < intLen; intCtr++)
	{
		objHTMLElement = objHTMLElements.item(intCtr);
		m_arrOldStyles[intCtr] = objHTMLElement.style.cursor;
		objHTMLElement.style.cursor = "wait";
	}
}

function setMouseCursorNormal(objWindow)
{
	if (m_arrOldStyles == null)
		return;

	var objHTMLElements = objWindow.document.getElementsByTagName("TD");

	for (var intCtr = 0; intCtr < objHTMLElements.length; intCtr++)
		objHTMLElements.item(intCtr).style.cursor = m_arrOldStyles[intCtr];

	m_arrOldStyles = null;
}

function stripHTMLChars(strText) 
{
	if(strText == null) return;
	if(strText == "") return "";

    for ( ; strText.indexOf("%20") > 0; )
        strText = strText.replace("%20", " ");
    
    return strText;
}

/* ------------------------------------------------ Variable type testing functions ------------------------------------------- */

var defaultEmptyOK = false;
var reInteger = /^(-)?\d+$/
var reFloat = /^(((-)?\d+(\.\d*)?)|((-)?(\d*\.)?\d+))$/

function isEmpty(strVal) 
{
	return ((strVal == null) || (strVal == ""));
}

/**
 * See if the string is blank.
 * @param strVal String to test.
 * @return true if the string is blank, false otherwise.
 */
function isBlank(strVal) {
	if (isEmpty(strVal)) return true;
	
	var s2 = String(strVal);
	for (var n = 0; n < s2.length; n++) {
		if (s2.charAt(n) != " ")
			return false;
	}
	
	return true;
}

/**
 * Compares two strings in either a case sensitive or case insensitive manner.
 * @param strVal1 - string to use in comparison.
 * @param strVal2 - string to use in comparison.
 * @return true if the strings are equal, false otherwise.
 */
function isEqual(strVal1, strVal2) {
	// Case insensitive comparison is optional.
	if (objApplication.Connection.databaseSensitivity == "SENSITIVE") {
		return (strVal1 == strVal2);
	} else {
		if ((strVal1 == null && strVal2 != null) || (strVal1 != null && strVal2 == null)) return false;
		if (strVal1 == null && strVal2 == null) return true;
		var l1 = strVal1.length;
		var l2 = strVal2.length;
		if (l1 != l2) return false;
		if (l1 == 0 && l2 == 0) return true;

		var collator = objApplication.EfacsApplet.getCollator();
		return (collator.compare(String(strVal1), String(strVal2))) == 0;
	}	
}

function isInteger (intVal) 
{
	var val = Number(util_parseNumber(intVal));
	if (!isNaN(val) && val != Infinity && Math.floor(val) == val)
		return isIntegerVal(intVal);
	else
		return false;
}

function isIntegerVal (intVal) 
{
    if (isEmpty(intVal)) 
       if (isInteger.arguments.length == 1)
			return defaultEmptyOK;
       else
			return (isInteger.arguments[1] == true);

    return reInteger.test(intVal);
}

function isFloat (dblVal) 
{
	var val = Number(util_parseNumber(dblVal));
	if (!isNaN(val) && val != Infinity)
		return true
	else
		return false;
}

function isISODate (strDate) 
{
	if (strDate.indexOf("-") == 4 && strDate.lastIndexOf("-") == 7 && 
		strDate.indexOf("T") == 10 && strDate.indexOf("Z") == 19 &&
		strDate.indexOf(":") == 13 && strDate.lastIndexOf(":") == 16)
		return true;
	else
		return false;
}

function getOffsetLeftFromElement(objChildElement, strElementID)
{
	var intOffsetLeft = 0;
	
	for (var objElement = objChildElement; objElement != null && objElement != objElement.offsetParent; objElement = objElement.offsetParent)
	{
		if (objElement.id == strElementID)
			break;
		
		intOffsetLeft += objElement.offsetLeft;
	}
	
	return intOffsetLeft;
}

function getOffsetTopFromElement(objChildElement, strElementID)
{
	var intOffsetTop = 0;
	
	for (var objElement = objChildElement; objElement != null && objElement != objElement.offsetParent; objElement = objElement.offsetParent)
	{
		if (objElement.id == strElementID)
			break;
	
		intOffsetTop += objElement.offsetTop;
	}
		
	return intOffsetTop;
}

function isAppWindowInAppContainer(objWindow)
{
	for (var intCtr=0; intCtr < objWindow.parent.frames.length; intCtr++)
	{
		if (typeof(objWindow.parent.frames[intCtr].document) == "unknown")
			return false;

		if (objWindow.parent.frames[intCtr].document.body.childNodes.length > 0)
		{
			if (objWindow.parent.frames[intCtr].name.substring(0, 7) == "HTML_AC")
				return true;
		}
	}
	return false;
}

function getDocumentBodyHeight(objWindow)
{
	if (isAppWindowInAppContainer(objWindow))
		return objWindow.document.body.offsetHeight + 26;
	else
		return objWindow.document.body.offsetHeight + 20;
}

function getDocumentBodyWidth(objWindow)
{
	if (isAppWindowInAppContainer(objWindow))
		return objWindow.document.body.offsetWidth + 26;
	else
		return objWindow.document.body.offsetWidth + 28;
}

function createLog(menuID, appID)
{
	if (objApplication.User.logUser != "true")
		return 0;

	var LogXML = objApplication.createXMLDocument();

	var objRPC = new RPCObject("UserActivityLog");

	var objNode = objApplication.Data.generateNewRow("UserActivityLog");

	LogXML.loadXML(objApplication.Data.convertToCollection(objNode).xml());

	objLog = LogXML.selectSingleNode("/useractivitylogs/useractivitylog");

	if (objLog == null)
		return;

	objLog.selectSingleNode("efacsappid/value").setText(appID);
	objLog.selectSingleNode("efacsmenuid/value").setText(menuID);
	
	var objEfacsCalendar=objApplication.getCalendarParser();
	objLog.selectSingleNode("startdate/value").setText(objEfacsCalendar.getDateTimeInISO());
		
	var strSaveXML = objApplication.Data.prepareForSave(objLog);


	objRPC.execute("Save", objApplication.Connection.strConnectionString, strSaveXML);
	LogXML = objRPC.getReturnedXMLDom();

	if (objRPC.FAILED)
		return;
	
	return Number(LogXML.selectSingleNode("/useractivitylogs/useractivitylog/lognumber/value").getText());
}

function updateLog(logNumber)
{
	objApplication.updateLog(logNumber);
}

function UTCToTimestamp(strUTCDate)
{
    var defDay = "";
    var defMonth = "";
    var defYear = "";
    var defHour = "";
    var defMin = "";
    var defSec = "";
    
    defYear = strUTCDate.substring(0, 4);
    defMonth = strUTCDate.substring(5, 7);
    defDay = strUTCDate.substring(8, 10);
    defHour = strUTCDate.substring(11, 13);
    defMin = strUTCDate.substring(14, 16);
    defSec = strUTCDate.substring(17, 19);
    
    return defYear + "-" + defMonth + "-" + defDay + " " + defHour + ":" + defMin + ":" + defSec + ".0";
}

function UTCToDatestamp(strUTCDate)
{
    var defDay = "";
    var defMonth = "";
    var defYear = "";
    
    defYear = strUTCDate.substring(0, 4);
    defMonth = strUTCDate.substring(5, 7);
    defDay = strUTCDate.substring(8, 10);
    
    return defYear + "-" + defMonth + "-" + defDay;
}

function isHTMLElementVisible(objHTMLElement)
{
	// REVIEW If objHTMLElement is null then it can't be visible.  Ideally need to find out why it is null.
	if (objHTMLElement == null)
		return false;
		
	// Check to see if this element any parent containers are hidden.
	for (var objElement = objHTMLElement; objElement.parentNode != null && objElement.parentNode != objElement.parentNode.parentNode; objElement = objElement.parentNode)
	{
		if (objApplication.browser == APPLICATION_IE) {
		if (objElement.currentStyle.display == "none" || objElement.currentStyle.visibility == "hidden")
			return false;
		}
	}
	
	return true;
}

function getEfacsApplet()
{
	var objTopWindow = window;

	if (window.dialogArguments != null && window.dialogArguments != undefined)
		objTopWindow = window.dialogArguments[modal_WINDOW];	

	for (var objWindow = objTopWindow.parent; objWindow != null; objWindow = objWindow.opener)
	{
		objTopWindow = objWindow;

		if (objWindow.dialogArguments != null && objWindow.dialogArguments != undefined)
		{
			objTopWindow = objWindow.dialogArguments[modal_WINDOW];
			objWindow = objTopWindow;
		}

		var objApplet = objTopWindow.document.getElementById(objApplication ? (objApplication.browser == APPLICATION_IE ? "EfacsApplet" : "EfacsAppletNN") : (navigator.appName == "Netscape" ? "EfacsAppletNN" : "EfacsApplet"))
		if (objApplet != null)
			return objApplet;

		// Now try iFrames too.		
		if (objTopWindow.opener == null && objTopWindow.parent != objTopWindow)
		{
			objTopWindow = objTopWindow.parent;
			objWindow = objTopWindow;
			var objApplet = objTopWindow.document.getElementById(objApplication ? (objApplication.browser == APPLICATION_IE ? "EfacsApplet" : "EfacsAppletNN") : (navigator.appName == "Netscape" ? "EfacsAppletNN" : "EfacsApplet"))
			if (objApplet != null)
				return objApplet;
		}
	}

	return objTopWindow.top.document.getElementById(objApplication ? (objApplication.browser == APPLICATION_IE ? "EfacsApplet" : "EfacsAppletNN") : (navigator.appName == "Netscape" ? "EfacsAppletNN" : "EfacsApplet"));
}

/**
 * Gets the top most window - usually EFACS Menu.
 *
 * @return The top most EFACS window.
 */
function getTopWindow()
{
	var objTopWindow = window;

	if (window.dialogArguments != null && window.dialogArguments != undefined)
		objTopWindow = window.dialogArguments[modal_WINDOW];	

	for (var objWindow = objTopWindow.parent; objWindow != null; objWindow = objWindow.opener)
	{
		objTopWindow = objWindow;

		if (objWindow.dialogArguments != null && objWindow.dialogArguments != undefined)
		{
			objTopWindow = objWindow.dialogArguments[modal_WINDOW];
			objWindow = objTopWindow;
		}

		var objApplet = objTopWindow.document.getElementById(objApplication ? (objApplication.browser == APPLICATION_IE ? "EfacsApplet" : "EfacsAppletNN") : (navigator.appName == "Netscape" ? "EfacsAppletNN" : "EfacsApplet"))
		if (objApplet != null)
			return objTopWindow;
	}

	return objTopWindow.top;
}

/**
 * Launch the call manager
 * The option buttons onclick does not like brackets and so we have to call via this method.
 */
function fireCTICallManager(args) {
	getCTIObject().launchCTICallManager(args);
}

/**
 * Return the CTI object that resides in appMenu.
 * For the Emerald menu the CTI object is instantiated in the menu itself.
 * For Sapphire though this is not the case and so we need to do it here.
 */
function getCTIObject() {
	if (m_CTIObject == null) {
		m_CTIObject = getTopWindow().objCTI;
	}
	
	if (m_CTIObject == undefined) {
		/*
		 * Must be using the Sapphire menu.
		 * Still need to instantiate the object though as it is used for certain Form set-up logic
		 */
		m_CTIObject = new CTIUtility();
	}
	
	return m_CTIObject;
}

/**
 * Returns the global functional test object declared on the menu.
 *
 * @return The functional test object.
 */
function getFunctionalTestObject()
{
	var objTopWindow = window;

	if (window.dialogArguments != null && window.dialogArguments != undefined)
		objTopWindow = window.dialogArguments[modal_WINDOW];	

	for (var objWindow = objTopWindow.parent; objWindow != null; objWindow = objWindow.opener)
	{
		objTopWindow = objWindow;

		if (objWindow.dialogArguments != null && objWindow.dialogArguments != undefined)
		{
			objTopWindow = objWindow.dialogArguments[modal_WINDOW];
			objWindow = objTopWindow;
		}

		var objApplet = objTopWindow.document.getElementById(objApplication ? (objApplication.browser == APPLICATION_IE ? "EfacsApplet" : "EfacsAppletNN") : (navigator.appName == "Netscape" ? "EfacsAppletNN" : "EfacsApplet"))
		if (objApplet != null)
			return objTopWindow.m_objFunctionalTest;
	}

	return objTopWindow.top.m_objFunctionalTest;
}

function getReverseVideoColour(strHexValue)
{
	var redOrig = Number("0x" + String(strHexValue).substring(1, 3));
	var red = ~redOrig & 0xFF;
	var greenOrig = Number("0x" + String(strHexValue).substring(3, 5));
	var green = ~greenOrig & 0xFF;
	var blueOrig = Number("0x" + String(strHexValue).substring(5, 7));
	var blue = ~blueOrig & 0xFF;
	
	if ((redOrig - red) < 10 && (redOrig - red) > -10) {
		red = 127 + (redOrig/2);
	}
	if ((greenOrig - green) < 10 && (greenOrig - green) > -10) {
		green = 127 + (greenOrig/2);
	}
	if ((blueOrig - blue) < 10 && (blueOrig - blue) > -10) {
		blue = 127 + (blueOrig/2);
	}
	
	var redStr = addStringPadding(getHexString(red), "0", 2);
	var greenStr = addStringPadding(getHexString(green), "0", 2);
	var blueStr = addStringPadding(getHexString(blue), "0", 2);
	
	return "#" + redStr + greenStr + blueStr;
}

function getHexString(intNumber) 
{
	var strRetVal = "";
	var charByte;
	var intRemainingNumber = intNumber;

	do {
		charByte = intRemainingNumber & 0xF;

		if (charByte < 10)
			strRetVal = charByte + strRetVal;
		else if (charByte == 10)
			strRetVal = "A" + strRetVal;
		else if (charByte == 11)
			strRetVal = "B" + strRetVal;
		else if (charByte == 12)
			strRetVal = "C" + strRetVal;
		else if (charByte == 13)
			strRetVal = "D" + strRetVal;
		else if (charByte == 14)
			strRetVal = "E" + strRetVal;
		else if (charByte == 15)
			strRetVal = "F" + strRetVal;

		intRemainingNumber = intRemainingNumber >> 4;
	} while (intRemainingNumber > 0);
	
	return strRetVal;
}

function addStringPadding(strInputString, strPaddingCharacter, intLength)
{
	var strOutputString = String(strInputString);
	
	while(strOutputString.length < intLength) {
		strOutputString = strPaddingCharacter + strOutputString;
	}
	return strOutputString;
}

function getMasterDataSource()
{
	var masterDataSource;
	var objXML = objApplication.createXMLDocument();
	objXML.loadURL("../../../efacsmaster/xmlProductDetails.xml", window.document.URL);

	masterDataSource = objXML.documentElement().selectSingleNode("content/product-details/master-datasource").getText();

	objXML = null;

	return masterDataSource;
}

function getWebComponentsPath()
{
	var objRPC = new RPCObject("Company");
	objRPC.execute("load", objApplication.Connection.strConnectionString, objApplication.User.company);
	var objXML = objRPC.getReturnedXMLDom();
	
	return objXML.selectSingleNode("//webcomponentspath/value").getText()
}

function getProxyServer()
{
	var objRPC = new RPCObject("Company");
	
	objRPC.execute("load", objApplication.Connection.strConnectionString, objApplication.User.company);

	var objXML = objRPC.getReturnedXMLDom();
	
	var strProxyServer = objXML.selectSingleNode("//proxyserver/value").getText();
	var strProxyPort = objXML.selectSingleNode("//proxyport/value").getText();

	if (!isBlank(strProxyPort))
		return strProxyServer + ":" + strProxyPort;
	else
		return strProxyServer;
}

/**
 * Left pads the passed value with the passed character.
 * 
 * @param value The value to be left padded.
 * @param numDigits The number of characters to left pad to the value.
 * @param strChar The character with which to pad.
 * @return The left padded string.
 */
function leftPadWithChar(value, numDigits, strChar)
{
	var strLen = String(value).length;
	for (var intCtr = strLen; intCtr < numDigits; intCtr++)
		value = strChar + String(value);
	
	return value;
}

/**
 * Modifies the supplied string escaping all backslash characters
 * @param strValue The string to be parsed
 * @return String The escaped string
 */
function EscapeStringBackslash(strValue) {
	if (typeof(strValue) != "string")
		return strValue;
		
	var regExp	= /\\/g;
	var escapedString = strValue.replace(regExp, "\\\\");
  
	return escapedString;
}

/**
 * Modifies the supplied string escaping all single quote characters
 * @param strValue The string to be parsed
 * @return String The escaped string
 */
function EscapeStringSinglequote(strValue) {
	if (typeof(strValue) != "string")
		return strValue;
		
	var regExp = /'/g;
	var escapedString = strValue.replace(regExp, "\\'")

	return escapedString;
}

/**
 * Modifies the supplied string escaping all double quote characters
 * @param strValue The string to be parsed
 * @return String The escaped string
 */
function EscapeStringDoublequote(strValue) {
	if (typeof(strValue) != "string")
		return strValue;
		
	var regExp = /"/g;
	var escapedString = strValue.replace(regExp, "\\\"")

	return escapedString;
}

/**
 * Displays EFACS errors in a user friendly way.
 * Instantiates a new EfacsError object (ssEfacsError.xml prepares the error object) displays
 * it determined by the passed flag. Always displays if error caused by application server
 * not running issues.
 * 
 * @param objError Could be a real javascript error object or a string of error XML from dataengine.
 * @param objWindow Reference to the window that had the error.
 * @param flgDisplayMessage If not false then user is given a message box containing user friendly error.
 */
function showEfacsError(objError, objWindow, flgDisplayMessage) 
{
	var objEfacsError = new EfacsError(objError, objWindow);
	
	if (flgDisplayMessage || objEfacsError.appServerNotRunning)
		objEfacsError.showError();
}

/**
 * Checks whether the parameter is a valid number
 * @param strValue The value being tested to see if it is a number
 * @return a boolean True if the parameter is a number, otherwise false.
 */
function isValidNumber (strValue) {

	if (isBlank(strValue) || isNaN(strValue * strValue))
		return false;

	return true;
}

/**
 * Copies one objects properties to another object.
 * Uses a for...in loop to copy the properties to the destination object.
 *
 * @param objSource The source object from which the properties will be copied.
 * @param objDestination The destination object to which the properties will be copied.
 */
function copyObject(objSource, objDestination)
{
	for (var i in objSource)
	{
		objDestination[i] = objSource[i];
	}
}

/**
 * Use when objApplication cannot be relied upon to get the current browser.
 * @return The current browser.
 */
function getCurrentBrowser()
{
	if (currentBrowser == null) {
		currentBrowser = navigator.appName == "Microsoft Internet Explorer" ? APPLICATION_IE : APPLICATION_NN;
	}
	return currentBrowser;
}

/**
 *	fires the DatePicker window.
 *	@param source - The object that the DatePicker is fired from.
 *	@param strFieldId - The form field ID that will receive the selected date.
 *	@param strFormId - The form ID that the DatePicker is fired from.
 */
function util_fireDatePicker(source, strFieldId, strFormId)
{
	var objDatePicker = source.document.getElementById("ctlDatePicker");

	if (objDatePicker.src == "")
	{
		objDatePicker.src = "../Applications_HTML/appDateTimePicker.html?mobile=" + objApplication.bMobile;

		if (objApplication.bMobile == true)
		{
			objDatePicker.style.height = "280";
			objDatePicker.style.width = "240";
		}
		else
		{
			objDatePicker.style.height = "262";
			objDatePicker.style.width = "170";
		}
	}

	objDatePicker.style.display = "inline";
	util_positionDatePicker(getOffsetLeftFromElement(source, "mainBodyTag"), getOffsetTopFromElement(source, "mainBodyTag"), objDatePicker);
	util_setDefaultDatePickerContent(strFieldId, strFormId);
}
	
/**
 *	Positions the DatePicker window relative to the object that fired it.
 *	@param x - x coordinate for the DatePicker.
 *	@param y - y coordinate for the DatePicker.
 *	@param objDatePicker - The DatePicker object
 */
function util_positionDatePicker(x, y, objDatePicker) 
{
	var objControl = objDatePicker;

	objControl.style.top = y;
	objControl.style.left = x;
}

/**
 *	Sets the defaults for the DatePicker object.
 *	@param strFieldId - The form field ID to receive the selected Date.
 *	@param strFormId - The form ID that fired the DatePicker.
 */
function util_setDefaultDatePickerContent(strFieldId, strFormId)
{
	var objForm;
	for (var intCtr = 0; intCtr < objApplication.arrForms.length; intCtr++)
	{
		objForm = objApplication.arrForms[intCtr];
		if (objForm.id == strFormId && objForm.objWindow.name == window.name)
			break;
	}

	var objField = objForm.getFieldByRef(strFieldId);
	
	if (objApplication.hadCriticalError)
		return;

	var frame = window.frames["ctlDatePicker"]

	if (frame.m_flgInitialised != true)
		setTimeout("util_setDefaultDatePickerContent('" + strFieldId + "', '" + strFormId + "')", 10);
	else
	{		
		frame.setFieldRef(objField);
			
		if (objApplication.hadCriticalError)
		{
			window.close();
			return;
		}

		frame.setDate();

		frame.document.getElementById("btnOK").focus();
	}
}

/**
 * Returns emerald Toolbar button class from passed HTML button element.
 *
 * @param objButton The HTML element.
 * @param objWindow The window object on which the button exists.
 * @return The Toolbar object.
 */
function util_getToolbarFromButton(objButton, objWindow)
{
	var objToolbar;
	var objTable = getParentElement(objButton, "TABLE");
	
	if (objTable != null && objTable.className == "ToolbarTable")
		objToolbar = objWindow[objTable.id.replace("tlb", "")];

	return objToolbar;
}

/**
 * Returns a new array which consists of the passed
 * array elements placed in a random order.
 *
 * @param arrList The array to randomize.
 * @return The randomized array.
 */
function util_randomizeArray(arrList)
{
	var arrNewList = new Array();
	
	var intListCount = arrList.length;
	
	for (var intCtr = 0; intCtr < intListCount; intCtr++)
	{
		for ( ; ; )
		{
			intRand = Math.round(arrList.length * Math.random());
			
			if (arrList[intRand] != null)
			{
				arrNewList[intCtr] = arrList[intRand];
				arrList[intRand] = null;
				break;
			}

		}
	}
	
	return arrNewList;
}


/**
 * Converts hex value to red part of r,g,b value..
 *
 * @param h Hex string value;
 * @return Red part of r,g,b value.
 */
function util_HexToR(h)
{
	return parseInt((util_cutHex(h)).substring(0,2),16);
}

/**
 * Converts hex value to green part of r,g,b value..
 *
 * @param h Hex string value;
 * @return Green part of r,g,b value.
 */
function util_HexToG(h)
{
	return parseInt((util_cutHex(h)).substring(2,4),16);
}

/**
 * Converts hex value to blue part of r,g,b value..
 *
 * @param h Hex string value;
 * @return Blue part of r,g,b value.
 */
function util_HexToB(h)
{
	return parseInt((util_cutHex(h)).substring(4,6),16);
}

/**
 * Strips hash (if present) from hex string.
 *
 * @param h Hex string value;
 * @return Hex string value with hash stripped off.
 */
function util_cutHex(h)
{
	if (h.charAt(0) == "#")
		return h.substring(1,7);
	else
		return h;
}

/**
 * util_roundToDP
 * @param value - The value to be rounded.
 * @param decimal_places - Number of decimal places to round to.
 *
 * Round the passed value to the specified nummber of decimal places.
 * Calculation rounds halves up (ROUND_HALF_UP) rather than using 
 * the ROUND_EVEN_UP which numberformatter uses.
 */
function util_roundToDP(value, decimal_places) {
    value = value * Math.pow(10, decimal_places)
    value = Math.round(value)
    value = value / Math.pow(10, decimal_places)
    return value;
}

/**
 * Clears down server cache of all transformed forms.
 */
function util_clearFormsCache()
{
	var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/servlet/FormProcessorServlet?clearCache=true";
	objApplication.EfacsApplet.post(strURL, "");
}

/** 
 * Trim a passed string of white space at the beginning and end
 * @param strObject String to trim
 * @return Trimmed String
 */
function util_trim(strObject) {
  strObject=strObject.replace(/^\s*(.*)/, "$1");
  strObject=strObject.replace(/(.*?)\s*$/, "$1");
  return strObject;
}

/**
 * Remove white space from the passed string
 * @param str String to parse
 * @return string minus any white space
 */
function util_removeWhiteSpace(str) {
	str=str.replace(/ /g, "");
	str=str.replace(/	/g, "");
	return str;
}

/** 
 * Ensures that only a string is passed to parseNumber as when running in foreign locales the 
 * decimal point is stripped from the Number causing errors in conversion
 * @param objNumber - this could be a String or a Number
 * @return String the number in UK locale format
 */
function util_parseNumber(objNumber) {
	var strNumber=String(objNumber);
	if (isBlank(strNumber))
		return "";

	return objApplication.getNumberFormatter().getNumber(strNumber);
}

/** 
 * Ensures that only a string is passed to getLocaleNumber as when running in foreign locales the 
 * decimal point is stripped from Number variables causing errors in conversion
 * @param objNumber - this could be a String or a Number
 * @param intDigitsAfter - the number of decimal places
 * @return String the number in UK locale format
 */
function util_localeNumber(objNumber, intDigitsAfter) {
	var strNumber=String(objNumber);
	if (isBlank(strNumber))
		return "";
		
	if (intDigitsAfter == null)
		return objApplication.getNumberFormatter().getLocaleNumber(strNumber);
	else 		
		return objApplication.getNumberFormatter().getLocaleNumber(strNumber, String (intDigitsAfter));
}

/**
 * Converts a javascript date into ISO format.
 * Should only be used internally and not in applications.
 *
 * @param dateIn The input javascript date.
 * @param returnBlankIfInvalid State whether a blank should be returned if date cannot be parsed.
 * @return The ISO formatted date.
 */
function UTCToISODate(dateIn, returnBlankIfInvalid) {

	// MCB - HACK to allow users to enter dates in format dd/mm/yyyy 
	// - change to mm/dd/yyyy to account for bug in javascript Date object failing to pick up British locale.
	if (objApplication.User.language.toLowerCase() == "gbr")

	{
		var arrVals = String(dateIn).split("/");
		if (arrVals.length == 3 && dateIn.length < 11)
		{
			// If year is 2 digits then convert to 4 digits using CENTURYYEAR system parameter.
			if (arrVals[2].length == 2)
			{
				var objCenturyYear = objApplication.Data.getSystemParameter("CENTURYYEAR");
				if (Number(arrVals[2]) > Number(objCenturyYear.selectSingleNode("spvalue/value").getText()))
					arrVals[2] = "19" + arrVals[2];
				else
					arrVals[2] = "20" + arrVals[2];
			}
			dateIn = arrVals[1] + "/" + arrVals[0] + "/" + arrVals[2];
		} 
		else if (arrVals.length == 3 && dateIn.length < 20)
		{
			// If year is 2 digits then convert to 4 digits using CENTURYYEAR system parameter.
			var arrYearAndTime = arrVals[2].split(" ");
			if (arrYearAndTime[0].length == 2)
			{
				var objCenturyYear = objApplication.Data.getSystemParameter("CENTURYYEAR");
				if (Number(arrYearAndTime[0]) > Number(objCenturyYear.selectSingleNode("spvalue/value").getText()))
					arrYearAndTime[0] = "19" + arrYearAndTime[0];
				else
					arrYearAndTime[0] = "20" + arrYearAndTime[0];
			}
			dateIn = arrVals[1] + "/" + arrVals[0] + "/" + arrYearAndTime[0] + " " + arrYearAndTime[1];
		}
	}
	
	var CurDat = new Date(dateIn);
	if (isNaN(CurDat))
	{
		try {
			if (!isBlank (dateIn)) { 
				var objDate = objApplication.getDateParser().parse(dateIn);
			} else {
				var objDate=objApplication.getDateParser().parseMillis (Number(new Date().valueOf()));
			}
			CurDat = new Date (objDate.getTime());
		} catch (error) {
			CurDat = null;
		}

		// if its not an ISO date and it isnt a java/javascript date object either
		if (CurDat==null || typeof(CurDat.setMinutes) == "undefined") {
			if (returnBlankIfInvalid == true)
				return "";
			else
				return dateIn;
		}
	}
		
	var MM = CurDat.getMonth() + 1;
	MM = "0" + MM;
	var DD = "0" + CurDat.getDate();

	// If no time has been passed then default time to 12:00 hours.
	if (String(dateIn).indexOf(":") == -1 && CurDat.getHours() == 0)
		var hh = "012";
	else
		var hh = "0" + CurDat.getHours();

	var mm = "0" + CurDat.getMinutes();
	var ss = "0" + CurDat.getSeconds();

	var retVal = CurDat.getFullYear() + "-" + MM.substring(MM.length-2) +
	"-" + DD.substring(DD.length-2) + "T" + hh.substring(hh.length-2) +
	":" + mm.substring(mm.length-2) + ":" + ss.substring(ss.length-2) + "Z";
	
	return retVal;
}

/*
 * compareDouble(double1, double2)
 *
 * checks which double is greater
 *
 * @param  double1
 * @param  double2
 * @return int       1 if double1 is greater, -1 if double2 is greater, 0 if both doubles are within tolerance
 *
 */
function compareDouble(double1, double2) {
	if (Number(double1) == Number(double2))
		return 0;	
	else if ((Number(double1) - GENUTIL_DOUBLETOLERANCE) > double2)
		return 1;
	else if ((Number(double1) + GENUTIL_DOUBLETOLERANCE) < double2)
		return -1;
	else
		return 0;
}

/**
 * Utility for printing out debug to the console from script.
 * Handy for when cannot use debugger (which can effect events)
 */
function pdebug(message) {
	objApplication.EfacsApplet.pdebug(message);
}

/**
 * Modifies the supplied string escaping all double blank spaces
 * @param strValue The string to be parsed
 * @return String The escaped string
 */
function escapeStringDoubleSpaces(strValue) {
	if (typeof(strValue) != "string")
		return strValue;
		
	var regEx = /  /g;
	var escapedString = strValue.replace(regEx, "&nbsp;&nbsp;")

	return escapedString;
}

	

// ADAPT constants.
var ADAPT_ONROWCLICK = 0x1;
var ADAPT_ONROWDBLCLICK = 0x2;
var ADAPT_ONBEGINROWEDIT = 0x4;

var m_objResizeObject = null;
var m_objMouseClickElement = null;
var m_blnDescend = false;

var m_strRowHighlightedColour = "";
var m_strRowSelectedColour = "";
var m_strRowSelectedTextColour = "";
var m_strGridDataToTableDataXSL = "../XSLT/xsltTransformNewGridDataToTableData.xslt";
var m_strBusDataToGridDataXSL = "../XSLT/xsltTransformBusinessDataToGridData.xslt";

// Global reference to the current editable grid (if any).
var m_objEditableGrid;

//--------------------------------------------------------------------------------
// Main constructor for "Grid" object
// Passed argument 'objElement' is reference to HTML container that holds the grid
// (normally the "GRID" element)

function Grid(objElement, strSelectType, strSortable, strAutoResize, strOnRowSelect, strOnRowDblClick, strOnColumnResize, objAppWindow) {

	this.DOM					= null;			// Contains reference to application's data
	this.objAppWindow			= objAppWindow;
	this.objGridEdit			= null;
	this.objEditFormXML			= null;

	this.objGridHeadingsXML		= null;			// Reference to grid's headings
	this.objGridDataXML			= null;

	this.objAppData				= null;
	this.overrideSort			= null;

	this.HTMLdiv				= objElement;		// HTML container that contains the grid
	this.setHeight				= et_setHeight;
	this.setWidth				= et_setWidth;

	this.id 					= objElement.id.replace("grd", "");  // Setup a quick reference to this grid objects ID.
	this.strSrc					= null;
	this.strVersion				= null;
	this.strRevision			= null;
	this.strModified			= null;
	this.hasTitle				= false;

	this.HTMLtable				= null;			// HTML TABLE.

	this.loadSettingsFromFile	= et_loadSettingsFromFile;

	// See if there is a select type - if not set default (values are 'single', 'none' or 'multiple' - default = 'multiple').
	if (strSelectType == "")
		this.selectType			= "multiple";
	else
		this.selectType			= strSelectType;
	this.sortable				= strSortable;
	this.autoResize				= strAutoResize;
	this.onRowSelect			= strOnRowSelect;
	this.onRowDblClick			= strOnRowDblClick;
	this.onDelKeyPressed		= null;
	this.onColumnResize			= strOnColumnResize;
	this.onmouseover			= null;	
	this.onmouseout				= null;	
	this.isEditable				= false;
	this.onchange				= null;
	this.onblur					= null;
	this.isTreeGrid				= false;
	this.isListPicker			= false;
	this.Tree					= null;
	this.stretchLastColumn		= false;
	this.arrRules				= new Array();
	
	this.addHeading				= et_addHeading;
	this.removeHeading 			= et_removeHeading;
	this.removeAllHeadings		= et_removeAllHeadings;
	this.showColumn				= et_showColumn;
	this.hideColumn 			= et_hideColumn;

	this.DataEngine				= null;
	this.setupWithDataEngine	= et_setupWithDataEngine;
	this.setup					= et_setup;
	this.toXML					= et_toXML;

	// Synchronize with application data
	this.strXPath				= null;
	this.strCollectionName		= null;
	this.strRecordName			= null;

	this.populateGrid			= et_populateGrid;		// Populate grid from header and data islands.
	this.clear					= et_clear;				// Empty the grid's contents

	this.getColumnValue			= et_getColumnValue;	// Returns the value for the passed column name and uniqueid.
	this.setColumnValue			= et_setColumnValue;
	this.setTreeColumnValue 	= et_setTreeColumnValue;
	this.getSelectedColumnValue = et_getSelectedColumnValue;  // Returns an array of passed column name values for all selected rows.
	this.getSelectedColumnValueByIndex = et_getSelectedColumnValueByIndex;  // Returns an array of passed column name values for all selected rows.
	this.setColumnOnClick		= et_setColumnOnClick;

	this.selectAllRows			= et_selectAllRows;		// highlighs all rows in the grid.
	this.deselectAllRows		= et_deselectAllRows;	// unhighlights all rows in the grid.
	this.selectRow				= et_selectRow;			// highlighs and selects the row with passed unique id.
	this.selectRowIndex			= et_selectRowIndex;	// highlighs and selects the row with passed row index.
	this.selectTopRow			= et_selectTopRow;		// highlighs and selects the top row in the grid.
	this.highlightRow			= et_highlightRow;		// highlighs the row with passed unique id.
	this.updateRow				= et_updateRow;
	this.insertRow				= et_insertRow;
	this.deleteRow				= et_deleteRow;
	this.setRowState			= et_setRowState;		// hidden or visible.
	this.getRowState			= et_getRowState;		// hidden or visible.
	this.resynchronizeUniqueIDs = et_resynchronizeUniqueIDs;
	this.focusRow				= et_focusRow;
	this.blurRow				= et_blurRow;
	this.scrollIntoView			= true;
	this.setupTableHeadings		= et_setupTableHeadings;

	this.hide					= et_hide;
	this.show					= et_show;
	this.isVisible				= et_isVisible;

	this.grdSplitterBar			= objAppWindow.document.createElement("div");
	this.grdSplitterBar.style.display = "none";
	objAppWindow.document.body.appendChild(this.grdSplitterBar);
	
	this.keyboardRowPointer		= 0;

	this.arrContextOptions		= new Array();
	this.addContextMenuOption	= et_addContextMenuOption;

	this.getRowIndex			= et_getRowIndex;
	this.getRowCount			= et_getRowCount;

	this.getColumnCellIndex		= et_getColumnCellIndex; 
	this.getColumnValues		= et_getColumnValues; // Returns an array of all the values for the specified column
	this.getMatchedRows			= et_getMatchedRows; // Returns an array of Row objects that match the supplied criteria
	this.getRows				= et_getRows;	
	this.getRow					= et_getRow;	
	this.swapRows				= et_swapRows;	
	this.getMaxUniqueID			= et_getMaxUniqueID;

	this.fireInfoPanel			= et_fireInfoPanel;
	this.performADAPTScript		= et_performADAPTScript;

	this.setRule				= et_setRule;
	this.applyAllRules			= et_applyAllRules;
	this.applyRule				= et_applyRule;
	this.processAllRules			= et_processAllRules;
	this.processRule			= et_processRule;
	this.removeRule				= et_removeRule;
	this.toggleRule				= et_toggleRule;
	this.addNewRule				= et_addNewRule;
	this.getRuleRows			= et_getRuleRows;
	this.getAllRules			= et_getAllRules;
	this.setColumnValues		= et_setColumnValues;
	this.disableColumn			= et_disableColumn;
	this.validateAllRows		= et_validateAllRows;
	this.sortByColumn			= et_sortByColumn;
	
	this.arrSelectedRows		= new Array();
	this.validate				= et_validate;
	this.beginRowEdit			= et_beginRowEdit;
	this.triggerAction          = et_triggerAction;
	this.disableCell			= et_disableCell;
	this.setLabelText			= et_setLabelText;
	this.attachGridEvents 		= et_attachGridEvents;
	this.destroy				= et_destroy;
	this.onRightClick			= null;
}

/** 
 * Used by ADAPT - returns an tree formatted xml representation of this object.
 *
 * @return The tree formatted xml representation of this object.
 */
function et_toXML()
{
	var strUID = this.strSrc.replace("../Grids/", "").replace(".xml", "");
	
	var strXML = "<node uid='" + this.id + "' level='3'>";
	strXML += "<vals>";
	strXML += "<val id='label'>" + this.id + "</val>";
	strXML += "<val id='name'>" + strUID + "</val>";
	strXML += "<val id='event1' parameter-name='objGrid'>onRowClick</val>";
	strXML += "<val id='event2' parameter-name='objGrid'>onRowDblClick</val>";
	strXML += "<val id='event3' parameter-name='objGrid'>onBeginRowEdit</val>";
	strXML += "</vals>";
	strXML += "</node>";

	return strXML;
}

/** Format the data in the grid
 * @param objHeadingNode The heading node from the table head
 * @param strColumnValue The value in this column to be formatted
 * @return the formatted data
 */
function et_formatGridData(objHeadingNode, strColumnValue)
{

	if (objHeadingNode.getAttribute("datatype") == "xsd:dateTime") {
		if (isISODate(strColumnValue)) {
			var objEfacsCalendar=objApplication.getCalendarParser()
			objEfacsCalendar.setDateTimeInISO (strColumnValue);

			if (objHeadingNode.getAttribute("date-time-format") == null)				
				return objEfacsCalendar.getDateInLocaleFormat();
			else			
				return objEfacsCalendar.getDateTimeInLocaleFormat();
		} else 
			return strColumnValue;	
	}
	else
		return escapeXML(String(strColumnValue));
}

/**
 * Empty the contents of the grid
 * @param flgClearRules Whether the rules should be reset.  Defaults to true if 
 *        no parameter passed.
 */
function et_clear(flgClearRules)
{
	if (flgClearRules != false)
		flgClearRules = true;
		
	this.objGridDataXML = objApplication.createXMLDocument("<grid />");
	this.setupTableHeadings();
	this.arrSelectedRows = new Array();

	if (flgClearRules) {
		this.arrRules = new Array();
	
		if (this.objGridEdit != null && this.objGridEdit.objForm != null)
			this.objGridEdit.objForm = null;
	}
}

/** Load grid settings from file to get things like version numbers
 * @param strPath Relative URL for grid file
 */
function et_loadSettingsFromFile(strPath) 
{
	var objXML = objApplication.createXMLDocument();
	objXML.loadURL(strPath);
	
	if (isBlank(objXML.xml()))
	{
		var strError = "Grid file missing or failed to load '" + strPath + "'.  Application will close.";
		eMsgBox(strError, 0, msg_Critical, this.objAppWindow);
		objApplication.hadCriticalError = true;
		objApplication.closeApplication();
		return;
	}
	
	this.strVersion = objXML.selectSingleNode("/evc:component/version").getAttribute("id");
	this.strRevision = objXML.selectSingleNode("/evc:component/source-details/revision-control").getAttribute("revision");
	this.strModified = objXML.selectSingleNode("/evc:component/source-details/revision-control").getAttribute("last-modified");
	
	objXML.loadXML(objXML.selectSingleNode("/evc:component/content/grid").xml());
	objXML.documentElement().setAttribute("id", this.id);
	this.objGridHeadingsXML = objXML;

	this.setupTableHeadings();
}

/** Remove a grid heading
 * @param strRef The ref of the column to remove
 */
function et_removeHeading(strRef)
{
	var objXML = this.objGridHeadingsXML;
	var objNode = objXML.selectSingleNode("/grid/column[@ref='" + strRef + "']");

	if (objNode != null)
		objXML.documentElement().removeChild(objNode);

	this.setupTableHeadings();
}

/** Make this into an empty grid with no columns
 */
function et_removeAllHeadings(){
	this.objGridHeadingsXML.loadXML("<grid />");
	this.setupTableHeadings();
}

/** Add a column
 * @param strRef Column reference
 * @param strHidden Is the column hidden
 * @param strDataType The data type
 * @param strCols The width of the column
 * @param strCaption The caption
 * @param strPrePoint The number of digits before the point
 * @param strProPoint The number of digits after the point
 * @param strEditable Is it editable
 * @param strYesNo Is it yes no
 * @param strDateFormat Is it date format
 * @param strFormat The format specifier
 * @param strDateTimeFormat Is it date time format
 */
function et_addHeading(strRef, strHidden, strDataType, strCols, strCaption, strPrePoint, strProPoint, strEditable, strYesNo, strDateFormat, strFormat, strDateTimeFormat) {
	var objXML;
	var strXML;
	var objNode;

	objXML = this.objGridHeadingsXML;

	if (!objXML)
	{
		objXML = objApplication.createXMLDocument();
		objXML.loadXML("<grid id='" + this.id + "' />");

		this.objGridHeadingsXML = objXML;
	}
	objNode = objXML.createElement("column");

	if (strRef != null && strRef != "")
		objNode.setAttribute("ref", strRef);
	if (strHidden != null && strHidden != "")
		objNode.setAttribute("hidden", strHidden);
	if (strDataType != null && strDataType != "")
		objNode.setAttribute("datatype", strDataType);
	if (strCols != null && strCols != "")
		objNode.setAttribute("cols", strCols);
	if (strEditable != null && strEditable != "")
		objNode.setAttribute("editable", strEditable);
	if (strYesNo != null && strYesNo != "")
		objNode.setAttribute("yesno", strYesNo);
	if (strDateFormat != null && strDateFormat != "")
		objNode.setAttribute("date-format", strDateFormat);
	if (strDateTimeFormat != null && strDateTimeFormat != "")
		objNode.setAttribute("date-time-format", strDateTimeFormat);
	if (strFormat != null && strFormat != "")
		objNode.setAttribute("format", strFormat);

	if (strPrePoint != null && strPrePoint != "")
		objNode.setAttribute("digits-before-point", strPrePoint);
	if (strProPoint != null && strProPoint != "")
		objNode.setAttribute("digits-after-point", strProPoint);

	objXML.documentElement().appendChild(objNode);

	objNode = objXML.createElement("caption");
	objNode.setText(strCaption);
	objXML.selectSingleNode("/grid/column[@ref='" + strRef + "']").appendChild(objNode);
}

// Returns a reference to the current Grid object. Passed the event element from the HTML table.
function et_getGridObject(evtSrcElement) {
	var strID = getParentElement(evtSrcElement, "table").id.replace("et_grd", "");
	return window[strID];
}

/****************************************
 Functions relating to building the table
*****************************************/

// Transform the xmlheadings to the table head.
function et_setupTableHeadings()
{
	if (this.objGridEdit != null && this.objGridEdit.objForm != null)
		this.objGridEdit.hide();

	if (this.objGridHeadingsXML == null)
	{
		this.objGridHeadingsXML = objApplication.createXMLDocument();
		this.objGridHeadingsXML.loadXML("<grid id='" + this.id + "' />");
	}
	this.HTMLdiv.innerHTML = et_getTableTAGString(this) + et_getTableHeadingString(this) + "<tbody></tbody></table>";

	this.HTMLtable = this.objAppWindow.document.getElementById("et_" + this.HTMLdiv.id);

	if (this.objGridEdit != null)
		this.HTMLdiv.style.backgroundColor = "#d9e2e8";

	// Restore grid column sizes.
	et_setPersistedColumnWidths(this);
	// Attach mouse click events to various parts of the table.
	this.attachGridEvents();
}

// Transform the xmlheadings to the table head.
// Transform the xml data island to the table body.
function et_populateGrid()
{
	if (this.objGridEdit != null && this.objGridEdit.objForm != null)
		this.objGridEdit.hide();

	this.HTMLdiv.innerHTML = et_getTableTAGString(this) + et_getTableHeadingString(this) + et_getTableBodyString(this) + "</table>";

	this.HTMLtable = this.objAppWindow.document.getElementById("et_" + this.HTMLdiv.id);

	// Restore grid column sizes.
	et_setPersistedColumnWidths(this);

	// Attach mouse click events to various parts of the table.
	this.attachGridEvents();
	
	var strGridRowClickMethod = "GRID_" + this.id + "_rowClick";
	if (typeof(this.objAppWindow[strGridRowClickMethod]) != "undefined") {
		this.objAppWindow[strGridRowClickMethod]();
	}
}

/** Initialise the grid
 */
function et_setup()
{
	if (this.objGridEdit != null && this.objGridEdit.objForm != null)
		this.objGridEdit.hide();
	
	this.HTMLtable = this.objAppWindow.document.getElementById("et_" + this.HTMLdiv.id);

	// Restore grid column sizes.
	et_setPersistedColumnWidths(this);

	// Attach mouse click events to various parts of the table.
	this.attachGridEvents();
	
	var strGridRowClickMethod = "GRID_" + this.id + "_rowClick";
	if (typeof(this.objAppWindow[strGridRowClickMethod]) != "undefined") {
		this.objAppWindow[strGridRowClickMethod]();
	}
		
	if (this.objGridEdit != null)
		this.HTMLdiv.style.backgroundColor = "#d9e2e8";

	this.arrRules = new Array();
	this.arrSelectedRows = new Array();

	if (this.objGridEdit != null)
	{
		if (this.objEditFormXML == null)
		{
			this.objEditFormXML = objApplication.createXMLDocument();
			this.objEditFormXML.loadURL(this.objGridEdit.editFormSrc);
		}

		var objHeadingNodes = this.objGridHeadingsXML.selectNodes("/grid/column");

		var objRows = this.HTMLtable.tBodies[0].rows;
		for (var i=0, intLen = objRows.length; i < intLen; i++)
		{
			var objCells = objRows[i].cells;
			
			for (var j=0, intJLen = objCells.length; j < intJLen; j++)
			{
				var objTD = objCells[j];
				var objHeadingNode = objHeadingNodes.item(j);

				var objTextBox = this.objEditFormXML.selectSingleNode("//textbox[@ref = '" + objHeadingNode.getAttribute("ref") + "']");

				if (objTextBox == null)
					continue;

				if (objTextBox.getAttribute("disabled") == "true")
					objTD.className = "ReadGridCell";
				else
					objTD.className = "EditGridCell";
			}
		}
	}
}

// Get the column widths from the User Settings xml and resize the grid columns.
function et_setPersistedColumnWidths(objGrid) {

	if (objApplication.PersistentXML == null)
		return;

	// Get the xml relating to the application.
	var strAppName = objApplication.getWindowFileName(objGrid.objAppWindow.document.URL);
	var strGridID = objGrid.id;

	var objAppSettingData = objApplication.PersistentXML.getPersistentData("grid[@id='" + strGridID + "']", objGrid.objAppWindow.m_strComponentId);
	var objAppSettingsNodes = null;

	if (objAppSettingData != null)
		objAppSettingsNodes = objAppSettingData.selectNodes("column");
	
	var objAppSettingNode;
	var i = 0;

	objGrid.objAppWindow.flgSkipResizingLastGridColumn = true;

	var objWindow;
	var objDiv;
	if (objAppSettingData == null)
	{
		objWindow = objGrid.objAppWindow;
		objDiv = objWindow.document.createElement("SPAN");
		objDiv.style.visibility = "hidden";
		objDiv.id = "tmpWidthDiv";
		objWindow.document.body.appendChild(objDiv);
	}
	
	var tableElement = objGrid.HTMLtable.childNodes.item(0).childNodes.item(0);
	// ...step through and update the column sizes.
	for (var heads = 0; heads < tableElement.childNodes.length; heads++) 
	{
		var strWidth = null;
		var objHeaderElement = tableElement.childNodes.item(heads);

		if (objAppSettingData != null && objAppSettingsNodes.item(heads) != null)
			strWidth = objAppSettingsNodes.item(heads).getAttribute("width");
		
		if (isBlank(strWidth) || Number(String(strWidth).replace("px", "")) < 40)
		{
			// No default user settings found - use grid widths defined in the actual grid xml.
			var strRef = tableElement.childNodes.item(heads).id.replace("grid_col_", "");
			var objGridCol = objGrid.objGridHeadingsXML.selectSingleNode("/grid/column[@ref = '" + strRef + "']");
			if (objGridCol == null)
				strWidth = "105px";
			else
			{
				var strCols = Number(objGridCol.getAttribute("cols"));
				if (strCols < 3)
					strCols = 3;
				
				switch (objGridCol.getAttribute("datatype"))
				{
					case "xsd:string":
						if (strCols > 25)
							strCols = 25;
						else if (strCols > 15)
							strCols = 15;

						if (objGridCol.getAttribute("isprimary") == "true" && strCols > 20)
							strCols = 20;
						break;

					case "xsd:float":
						strCols = 12;
						break;

					case "xsd:double":
						strCols = 12;
						break;

					case "xsd:decimal":
						strCols = 12;
						break;

					case "xsd:integer":
						strCols = 6;
						break;

					case "xsd:short":
						strCols = 6;
						break;

					case "xsd:smallint":
						strCols = 6;
						break;

					case "xsd:dateTime":
						strCols = 16;
						break;

					case "xsd:boolean":
						strCols =	6;
						break;
				}

				strWidth = String(Number(strCols) * 7) + "px";
			}

			var intMinWidth = 0;

			if (objDiv != null && objGrid.objAppWindow.document.body.compId != "appMenu.xml" && objGrid.objAppWindow.document.body.compId != "appMobileMenu.xml" )
			{
				objDiv.innerHTML = objHeaderElement.innerHTML.replace("<span class=arrow>6</span>", "").replace("<span class=arrow>5</span>", "");
				intMinWidth = objWindow.document.getElementById("tmpWidthDiv").offsetWidth + 4;
			}
			
			// Make sure width of header is at least the min width.
			if (intMinWidth > Number(strWidth.replace("px", "")))
				strWidth = intMinWidth + "px";
		}
		
		objHeaderElement.style.width = strWidth;
	}

	if (objAppSettingData == null)
	{
		objWindow.document.body.removeChild(objWindow.document.getElementById("tmpWidthDiv"));
		objApplication.PersistentXML.saveWindowSettings(objGrid.objAppWindow.m_strComponentId, objGrid.objAppWindow, "false");
	}
	
	objGrid.objAppWindow.flgSkipResizingLastGridColumn = false;
}

/** Get the table HTML TAG string
 * @param objGrid The grid to convert
 * @return the string
 */
function et_getTableTAGString(objGrid) {
	return "<table id='et_" + objGrid.HTMLdiv.id + "' cellspacing='0' cellpadding='0' class='GridContainer' align='top' style='table-layout:fixed'>";
}

/** Get the table head as a string
 * @param objGrid The grid to convert
 * @return the string
 */
function et_getTableHeadingString(objGrid) 
{
	var strXML = objApplication.EfacsApplet.getGridHeadTransformXML("http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/XSLT/xsltTransformNewGridHeadToTableHead.xslt");
	var objTransformXSL = objApplication.createXMLDocument(strXML);
	return objGrid.objGridHeadingsXML.transformNode(objTransformXSL);
}

/** Get the table body as a string
 * @param objGrid The grid to convert
 * @return the string
 */
function et_getTableBodyString(objGrid)
{
	var objTransformXSL = objApplication.createXMLDocument();
	objTransformXSL.loadURL(m_strGridDataToTableDataXSL, window.document.URL);

	// Set the table row name for use in the translation.
	objGrid.objGridDataXML.documentElement().setAttribute("name", "et_" + objGrid.HTMLdiv.id + "_uniqueTRid");

	objGrid.objGridDataXML.addTransformParameter("localeLanguageCode", objApplication.User.localeid);
	objGrid.objGridDataXML.addTransformParameter("baseURL", window.document.URL);
	objGrid.objGridDataXML.addTransformParameter("relativeURL", "../XML/xmlRegionalSettings.xml");

	return objGrid.objGridDataXML.transformNode(objTransformXSL);
}

/******************************************************
 Functions relating to selecting and highlighting rows.
******************************************************/

/**
 * Attaches mouse events to various parts of the table.
 * Attaches resize event so the last column can be resized to fit available space.
 */
function et_attachGridEvents() 
{
	// Attach mouse events to the body.
	removeEvent(this.objAppWindow.document.body, "onmouseup", this.objAppWindow.et_doMouseUp);
	removeEvent(this.objAppWindow.document.body, "onmousemove", this.objAppWindow.et_doMouseMove);
	addEvent(this.objAppWindow.document.body, "onmouseup", this.objAppWindow.et_doMouseUp);
	addEvent(this.objAppWindow.document.body, "onmousemove", this.objAppWindow.et_doMouseMove);

	// Attach mousedown and dblclick events to the table headers for resizing,
	// sorting etc.
	removeEvent(this.HTMLtable.tHead, "onmousedown", this.objAppWindow.et_doHeaderMouseDown);
	removeEvent(this.HTMLtable.tHead, "onmouseup", this.objAppWindow.et_doMouseUp);
	removeEvent(this.HTMLtable.tHead, "ondblclick", this.objAppWindow.et_doHeaderDblClick);
	removeEvent(this.HTMLtable.tHead, "onmouseover", this.objAppWindow.et_doHeaderMouseOver);
	removeEvent(this.HTMLtable.tHead, "onmouseout", this.objAppWindow.et_doHeaderMouseOut);
	addEvent(this.HTMLtable.tHead, "onmousedown", this.objAppWindow.et_doHeaderMouseDown);
	addEvent(this.HTMLtable.tHead, "onmouseup", this.objAppWindow.et_doMouseUp);
	addEvent(this.HTMLtable.tHead, "ondblclick", this.objAppWindow.et_doHeaderDblClick);
	addEvent(this.HTMLtable.tHead, "onmouseover", this.objAppWindow.et_doHeaderMouseOver);
	addEvent(this.HTMLtable.tHead, "onmouseout", this.objAppWindow.et_doHeaderMouseOut);

	// Attach mouse events to the table body for highlighting and selecting rows etc.
	removeEvent(this.HTMLtable.tBodies[0], "onmouseover", this.objAppWindow.et_doHighlightOn);
	removeEvent(this.HTMLtable.tBodies[0], "onmouseout", this.objAppWindow.et_doHighlightOff);
	removeEvent(this.HTMLtable.tBodies[0], "onclick", this.objAppWindow.et_doBodyClick);
	removeEvent(this.HTMLtable.tBodies[0], "ondblclick", this.objAppWindow.et_doBodyDblClick);
	removeEvent(this.HTMLtable.tBodies[0], "oncontextmenu", this.objAppWindow.et_doContextMenu);
	addEvent(this.HTMLtable.tBodies[0], "onmouseover", this.objAppWindow.et_doHighlightOn);
	addEvent(this.HTMLtable.tBodies[0], "onmouseout", this.objAppWindow.et_doHighlightOff);
	addEvent(this.HTMLtable.tBodies[0], "onclick", this.objAppWindow.et_doBodyClick);
	addEvent(this.HTMLtable.tBodies[0], "ondblclick", this.objAppWindow.et_doBodyDblClick);
	addEvent(this.HTMLtable.tBodies[0], "oncontextmenu", this.objAppWindow.et_doContextMenu);
	
	// Attach resize event to table so we can stretch last grid column to fit available space.
	removeEvent(this.HTMLdiv, "onresize", this.objAppWindow.et_doResizeLastColumn);
	addEvent(this.HTMLdiv, "onresize", this.objAppWindow.et_doResizeLastColumn);
	
	// Attach onblur event if declared externally in the application.
	if (!isBlank(this.onblur))
	{
		removeEvent(this.HTMLdiv, "onblur", this.objAppWindow.et_doOnBlur);
		addEvent(this.HTMLdiv, "onblur", this.objAppWindow.et_doOnBlur);
	}
}

/**
 * This function captures any key presses that occur within the grid.
 *
 * @param objEvent - the 'keydown' event.
 */
function et_doKeyDown(objEvent)
{
	if (! objEvent) 
		objEvent = window.event; // Get event details for IE

	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;
	
	var objGrid;
	if (objBrowserEvent.className == "GridDiv")
	{
		objBrowserEvent = objBrowserEvent.children(0);
		objGrid = window[objBrowserEvent.id.replace("et_grd", "")];
	}	
	else
	{
		objBrowserEvent = getParentElement(objEvent.srcElement ? objEvent.srcElement : objEvent.target, "table");
		objGrid = et_getGridObject(objBrowserEvent);
	}

	if (objBrowserEvent == null || objBrowserEvent.tBodies[0] == null)
		return;
		
	var objHTMLRows = objBrowserEvent.tBodies[0].rows;

	if (objEvent.keyCode == 13 && objHTMLRows.length > 0)			// ENTER KEY
	{
		if (objGrid.objGridEdit != null && objGrid.objGridEdit.objForm != null)
		{
			var intCellIndex = 1;
			if (objEvent.srcElement.tagName == "TD")
				intCellIndex = et_getCellIndex(objEvent.srcElement);

			var objTD = objHTMLRows[objGrid.keyboardRowPointer].cells[intCellIndex];
			objGrid.objGridEdit.activateEditForm(objTD)
		}
		else
		{
			if (objGrid.onRowDblClick != "") {
				var evalFunction = new Function("objGrid", "objGrid.objAppWindow." + objGrid.onRowDblClick);
				evalFunction(objGrid);
			}

			objGrid.performADAPTScript(ADAPT_ONROWDBLCLICK);
		}
		
		if (objApplication.browser == APPLICATION_IE)
			objEvent.returnValue = false;
		objEvent.cancelBubble = true;
	}
	else if (objEvent.keyCode == 46)		// DELETE KEY
	{
		if (objGrid.onDelKeyPressed && objGrid.getSelectedColumnValue("uniqueid").length > 0) {
			var evalFunction = new Function("objGrid", "objGrid.objAppWindow." + objGrid.onDelKeyPressed);
			evalFunction(objGrid);
		}
	}
	else if (objEvent.keyCode == 65 || objEvent.keyCode == 89)		// CTRL A	-	select all
	{
		if (objEvent.ctrlKey)
		{
			if (objHTMLRows.length > 0)
			{
				for (var intCtr = 0; intCtr < objHTMLRows.length - 1; intCtr++)
					et_toggleRowSelected(objGrid, objHTMLRows[intCtr], true, objEvent, false);
			
				et_toggleRowSelected(objGrid, objHTMLRows[objHTMLRows.length - 1], true, objEvent, true);
			}

			if (objApplication.browser == APPLICATION_IE)
				objEvent.returnValue = false;
			objEvent.cancelBubble = true;
		}
	}
	else if (objEvent.keyCode == 33)		// PAGE UP
	{
		var intPageSize = Math.round(objGrid.HTMLdiv.offsetHeight / 16) - 1;
		
		if (objHTMLRows.length > 0)
		{
			objGrid.keyboardRowPointer -= intPageSize;
			if (objGrid.keyboardRowPointer < 0)
				objGrid.keyboardRowPointer = 0;

			if (objHTMLRows[objGrid.keyboardRowPointer] == null)
				objGrid.keyboardRowPointer = 0;

			et_toggleRowSelected(objGrid, objHTMLRows[objGrid.keyboardRowPointer], false, objEvent);

			if (objGrid.scrollIntoView)
				objHTMLRows[objGrid.keyboardRowPointer].scrollIntoView(false);
		}
		
		if (objApplication.browser == APPLICATION_IE)
			objEvent.returnValue = false;
		objEvent.cancelBubble = true;
	}
	else if (objEvent.keyCode == 34)		// PAGE DOWN
	{
		var intPageSize = Math.round(objGrid.HTMLdiv.offsetHeight / 16) - 1;

		if (objHTMLRows.length > 0)
		{
			objGrid.keyboardRowPointer += intPageSize;
			if (objGrid.keyboardRowPointer >= objHTMLRows.length - 1)
				objGrid.keyboardRowPointer = objHTMLRows.length - 1;

			if (objHTMLRows[objGrid.keyboardRowPointer] == null)
				objGrid.keyboardRowPointer = 0;

			et_toggleRowSelected(objGrid, objHTMLRows[objGrid.keyboardRowPointer], false, objEvent);

			if (objGrid.scrollIntoView)
				objHTMLRows[objGrid.keyboardRowPointer].scrollIntoView(true);
		}

		if (objApplication.browser == APPLICATION_IE)
			objEvent.returnValue = false;
		objEvent.cancelBubble = true;
	}
	else if (objEvent.keyCode == 35)		// END
	{
		if (objHTMLRows.length > 0)
		{
			if (objEvent.shiftKey)
			{
				et_toggleRowSelected(objGrid, objHTMLRows[objGrid.keyboardRowPointer], false, objEvent);

				for (var intCtr = objGrid.keyboardRowPointer + 1; intCtr < objHTMLRows.length; intCtr++)
					et_toggleRowSelected(objGrid, objHTMLRows[intCtr], true, objEvent);
			}
			else
			{
				objGrid.keyboardRowPointer = objHTMLRows.length - 1;
				et_toggleRowSelected(objGrid, objHTMLRows[objGrid.keyboardRowPointer], false, objEvent);
			}

			if (objGrid.scrollIntoView)
				objHTMLRows[objGrid.keyboardRowPointer].scrollIntoView(false);
		}
		
		if (objEvent.returnValue)
			objEvent.returnValue = false;
		objEvent.cancelBubble = true;
	}
	else if (objEvent.keyCode == 36)		// HOME
	{
		if (objHTMLRows.length > 0)
		{
			if (objEvent.shiftKey)
			{
				et_toggleRowSelected(objGrid, objHTMLRows[objGrid.keyboardRowPointer], false, objEvent);

				for (var intCtr = objGrid.keyboardRowPointer - 1; intCtr >= 0; intCtr--)
					et_toggleRowSelected(objGrid, objHTMLRows[intCtr], true, objEvent);
			}
			else
			{
				objGrid.keyboardRowPointer = 0;
				et_toggleRowSelected(objGrid, objHTMLRows[objGrid.keyboardRowPointer], false, objEvent);
			}

			if (objGrid.scrollIntoView)
				objHTMLRows[objGrid.keyboardRowPointer].scrollIntoView(false);
		}
		
		if (objEvent.returnValue)
			objEvent.returnValue = false;
		objEvent.cancelBubble = true;
	}
	else if (objEvent.keyCode == 38)		// UP ARROW
	{
		if (objHTMLRows.length > 0)
		{
			if (objGrid.keyboardRowPointer > 0)
				objGrid.keyboardRowPointer --;

			if (objHTMLRows[objGrid.keyboardRowPointer] == null)
				objGrid.keyboardRowPointer = 0;

			if (objEvent.shiftKey)
				et_toggleRowSelected(objGrid, objHTMLRows[objGrid.keyboardRowPointer], true, objEvent);
			else
				et_toggleRowSelected(objGrid, objHTMLRows[objGrid.keyboardRowPointer], false, objEvent);

			if (objGrid.scrollIntoView)
				objHTMLRows[objGrid.keyboardRowPointer].scrollIntoView(false);
		}
		
		if (objApplication.browser == APPLICATION_IE)
			objEvent.returnValue = false;
		objEvent.cancelBubble = true;
	}
	else if (objEvent.keyCode == 40)		// DOWN ARROW
	{
		if (objHTMLRows.length > 0)
		{
			if (objGrid.keyboardRowPointer < objHTMLRows.length - 1)
				objGrid.keyboardRowPointer ++;

			if (objHTMLRows[objGrid.keyboardRowPointer] == null)
				objGrid.keyboardRowPointer = 0;

			if (objEvent.shiftKey)
				et_toggleRowSelected(objGrid, objHTMLRows[objGrid.keyboardRowPointer], true, objEvent);
			else
				et_toggleRowSelected(objGrid, objHTMLRows[objGrid.keyboardRowPointer], false, objEvent);

			if (objGrid.scrollIntoView)
				objHTMLRows[objGrid.keyboardRowPointer].scrollIntoView(true);
		}

		if (objApplication.browser == APPLICATION_IE)
			objEvent.returnValue = false;
		objEvent.cancelBubble = true;
	}
	else if (objEvent.keyCode == 27)			// ESCAPE
	{
		if (objGrid.objGridEdit != null && objGrid.objGridEdit.objForm != null)
		{
			objGrid.objGridEdit.hide();
			objEvent.cancelBubble = true;
			objEvent.returnValue = false;
		}
	}

	objGrid.objAppWindow.appTrans_mainBodyFTEvent(objEvent);
}

/** Highlight this row
 * @param objEvent DHTML event object
 */
function et_doHighlightOn(objEvent) 
{
	if (typeof(objApplication.browser) == "unknown")
		return;

	var objCurrentRow;
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;

	// Get a ref to the parent <tr> tag.
	objCurrentRow = getParentElement(objBrowserEvent, "tr");

	if (objCurrentRow == null)
		return;

	/* Don't change if already selected */
	if (objCurrentRow.selected == "true") {
		return;
	}

	// Original colour can vary row by row.
	if (objCurrentRow.getAttribute("xloc") == null) {
		objCurrentRow.setAttribute("xloc", objCurrentRow.currentStyle.color);
	}

	// If this is the first time we are setting background colours, use the
	// className attribute to fecth all the background colours we need.
	// Next time we will be able to use the style.background property to set
	// the background colours as this is much faster than changing the class name
	// every highlight/de-highlight.
	if (m_strRowHighlightedColour == "")
	{
		var strCurrentRowClass = objCurrentRow.className;
		objCurrentRow.removeAttribute("style");
		objCurrentRow.className = "gridRowSelected";
		if (objApplication.browser == APPLICATION_IE) {
			m_strRowSelectedColour = objCurrentRow.currentStyle.backgroundColor;
			m_strRowSelectedTextColour = objCurrentRow.currentStyle.color;
		} else {
			m_strRowSelectedColour = "orange";
		}
		
		objCurrentRow.className = "gridRowHighlight";
		if (objApplication.browser == APPLICATION_IE)
			m_strRowHighlightedColour = objCurrentRow.currentStyle.backgroundColor;
		else
			m_strRowHighlightedColour = "yellow";

		objCurrentRow.className = strCurrentRowClass;
	}

	objCurrentRow.style.backgroundColor = m_strRowHighlightedColour;

	
	var objGrid = et_getGridObject(objCurrentRow);

	// if mouseover function defined call (passing uniqueid)	
	if (objGrid != null && objGrid.onmouseover != null) {
		objGrid.onmouseover(objCurrentRow.id.substr(objCurrentRow.id.lastIndexOf("_uniqueTRid") + 11));
	}
}

/** Handle click events
 * @param objEvent DHTML event object
 */
function et_doBodyClick(objEvent)
{
	var objCurrentRow;
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;

	var objGrid = et_getGridObject(objBrowserEvent);

	// If we are not allowed to select rows then simply return.
	if (objGrid.selectType == "none")
		return;

	// Get a ref to the parent <tr> tag.
	objCurrentRow = getParentElement(objBrowserEvent, "tr");

	if (objCurrentRow == null)
		return;

	// Put the focus on the table body so keypresses can be detected.
	// But not required for tree node labels.
	if (objBrowserEvent.tagName != "LABEL" && objGrid.objGridEdit == null)
	{
		try {
			objGrid.HTMLdiv.focus();
		} catch (error) {
		}
	}

	// Get a ref to the <td> tag - see if a check box value should be toggled.
	objCurrentCell = getParentElement(objBrowserEvent, "td");

	if (objEvent.shiftKey)
	{
		var intNewRowIndex = objCurrentRow.rowIndex;
		var objHTMLRows = objGrid.HTMLtable.tBodies[0].rows;

		if (objGrid.keyboardRowPointer < intNewRowIndex)
		{
			for (var intCtr = objGrid.keyboardRowPointer; intCtr < intNewRowIndex; intCtr++)
				et_toggleRowSelected(objGrid, objHTMLRows[intCtr], true, objEvent, false);
		}
		else
		{
			for (var intCtr = objGrid.keyboardRowPointer - 1; intCtr >= intNewRowIndex - 1; intCtr--)
				et_toggleRowSelected(objGrid, objHTMLRows[intCtr], true, objEvent, false);
		}
	} 
	else	
		et_toggleRowSelected(objGrid, objCurrentRow, false, objEvent);
		
	objGrid.keyboardRowPointer = objCurrentRow.rowIndex - 1;

	if (objCurrentCell.style.backgroundImage.indexOf("checkBoxTicked") != -1 || objCurrentCell.style.backgroundImage.indexOf("checkBoxNotTicked") != -1)
		et_toggleCheckBoxValue(objGrid, objCurrentCell);
}

/** Toggles the checkbox value, if the current checkbox is editable.
 * @param objGrid Current grid
 * @param objCurrentCell Current cell
 * @return true if changed, otherwise false.
 */
function et_toggleCheckBoxValue(objGrid, objCurrentCell) {
	var objAppRow;

	// Get a ref to the GridHeadingXML node.
	var objGridHeadingXMLnode = objGrid.objGridHeadingsXML.selectNodes("/grid/column").item(et_getCellIndex(objCurrentCell));

	// See if column is editable.
	if (objGridHeadingXMLnode.getAttribute("editable") != "true")
		return false;

	// Get the uniqueid for the current row.
	var strUniqueID = objCurrentCell.parentNode.cells[0].innerHTML;
	for ( ; strUniqueID.indexOf(" ") != -1 ; )
		strUniqueID = strUniqueID.replace(" ", "")

	if (objGrid.objGridDataXML != null)
	{
		// Get a reference to the GridDataXML row node for the selected row.
		var objNode = objGrid.objGridDataXML.selectSingleNode("/grid/row/column[@name='uniqueid' and label/text()='" + strUniqueID + "']");
		var objRowNode;
		var objColumnNode
		if (objNode != null)
		{
			objRowNode = objNode.parentNode();
			// Now get a reference to the GridDataXML column node and update the value.
			objColumnNode = objRowNode.selectNodes("*").item(objCurrentCell.cellIndex + 1);
		}
	}
		
	// And also get a reference to the application data row so it's value can be updated.
	if (objGrid.objAppData)
		objAppRow = objGrid.objAppData.selectSingleNode(objGrid.strRecordName + "[@uniqueid = '" + strUniqueID + "']");

	// Get the column reference name.
	var strColumnRef = objGridHeadingXMLnode.getAttribute("ref");

	// could be enabled or disabled, but is checked
	if (objCurrentCell.style.backgroundImage.indexOf("checkBoxTicked") != -1)	 
	{ 
		// set to the opposite state but maintain disabled nature if appropriate
		if (objCurrentCell.style.backgroundImage== "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTicked.gif)")	
			objCurrentCell.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTicked.gif)";			// Update the HTML.
		else
			objCurrentCell.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTickedDisabled.gif)";		// Update the HTML.
			
		if (objColumnNode)
			objColumnNode.selectSingleNode("label").setText("0");						// Update the GridDataXML
		if (objGrid.objAppData)
			objAppRow.selectSingleNode(strColumnRef + "/value").setText("0");		// Update the app data
	}
	else
	{
		// set to the opposite state but maintain disabled nature if appropriate	
		if (objCurrentCell.style.backgroundImage== "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTicked.gif)")	
			objCurrentCell.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTicked.gif)";				// Update the HTML.
		else
			objCurrentCell.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTickedDisabled.gif)";	// Update the HTML.
		
		if (objColumnNode)
			objColumnNode.selectSingleNode("label").setText("-1");					// Update the GridDataXML
		if (objGrid.objAppData)
			objAppRow.selectSingleNode(strColumnRef + "/value").setText("-1");	// Update the application data.
	}

	// If there is an onclick function to call then call it.
	if (!isBlank(objGridHeadingXMLnode.getAttribute("onclick"))) {
		objGrid.objAppWindow[objGridHeadingXMLnode.getAttribute("onclick")](strUniqueID);
	}

	return true;
}

/**
 * Fires when the user leaves an editable grid cell.
 * Removes input box from TD, re-applies cell formatting on the data and
 * fires the onchange event as declared in the app - if there is one.
 * 
 * @param objEvent The window event object.
 * @see et_setTDEditable
 */
function et_InputOnBlur(objEvent)
{
	var objInput = objEvent.srcElement;
	
	var strNewVal = objInput.value;
	var objTD = objInput.parentElement;
	
	var objGrid = et_getGridObject(objTD);
	var objHeadingNode = objGrid.objGridHeadingsXML.selectNodes("/grid/column").item(et_getCellIndex(objTD))
	
	objTD.style.paddingLeft = "5px";
	objTD.innerHTML = et_applyCellProperty(strNewVal, objHeadingNode);

	// Call the onchange event declared in the app - if there is one.
	// Pass the row, the column name and the unique id for use in the calling app.	
	if (!isBlank(objGrid.onchange) && objTD.innerHTML != objTD.getAttribute("originalValue"))
	{
		var strEval;
		if (objGrid.onchange.indexOf("()") != -1) {
			strEval = objGrid.onchange.replace("()", "(objRow, strColumnName, lngUniqueID)");
		} else if (objGrid.onchange.indexOf(")") != -1) {
			strEval = objGrid.onchange.replace(")", ", objRow, strColumnName, lngUniqueID)");
		} else {
			strEval = objGrid.onchange + "(objRow, strColumnName, lngUniqueID)";
		}

		var strColumnName = objHeadingNode.getAttribute("ref");
		var lngUniqueID = objTD.parentElement.id.replace("et_grd" + objGrid.id + "_uniqueTRid", "");
		var objRow = objGrid.getRow(lngUniqueID)
		
		var evalFunction = new Function("objRow", "strColumnName", "lngUniqueID", strEval);
		evalFunction(objRow, strColumnName, lngUniqueID);
	}
}

/**
 * Handles key presses used for navigating about the editable grid cells.
 * Supports TAB, Shift TAB, Up Arrow and Down Arrow. ENTER key = TAB key.
 * 
 * @param objEvent The window event object.
 */
function et_InputOnKeyDown(objEvent)
{
	var objTD = objEvent.srcElement.parentElement;
	var objTR;

	if (objEvent.keyCode == 9 || objEvent.keyCode == 13)	// TAB key or ENTER key
	{
		if (objEvent.shiftKey)
			objTD = et_getPreviousEditableTD(objTD);
		else
			objTD = et_getNextEditableTD(objTD);

		if (objTD != null)
			et_setTDEditable(objTD);
	
		objEvent.cancelBubble = true;
		objEvent.returnValue = false;
	}	
	else if (objEvent.keyCode == 38)	// UP ARROW key
	{
		objTR = objTD.parentElement.previousSibling;
		if (objTR != null)
		{
			objTD = objTR.cells[et_getCellIndex(objEvent.srcElement.parentElement)];
			et_setTDEditable(objTD);
		}
	}
	else if (objEvent.keyCode == 40)	// DOWN ARROW key
	{
		objTR = objTD.parentElement.nextSibling;
		if (objTR != null)
		{
			objTD = objTR.cells[et_getCellIndex(objEvent.srcElement.parentElement)];
			et_setTDEditable(objTD);
		}
	}
}

/**
 * Gets previous editable grid cell. Called when pressing
 * SHIFT TAB in an editable grid cell.
 * 
 * @param objTD The current grid cell being edited.
 * @return The previous editable grid cell or null if this is the first cell in the grid.
 * @see et_InputOnKeyDown
 */
function et_getPreviousEditableTD(objTD)
{
	var objGrid = et_getGridObject(objTD);
	var objTR;

	for ( ; ; )
	{
		objTD = objTD.previousSibling;
		
		if (et_getCellIndex(objTD) == 0)
		{
			objTR = objTD.parentElement.previousSibling;
			if (objTR == null)
				return;
			
			objTD = objTR.cells[objTR.cells.length - 1];
		}
		
		var objHeadNode = objGrid.objGridHeadingsXML.selectNodes("/grid/column").item(et_getCellIndex(objTD));
		if (objHeadNode.getAttribute("read-only") != "true" && objTD.style.display != "none")
			return objTD;
	}
}

/**
 * Gets next editable grid cell. Called when pressing
 * TAB in an editable grid cell.
 * 
 * @param objTD The current grid cell being edited.
 * @return The next editable grid cell or null if this is the last cell in the grid.
 * @see et_InputOnKeyDown
 */
function et_getNextEditableTD(objTD)
{
	var objGrid = et_getGridObject(objTD);
	var objTR;

	for ( ; ; )
	{
		if (objTD.nextSibling == null)
		{
			objTR = objTD.parentElement.nextSibling;
			if (objTR == null)
				return;
			
			objTD = objTR.cells[1];
		}
		else
			objTD = objTD.nextSibling;
		
		var objHeadNode = objGrid.objGridHeadingsXML.selectNodes("/grid/column").item(et_getCellIndex(objTD));
		if (objHeadNode.getAttribute("read-only") != "true" && objTD.style.display != "none")
			return objTD;
	}
}

/**
 * Used to reliably get the cell index for a TD.
 * Cannot use objTD.cellIndex as this can give the wrong index if
 * there are hidden columns in the grid.
 * 
 * @param objTD The TD for which the cellIndex is required.
 * @return The cellIndex for the TD.
 */
function et_getCellIndex(objTD)
{
	for (var intCtr = 0; objTD != null; intCtr++)
		objTD = objTD.previousSibling;
	
	return intCtr - 1;
}

/**
 * Sets a TD as editable by inserting an INPUT element.
 * INPUT element is removed in the et_InputOnBlur method.
 * 
 * @param objTD The TD to be set as editable.
 * @return False if unable to set new TD as ediatable, else true.
 * @see et_InputOnBlur
 */
function et_setTDEditable(objTD)
{
	m_objEditableGrid = et_getGridObject(objTD);

	if (m_objEditableGrid.objGridEdit != null)
	{
		objTD.focus();
		return m_objEditableGrid.objGridEdit.activateEditForm(objTD);
	}
	else
	{
		var objInput = window.document.createElement("INPUT");
		objInput.value = objTD.innerHTML;
		objTD.innerHTML = "";
		objTD.setAttribute("originalValue", objInput.value);
		objTD.appendChild(objInput);
		objTD.style.padding = "0px";
		objTD.style.margin = "0px";
		addEvent(objInput, "onblur", et_InputOnBlur);
		addEvent(objInput, "onkeydown", et_InputOnKeyDown);
		objInput.style.padding = "0px";
		objInput.style.paddingLeft = "2px";
		objInput.style.margin = "0px";
		objInput.style.height = objTD.offsetHeight - 7;
		objInput.style.width = objTD.offsetWidth - 7;
		objInput.select();
		objInput.focus();
	}
	
	return true;
}

/**
 * Fires when a user clicks a row in the grid.
 * If the grid is editable then the data in the cell actually 
 * clicked on is made available to the user for changing.
 * If the grid is not editable then the row is highlighted
 * with a different background colour.
 * 
 * @param objGrid Reference to the grid object that the row will be selected on.
 * @param objCurrentRow The html TR element representing the row to be selected.
 * @param flgKeepAlreadySelected If set to 'true' then any existing selected rows will remain selected. Default is false.
 * @param objEvent The window event object.
 * @param flgFireEvents Determines whether external onRowSelect method should be fired.
 *        E.g. Set to false when using CTRL-A to select all rows.
 */
function et_toggleRowSelected(objGrid, objCurrentRow, flgKeepAlreadySelected, objEvent, flgFireEvents)
{
	if (objGrid.selectType == "none")
		return;

	if (objEvent != null && objGrid.isEditable)
	{
		var objTD = objEvent.srcElement;
		if (objTD.tagName == "TD")
		{
			if (objGrid.objGridEdit != null || objGrid.objGridHeadingsXML.selectNodes("/grid/column").item(et_getCellIndex(objTD)).getAttribute("read-only") != "true")
			{
				if (et_setTDEditable(objTD) == false)
					return;
			}
		}
	}

	// Original colour can vary row by row.
	if (objCurrentRow.getAttribute("xloc") == null) {
		objCurrentRow.setAttribute("xloc", objCurrentRow.currentStyle.color);
	}

	// Select the row.
	if (m_strRowHighlightedColour == "")
	{
		var strCurrentRowClass = objCurrentRow.className;
		objCurrentRow.removeAttribute("style");
		objCurrentRow.className = "gridRowSelected";
		if (objApplication.browser == APPLICATION_IE) {
			m_strRowSelectedColour = objCurrentRow.currentStyle.backgroundColor;
			m_strRowSelectedTextColour = objCurrentRow.currentStyle.color;
		}
		
		objCurrentRow.className = "gridRowHighlight";
		if (objApplication.browser == APPLICATION_IE)
		m_strRowHighlightedColour = objCurrentRow.currentStyle.backgroundColor;
		objCurrentRow.className = strCurrentRowClass;
	}

	if (objCurrentRow.id.indexOf("uniqueTRid") == -1)
		return;

	// If we are only allowed to select a single row, then we need to check
	// for any rows already selected and deselect them.
	if (objGrid.selectType == "single")
		objGrid.deselectAllRows();
	else if (flgKeepAlreadySelected != true) 
	{
		if (objEvent != null)
		{
			if (objEvent.type == "keydown" || objEvent.ctrlKey == false)
				objGrid.deselectAllRows();
		}
		else
			objGrid.deselectAllRows();
	}	

	// Set the selected attribute, assign an id (based on this table name),
	// The id can be used later for quick access to all HTML selected rows.
	objCurrentRow.selected = "true";
	objCurrentRow.cells[0].id = objGrid.HTMLdiv.id + "_et_rowSelected";
	objCurrentRow.style.backgroundColor = m_strRowSelectedColour;
	if (objGrid.objGridEdit == null) {
		objCurrentRow.style.color = m_strRowSelectedTextColour;
	}

	// Now we have highlighted the row on the HTML table, we need to update
	// the XML data island to flag the row as selected.
	et_updateRowSelectedStatus(objGrid, et_trimSpace(objCurrentRow.cells[0].innerHTML), true);

	// Call the onrowselect function if there is one.
	if (flgFireEvents != false)
	{
		et_callOnRowSelect(objGrid);
		objGrid.performADAPTScript(ADAPT_ONROWCLICK);
	}
}

/** Call an application defined onRowSelect function
 * @param objGrid The grid that is firing the event
 */
function et_callOnRowSelect(objGrid)
{
	if (objGrid.onRowSelect != "") {
		if (objGrid.onRowSelect.indexOf("objGrid.objAppWindow") != -1) {
			var evalFunction = new Function("objGrid", objGrid.onRowSelect);
			evalFunction(objGrid);
		} else {
			var evalFunction = new Function("objGrid", "objGrid.objAppWindow." + objGrid.onRowSelect);
			evalFunction(objGrid);
		}
	}
}

// Call the onrowdblclick function if there is one.
function et_doBodyDblClick(objEvent)
{
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;
	var objCurrentRow;
	var objGrid = et_getGridObject(objBrowserEvent);

	// If we are not allowed to select rows then simply return.
	if (objGrid.selectType == "none")
		return;

	// Get a ref to the parent <tr> tag.
	objCurrentRow = getParentElement(objBrowserEvent, "tr");

	if (objCurrentRow == null)
		return;

	// Make sure we have a selected row.
	if (objCurrentRow.selected == "false")
		et_doBodyClick(objEvent);

	if (objGrid.onRowDblClick != "") {
		var evalFunction = new Function("objGrid", "objGrid.objAppWindow." + objGrid.onRowDblClick);
		evalFunction(objGrid);
	}
	
	objGrid.performADAPTScript(ADAPT_ONROWDBLCLICK);
}

/** Update a row's selected status - on or off
 * @param objGrid the grid
 * @param strUniqueID The unique ID for the grid row
 * @param flgSelected Is the row to be selected or unselected
 */
function et_updateRowSelectedStatus(objGrid, strUniqueID, flgSelected) 
{
	if (objGrid.objGridDataXML == null)
		return;

	var objColNode = objGrid.objGridDataXML.selectSingleNode("/grid/row/column[@name='uniqueid' and label/text()='" + strUniqueID + "']");

	if (objColNode == null)
		return;

	if (flgSelected)
		objColNode.parentNode().setAttribute("selected", "yes");
	else
		objColNode.parentNode().setAttribute("selected", "no");
}

/** Turn a row highlight off
 * @param objEvent DHTML event object
 */
function et_doHighlightOff(objEvent) {

	if (typeof(objApplication.browser) == "unknown")
		return;

	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;

	// Get a ref to the parent <tr> tag.
	var objCurrentRow = getParentElement(objBrowserEvent, "tr");

	if (objCurrentRow == null)
		return;

	/* Don't change if already selected */
	if (objCurrentRow.selected == "true") {
		return;
	}

	var objGrid = et_getGridObject(objCurrentRow);
	
	// If the row we are moving off is flagged as selected then we need to
	// change the background colour to selected colour.
	if (objCurrentRow.selected == "true") {
		objCurrentRow.style.backgroundColor = m_strRowSelectedColour;
		if (objGrid != null && objGrid.objGridEdit == null) {
			objCurrentRow.style.color = m_strRowSelectedTextColour;
		}
	} else {
		objCurrentRow.style.backgroundColor = "transparent";
		var strStandardTextColour = objCurrentRow.getAttribute("xloc");
		if (strStandardTextColour != null) {
			objCurrentRow.style.color = strStandardTextColour;
		}
	}

	// if mouseout function defined call (passing uniqueid)	
	if (objGrid != null && objGrid.onmouseout != null){
		objGrid.onmouseout(objCurrentRow.id.substr(objCurrentRow.id.lastIndexOf("_uniqueTRid") + 11));
	}
}

// Highlights all rows in the grid.
function et_selectAllRows()
{
	var objRows = this.HTMLtable.tBodies[0].rows;

	for (var intCtr = 0; intCtr < objRows.length; intCtr++)
	{	
		var objRow = objRows[intCtr];
		
		if (objRow.selected != "true")
		{
			var strUniqueID = objRow.cells[0].innerHTML;
			this.selectRow(strUniqueID, true);
		}
	}
}

// Unhighlights all rows in the grid.
function et_deselectAllRows() {

	var objSelectedElements;

	// Get all body rows <tr>'s that have id equal CurrentTableName + "_et_rowSelected".
	if ((objSelectedElements = this.objAppWindow.document.getElementsByName(this.HTMLdiv.id + "_et_rowSelected")) == null)
		return;

	// Using document.all(strName) may return a single element or a collection of
	// of elements. We need to test for both.
	if (objSelectedElements.length == null)
	{
		objSelectedElements.id = "";
		objParentElem.selected = "false";
		objSelectedElements.parentNode.selected = "false";
		objSelectedElements.parentNode.style.backgroundColor = "transparent";
		var strStandardTextColour = objSelectedElements.parentNode.getAttribute("xloc");
		if (strStandardTextColour != null) {
			objSelectedElements.parentNode.style.color = strStandardTextColour;
		}

		// Now we have un-highlighted the row on the HTML table, we need to update
		// the XML data island to flag the row as not selected.
		et_updateRowSelectedStatus(this, et_trimSpace(objSelectedElements.innerHTML), false);
	}
	else
	{
		for (;objSelectedElements.length > 0; )
		{
			var objParentElem = objSelectedElements.item(0).parentNode;
			objParentElem.cells[0].id = "";
			objParentElem.selected = "false";
			objParentElem.style.backgroundColor = "transparent";
			var strStandardTextColour = objParentElem.getAttribute("xloc");
			if (strStandardTextColour != null) {
				objParentElem.style.color = strStandardTextColour;
			}

			// Now we have un-highlighted the row on the HTML table, we need to update
			// the XML data island to flag the row as not selected.
			et_updateRowSelectedStatus(this, et_trimSpace(objParentElem.cells[0].innerHTML), false);
		}
	}
}

/*****************************************
 Functions relating to sorting columns.
*****************************************/

/**
 *	Internal sort method, should not be called by front end. 
 * 	Use sortByColumn method for frontend use.
 *	@param objHeadParent - The Grid table head element.
 *	@param objElement - The column element which invoked the event.
 */
function et_sortColumn(objHeadParent, objElement) {
	var i = et_setColumnDirection(objHeadParent, objElement);

	if (objElement != null) {
		var table = getParentElement(objElement, "table");
		
		try {
			table.focus();
		} catch (objError) {
		}

		// can't fail
		et_sortTable(table, i, objElement._descending, objElement.type);
	}
}

/**
 *	Internal sort column direction method, should not be called by front end.
 * 	Use sortByColumn method for frontend grid column sorting.
 *	@param objHeadParent - The Grid table head element.
 *	@param objElement - The column element which invoked the event.
 *	@return - Return the integer element column number.
 */
function et_setColumnDirection(objHeadParent, objElement) {
	if (m_objResizeObject != null)
	{
		m_objResizeObject = null;
		return;
	}

	if (objElement != null) {
		var p = objElement.parentNode;
		var i;

		if (objElement._descending)	// catch the null
			objElement._descending = false;
		else
			objElement._descending = true;

		if (objHeadParent.arrow != null) {
			if (objHeadParent.arrow.parentNode != objElement) {
				objHeadParent.arrow.parentNode._descending = null;	//reset sort order
			}
			objHeadParent.arrow.parentNode.removeChild(objHeadParent.arrow);
		}

		var objArrowDown = document.createElement("IMG");
		objArrowDown.className = "arrow";
		objArrowDown.src = "../GIF/gifGridArrowDown.gif";
		objArrowDown.style.height = "11px";
		
		var objArrowUp = document.createElement("IMG");
		objArrowUp.className = "arrow";
		objArrowUp.src = "../GIF/gifGridArrowUp.gif";
		objArrowUp.style.height = "11px";

		if (objElement._descending)
			objHeadParent.arrow = objArrowDown.cloneNode();
		else
			objHeadParent.arrow = objArrowUp.cloneNode();

		objElement.appendChild(objHeadParent.arrow);
		// get the index of the td
		for (i=0; i<p.cells.length; i++) {
			if (p.cells[i] == objElement) break;
		}
	}

	return i;
}

/** Sort the table by a specified column
 * @param objTableNode The table element
 * @param intColumnNumber The column to sort by
 * @param flgDescending Sort descending if true otherwise ascending
 * @param strSortType Type of sort
 */
function et_sortTable(objTableNode, intColumnNumber, flgDescending, strSortType) {
	var objBody = objTableNode.tBodies[0];
	var objRows = objBody.rows;
	var arrColumns = new Array();

	// Create an array from the HTML rows.
	// We can then use  the javascript sort facility for fast performance.
	for (var i=0; i < objRows.length; i++) {
		arrColumns[i] = objRows[i];
	}

	arrColumns.sort(et_compareByColumn(intColumnNumber, flgDescending, strSortType));

	for (var i=0; i < arrColumns.length; i++) {
		objBody.appendChild(arrColumns[i]);
	}
}

// These 3 functions used in compare by column for formatting the cell data
// before comparing.
function et_caseInsensitiveString(s) {
	return String(s).toLowerCase();
}

/** Parse a string into a date
 * @param s String date in locale format
 * @return String  date in ISO format
 */
function et_parseDate(s) {
	// if the column is null then return an empty string. 
	if (isBlank(s))
		return "";
		
	var objEfacsCalendar=objApplication.getCalendarParser();

	objEfacsCalendar.setDateTimeInLocaleFormat(s);
	return objEfacsCalendar.getDateTimeInISO();
}

/** Parse a String into a number
 * @param strNumber String number
 * @return A Number object
 */
function et_parseNumber(strNumber)
{
	if (isBlank(strNumber))
		return "";

	return Number(objApplication.EfacsApplet.parseNumber(strNumber));
}

// Does the actual compare of column data.
function et_compareByColumn(intColumnNumber, flgDescending, strSortType) {
	// Default typecast to case insensitive string.
	var fTypeCast = et_caseInsensitiveString;

	if (strSortType == "xsd:float" || strSortType == "xsd:double" ||
		strSortType == "xsd:integer" || strSortType == "xsd:short" ||
	    strSortType == "xsd:smallint" || strSortType == "xsd:decimal")
		fTypeCast = et_parseNumber;
	else if (strSortType == "xsd:dateTime")
		fTypeCast = et_parseDate;
	else if (strSortType == "xsd:string")
		fTypeCast = String;

	return function (n1, n2) {
		var objCell1 = n1.cells[intColumnNumber];
		var objCell2 = n2.cells[intColumnNumber];
		if (objCell1.style.backgroundImage.indexOf("checkBoxNotTicked") != -1 && objCell2.style.backgroundImage.indexOf("checkBoxTicked") != -1)
			return flgDescending ? -1 : +1;
		if (objCell1.style.backgroundImage.indexOf("checkBoxTicked") != -1 && objCell2.style.backgroundImage.indexOf("checkBoxNotTicked") != -1)
			return flgDescending ? +1 : -1;
		if (fTypeCast(et_getInnerText(objCell1)) < fTypeCast(et_getInnerText(objCell2)))
			return flgDescending ? -1 : +1;
		if (fTypeCast(et_getInnerText(objCell1)) > fTypeCast(et_getInnerText(objCell2)))
			return flgDescending ? +1 : -1;
		return 0;
	};

}

/** Get the text from an element
 * @param objElement HTML element
 * @return the innerHTML
 */
function et_getInnerText(objElement) {
	return objElement.innerHTML;
}

/*****************************************
 Functions relating to resizing columns.
*****************************************/

function et_resizeObject() {
	this.element     = null;    // Pointer to the column being resized.
	this.mouseposition   = "";      // mouseposition of resize (left, right).
	this.grabx       = null;    // Some useful values
	this.width       = null;
	this.leftEl      = null;
	this.leftElWidth = null;
}

function et_doHeaderMouseOver(objEvent)
{
	var objElement;
	var strMousePosition = "";
	
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;

	// Get a reference to the header TD that was clicked.
	objElement = et_getClickedHeaderElement(objBrowserEvent);

	if (objElement == null)
	{
		return;
	}

	strMousePosition = et_getMousePosition(objElement);

	if (strMousePosition == "")
		objElement.style.cursor = "default";
	else
		objElement.style.cursor = "e-resize";
}

function et_doHeaderMouseOut(objEvent) {
	var objElement;
	var strMousePosition = "";
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;

	// Get a reference to the header TD that was clicked.
	objElement = et_getClickedHeaderElement(objBrowserEvent);

	if (objElement == null)
	{
		return;
	}

	objElement.style.cursor = "default";
}

function et_doHeaderMouseDown(objEvent)
{
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;
	var objElement;
	var strMousePosition = "";

	// Get a reference to the header TD that was clicked.
	objElement = et_getClickedHeaderElement(objBrowserEvent);
	var objGrid = et_getGridObject(objElement);
	objGrid.grdSplitterBar.style.display = "none";

	if (objElement == null)
	{
		m_objResizeObject = null;
		return;
	}

	strMousePosition = et_getMousePosition(objElement);

	if (strMousePosition == "")
	{
		// Take a copy of the element and check we have the same element on the
		// mouseUp event - if we have, simulate a mouseClick.
		m_objMouseClickElement = objElement;
		return;
	}
	else
		m_objMouseClickElement = null;

	m_objResizeObject = new et_resizeObject();
	m_objResizeObject.element = objElement;
	m_objResizeObject.mouseposition = strMousePosition;
	m_objResizeObject.grabx = getPosX(objEvent);
	m_objResizeObject.width = objElement.offsetWidth;

	// TODO: offsetY/X has no equivalent in the DOM Level 2 event model.
	var intGridTop = objEvent.clientY - (objEvent.offsetY ? objEvent.offsetY + 3 : 3);
	var intGridHeight = objGrid.HTMLdiv.offsetHeight;
	objGrid.grdSplitterBar.innerHTML = "<div style='visibility:visible; background-color:black; position:absolute; top:" + intGridTop + "; left:" + getPosX(objEvent) + "; width:1px; height:" + intGridHeight + "px;'></div>";						
		objGrid.grdSplitterBar.style.display = "inline";
	
	// Take a snapshot of previous sibling's width.
	if (m_objResizeObject.element.cellIndex > 1)
	{
		m_objResizeObject.leftEl = m_objResizeObject.element.previousSibling;
		m_objResizeObject.leftElWidth = m_objResizeObject.leftEl.offsetWidth;
	}
}

function et_doMouseUp(objEvent)
{
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;
	var objElement = et_getClickedHeaderElement(objBrowserEvent);
	var intIdx = et_getCellIndex(objElement);

	if (m_objMouseClickElement != null && m_objMouseClickElement == objElement)
	{
		var objHeadParent = getParentElement(objBrowserEvent, "thead");
		var objElement = getParentElement(objBrowserEvent, "td");

		if (objHeadParent != null) {
			var objGridSort = et_getGridObject(objHeadParent);

			objGridSort.objAppWindow.objStatusBar.clear();

			if (objGridSort.objGridHeadingsXML.selectNodes("/grid/column").item(intIdx).getAttribute("editable") == "true")
				return;

			if (objGridSort.objGridHeadingsXML.selectNodes("/grid/column").item(intIdx).getAttribute("sortable") == "false") {
				objGridSort.objAppWindow.objStatusBar.error(fl("SORTINGNOTSUPPORTED"));
				return;
			}
			
			if (objGridSort.objGridEdit != null)
				return;

			if (objGridSort.isTreeGrid == false && objGridSort.isListPicker == false && objGridSort.sortable != "false")
			{
				if (objGridSort.overrideSort == null) {
					et_sortColumn(objHeadParent, objElement);
				}
				else {
					var p = objHeadParent.parentNode;
					
					var strColumnName = objElement.id.replace ("grid_col_", "");
					
					// find the table name associated with this column in case it is 
					// not a unique column within the query
					var strTableName = objGridSort.objGridHeadingsXML.selectSingleNode ("/grid/column[@ref='" + strColumnName + "']").getAttribute ("table");
						
					// if the tablename is not blank then prepend it to the column name to acheive full qualification.	
					if (!isBlank (strTableName)) 
						strColumnName = strTableName + "." + strColumnName;
					
					m_blnDescend = objElement._descending;
					
					if (objGridSort.overrideSort.indexOf(".") == -1) {
						window[objGridSort.overrideSort](strColumnName, m_blnDescend ? "desc" : "asc");
					} else {
						eval(objGridSort.overrideSort + "( '" + strColumnName + "', \"" + (m_blnDescend ? "desc" : "asc") + "\");");
					}
						
					objHeadParent = objGridSort.HTMLtable.tHead;
					objElement = objGridSort.HTMLtable.tHead.rows[0].cells[intIdx];

					objElement._descending = m_blnDescend;

					et_setColumnDirection(objHeadParent, objElement);
				}
			}
		}
	}

	if (m_objResizeObject != null)
	{
		if (m_objResizeObject.mouseposition.indexOf("right") != -1)
			objResizeElement = m_objResizeObject.leftEl;
		else
			objResizeElement = m_objResizeObject.element;

		var deltaX = getPosX(objEvent) - m_objResizeObject.grabx;
		
		if (objResizeElement.style.pixelWidth + deltaX > 40)
			objResizeElement.style.width = (objResizeElement.style.pixelWidth + deltaX) + "px";
		else
			objResizeElement.style.width = "40px";
		
		var objGrid = et_getGridObject(objResizeElement);
		objGrid.grdSplitterBar.style.display = "none";
		
		if (objGrid.objGridEdit != null && objGrid.objGridEdit.objForm != null)
		{
			objGrid.objGridEdit.resizeFormFields();
			objGrid.objGridEdit.positionIFrame();
		}

		objGrid.objAppWindow.document.body.focus();
		setTimeout("et_fixGridFocus('" + objGrid.id + "')", 5);
		
		// persist the grid before re-populating.
		if (objApplication.PersistentXML != null)
			objApplication.PersistentXML.saveWindowSettings(objGrid.objAppWindow.m_strComponentId, objGrid.objAppWindow, "false");
	}

	m_objResizeObject = null;
	m_objMouseClickElement = null;
}

/**
 * Fixes intermittent screen corruption occuring when certain grids or grid columns are resized.
 */
function et_fixGridFocus(strGridId)
{
	var objGrid = this.window.eval(strGridId);
	try {
		objGrid.HTMLdiv.focus();
	} catch (objError) {
	}
}

function et_doMouseMove(objEvent) 
{
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;
	var objElement;
	var strMousePosition;
	var xMin = 24;
	var objResizeElement = null;
	var deltaX;

	if (m_objResizeObject == null)
		return;

	objElement = et_getClickedHeaderElement(objBrowserEvent);

	if (objElement == null)
	{
		m_objResizeObject = null;
		return;
	}

	var objGrid = et_getGridObject(m_objResizeObject.element);
	objGrid.grdSplitterBar.childNodes.item(0).style.left = getPosX(objEvent);
}

// Resizes the column to the best fit width.
function et_doHeaderDblClick(objEvent) 
{
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;
	var objElement;
	var strMousePosition;
	var xMin = 24;
	var objResizeElement = null;
	var deltaX;
	var objGrid = et_getGridObject(objBrowserEvent);
	
	et_doHeaderMouseDown(objEvent);

	if (m_objResizeObject == null)
		return;

	objElement = et_getClickedHeaderElement(objBrowserEvent);

	if (objElement == null)
	{
		m_objResizeObject = null;
		return;
	}

	if (m_objResizeObject.mouseposition.indexOf("left") != -1) // Re-size this element.
		objResizeElement = m_objResizeObject.element;
	else if (m_objResizeObject.mouseposition.indexOf("right") != -1) // Resize element to left of this.
		objResizeElement = m_objResizeObject.leftEl;

	var objGrid = et_getGridObject(objResizeElement);
	objGrid.grdSplitterBar.style.display = "none";

	objResizeElement.style.width = et_getMaxDataWidth(objGrid, objResizeElement);
	m_objResizeObject = null;

	if (objGrid.objGridEdit != null && objGrid.objGridEdit.objForm != null)
	{
		objGrid.objGridEdit.resizeFormFields();
		objGrid.objGridEdit.positionIFrame();
	}

	objGrid.HTMLtable.style.visibility = "hidden";
	objGrid.HTMLtable.style.visibility = "visible";

	// persist the grid before re-populating.
	if (objApplication.PersistentXML != null)
		objApplication.PersistentXML.saveWindowSettings(objGrid.objAppWindow.m_strComponentId, objGrid.objAppWindow, "false");
}

function et_getMaxDataWidth(objGrid, objHeaderElement) {

	var objElement;
	var objDataRows;
	var strInnerHTML;
	var intElementNumber;

	for (var intCtr=0; intCtr < objHeaderElement.parentNode.cells.length; intCtr++)
		if (objHeaderElement == objHeaderElement.parentNode.cells.item(intCtr))
			intElementNumber = intCtr;

	// Initialise length to length of header text itself.
	var intMaxLen = et_trimSpace(objHeaderElement.innerHTML.replace("<span class=arrow>6</span>", "").replace("<span class=arrow>5</span>", "")).length;

	// Get a ref to all table rows.
	objDataRows = objGrid.HTMLtable.tBodies[0].rows;
	for (var lngCtr=0; lngCtr < objDataRows.length; lngCtr++)
	{
		objElement = objDataRows.item(lngCtr).cells(intElementNumber);

		if (objElement != null)
		{
			if (objElement.lastChild == null || objElement.lastChild.tagName != "LABEL")
			{
			// Remove any sort arrows before testing the length of a heading.
			strInnerHTML = objElement.innerHTML.replace("<span class=arrow>6</span>", "");
			strInnerHTML = strInnerHTML.replace("<span class=arrow>5</span>", "");
			}
			else
				strInnerHTML = objElement.lastChild.innerHTML;
				
			if (et_trimSpace(strInnerHTML).length > intMaxLen)
				intMaxLen = et_trimSpace(strInnerHTML).length;
		}
	}

	// mcb - finish - 7 should be calculated fontsize.
	return intMaxLen * 7;

}

function et_getClickedHeaderElement(objElement) {

	var objTempElement = objElement;

	while ((objTempElement != null) && (objTempElement.tagName != "BODY"))
	{
		if (objTempElement.className != null)
		{
		if (objTempElement.className.indexOf("resizeMe") != -1)
		{
			objElement = objTempElement;
			return objTempElement;
		}
		}
		objTempElement = objTempElement.parentNode;
	}

	return objTempElement;

}

// Determine the mouseposition of the resize (whether the user clicks left or right
// of resize line) returns "left", "right", or "".
function et_getMousePosition(objElement) {
	var xPos;
	var offset;
	var retVal = "";

	xPos = objApplication.browser == APPLICATION_IE ? event.offsetX : 0;

	offset = 8; // The distance from the edge in pixels.

	// This test makes sure we can't drag the left edge of the first cell
	if (xPos < offset && objElement.cellIndex > 1)
		retVal = "right";
	else if (xPos > objElement.offsetWidth - offset)
		retVal = "left";

	return retVal;

}

function et_trimSpace(strString)
{
	return util_trim(strString);
}

// Passed parameters are overloaded - the extra params represent the data for the new row.
function et_insertRow(insertPosition, insertReferenceID)
{
	var strUID = arguments[2];
	
	var objHeadingNodes = this.objGridHeadingsXML.selectNodes("/grid/column");

	// Check args passed do not exceed number of columns in grid.
	if (et_checkNumberOfArgs(2, arguments, objHeadingNodes, this) == false)
		return;

	// Perform the XML data insert.
	var objXMLRowNode = et_performXMLDataInsert(this, insertPosition, insertReferenceID, arguments, objHeadingNodes);

	// Perform the HTML Row data insert.
	var objNewTR = et_performHTMLDataInsert(this, insertReferenceID, objXMLRowNode, strUID);

	// Set any grid rules
	var objRow = this.getRow(objNewTR.cells[0].innerHTML);
	// Loop through all rules and apply each to the specified row.
	for (var i=0; i<this.arrRules.length; i++)
	{
		var objRule = this.arrRules[i];
		
		if (this.processRule(objRule, objRow) == true)
			objRule.arrRows[objRule.arrRows.length] = objRow;
	}
	
	// Scroll the new row into view.
	if (this.scrollIntoView)
		objNewTR.scrollIntoView(false);
	
	return objNewTR;
}

function et_deleteRow(strUniqueID) 
{
	// Get the html rowindex for the <tr> based on the unique id we are deleting.
	var lngIndex = this.getRowIndex(strUniqueID);

	// Delete the <tr> from the <table>.
	this.HTMLtable.tBodies[0].deleteRow(lngIndex);

	var flgScroll = this.scrollIntoView;
	this.scrollIntoView = false;

	if (this.HTMLtable.tBodies[0].rows[lngIndex] != null)
		this.selectRow(this.HTMLtable.tBodies[0].rows[lngIndex].cells[0].innerHTML);
	else if (lngIndex > 0 && this.HTMLtable.tBodies[0].rows[lngIndex - 1] != null)
		this.selectRow(this.HTMLtable.tBodies[0].rows[lngIndex - 1].cells[0].innerHTML);
	else
	{
		var strMethodName = "GRID_" + this.id + "_rowClick";
		if (typeof(this.objAppWindow[strMethodName]) != "undefined") {
			this.objAppWindow[strMethodName]();
		}
	}
	
	//Remove the deleted row from this.arrSelectedRows by creating a new temporary 
	//array without it and then pointing this.arrSelectedRows to this new array.
	var lngUniqueID = Number(strUniqueID);
	var arrTempRows = new Array();
	for (var i=1, j=1, intLen = this.arrSelectedRows.length - 1; i < intLen; i++){
		if (i != lngUniqueID){
			arrTempRows[i] = this.arrSelectedRows[j++];
		}else{
			arrTempRows[i] = this.arrSelectedRows[++j];
		}
	}
	
	this.arrSelectedRows = arrTempRows;
	this.scrollIntoView = flgScroll;
}

function et_resynchronizeUniqueIDs()
{
	for (var i=1; i <= this.getRowCount(); i++) {
		this.HTMLtable.tBodies[0].rows[i-1].setAttribute("id", "et_grd" + this.id + "_uniqueTRid" + i);
		this.HTMLtable.tBodies[0].rows[i-1].cells[0].innerHTML = i;
	}
}

function et_getRowState(strUniqueID)
{
	// Get the a ref to the <tr> based on the unique id we are hiding/unhiding.
	var objTR = this.objAppWindow.document.getElementById("et_" + this.HTMLdiv.id + "_uniqueTRid" + strUniqueID);
	if (objTR == null)	{
		eMsgBox(fl("CANNOTGETROWSTATE", String(strUniqueID)), 0, msg_Critical, this.objAppWindow);
		return;
	}
	
	if (objTR.getAttribute("hidden"))
		return etc_HIDDEN;
	else
		return etc_VISIBLE;
}

function et_setRowState(strUniqueID, displayStatus)
{
	// Get the a ref to the <tr> based on the unique id we are hiding/unhiding.
	var objTR = this.objAppWindow.document.getElementById("et_" + this.HTMLdiv.id + "_uniqueTRid" + strUniqueID);
	if (objTR == null) {
		eMsgBox(fl("CANNOTSETROWSTATE", String(strUniqueID)), 0, msg_Critical, this.objAppWindow);
		return;
	}
	
	// Set the display style for the <tr>.
	if (displayStatus == etc_VISIBLE) {
		objTR.style.display = "inline";
		objTR.removeAttribute("hidden");
	}
	else {
		objTR.style.display = "none";
		objTR.setAttribute("hidden", "true");
	}
}

// Passed parameters are overloaded - the extra params represent the data for the new row.
function et_updateRow() 
{ 
	// Get a reference to the heading and data XML islands.
	var objHeadingNodes = this.objGridHeadingsXML.selectNodes("/grid/column");

	// Check args passed do not exceed number of columns in grid.
	if (et_checkNumberOfArgs(1, arguments, objHeadingNodes, this) == false)
		return;

	// Get the unique ID for the updated row.
	// This is always the first data parameter passed.
	strUniqueID = arguments[0];

	// Get a reference to the <tr> we need to update.
	var objTR = this.objAppWindow.document.getElementById("et_" + this.HTMLdiv.id + "_uniqueTRid" + strUniqueID);

	for (var intCtr=0; intCtr < objHeadingNodes.length(); intCtr++)
	{
		if (arguments[intCtr] == null)
			continue;

		// Update the HTML in the Grid.
		if (objTR.cells[intCtr].style.backgroundImage.indexOf("checkBoxTicked") != -1 || objTR.cells[intCtr].style.backgroundImage.indexOf("checkBoxNotTicked") != -1)
		{
			// if this is a checkbox, and has a gif attached, see if its heading node has an onClick, indicating that it is editable.
			var objHeadingNode=objHeadingNodes.item(intCtr);
			var bEditable=true;
			if ((objHeadingNode.getAttribute("onclick") == null) && (objHeadingNode.getAttribute("editable") == null || objHeadingNode.getAttribute("editable") == "false"))
				bEditable=false;
						
			if (arguments[intCtr] == -1 || arguments[intCtr] == "true") {
				if (bEditable)
					objTR.cells[intCtr].style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTicked.gif)";
				else 
					objTR.cells[intCtr].style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTickedDisabled.gif)";
				}
			else {
				if (bEditable) 
					objTR.cells[intCtr].style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTicked.gif)";
				else 
					objTR.cells[intCtr].style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTickedDisabled.gif)";					
				}
		}
		else {
			objTR.cells[intCtr].innerHTML = escapeXML(et_applyCellProperty(arguments[intCtr], objHeadingNodes.item(intCtr)));
			objTR.cells[intCtr].unformattedvalue = arguments[intCtr];
		}
	}
}

function et_checkNumberOfArgs(argNum, args, objHeadingNodes, objGrid) {

	var retVal = true;

	if (args.length <= argNum - 1)
	{
		eMsgBox(fl("NOTENOUGHGRIDARGS"), 0, msg_Critical, objGrid.objAppWindow);
		retVal = false;
	}

	if (args.length - argNum > objHeadingNodes.length())
	{
		eMsgBox(fl("TOOMANYGRIDARGS"), 0, msg_Critical, objGrid.objAppWindow);
		retVal = false;
	}

	return retVal;

}

function et_performXMLDataInsert(objGrid, insertPosition, insertReferenceID, args, objHeadingNodes) {
	// Create the new XML row that is to be inserted into the grid data xml island.
	var objXML = et_createNewXMLRow(args, objHeadingNodes);

	if (objGrid.objGridDataXML == null || objGrid.objGridDataXML.documentElement() == null)
	{
		if (objGrid.objGridHeadingsXML == null)
			objGrid.clear();
		else
			objGrid.objGridDataXML = objApplication.createXMLDocument("<grid />");
	}

	var objReferenceNode = objGrid.objGridDataXML.selectSingleNode("/grid/row/column[@name = 'uniqueid' and label/text() = '" + insertReferenceID + "']");

	// If we can't find the insert reference node - append new node to end of list.
	if (objReferenceNode == null)
		objXMLRowNode = objGrid.objGridDataXML.documentElement().appendChild(objXML.selectSingleNode("/row"));
	else
	{
		if (insertPosition == etc_BEFORE)
			objXMLRowNode = objGrid.objGridDataXML.documentElement().insertBefore(objXML.selectSingleNode("/row"), objReferenceNode.parentNode());
		else
		{
			// If nextSibling is null - append new node to end of list.
			if (objReferenceNode.parentNode().nextSibling() == null)
				objXMLRowNode = objGrid.objGridDataXML.documentElement().appendChild(objXML.selectSingleNode("/row"));
			else
				objXMLRowNode = objGrid.objGridDataXML.documentElement().insertBefore(objXML.selectSingleNode("/row"), objReferenceNode.parentNode().nextSibling());
		}
	}

	return objXMLRowNode;

}

function et_createNewXMLRow(args, objHeadingNodes) {
	var intCtr;
	var objNode;

	var objXML = objApplication.createXMLDocument();

	var strXML = "<row>";
	for (intCtr=0, objNode=objHeadingNodes.nextNode(); objNode != null; objNode=objHeadingNodes.nextNode(), intCtr++)
	{
		var strLabel = args[intCtr + 2];
		//Where strLabel is 0, we want it to be set to the escape character. isBlank for some reason returns true when 0 is passed to it.
		if (isBlank(strLabel) && strLabel != 0)
			strLabel = "&#160;";
		else
			strLabel = et_formatGridData(objNode, strLabel);
			
		strXML = strXML + "<column name='" + objNode.getAttribute("ref") + "' datatype ='" + objNode.getAttribute("datatype") + "' format = '" + objNode.getAttribute("format") + "' editable = '" + objNode.getAttribute("editable") + "'><label>" + strLabel + "</label></column>";
	}
	strXML = strXML + "</row>";
	objXML.loadXML(strXML);

	return objXML;

}

function et_performHTMLDataInsert(objGrid, insertReferenceID, objXMLRowNode, newID) {
	var lngBeforeHTMLIndex;
	var intCtr = 0;
	var objDataNode;
	var objNewTD;

	var objHeadingNodes = objGrid.objGridHeadingsXML.selectNodes("/grid/column");

	// Get the index of the next HTML row in the table. This is used when we come to insert the row HTML in the <table>.
	if (objXMLRowNode.nextSibling() == null)
		lngBeforeHTMLIndex = 0;
	else
		lngBeforeHTMLIndex = objGrid.objAppWindow.document.getElementById("et_" + objGrid.HTMLdiv.id + "_uniqueTRid" + insertReferenceID).rowIndex + 1;

	var objNewTR = objGrid.HTMLtable.tBodies[0].insertRow(lngBeforeHTMLIndex <= 0 ? -1 : lngBeforeHTMLIndex - 1);

	objNewTR.id = "et_" + objGrid.HTMLdiv.id + "_uniqueTRid" + newID;

	// Now loop through and add the new <td> elements.
	var objNodes = objXMLRowNode.selectNodes("column");

	if (objGrid.objGridEdit != null)
	{
		if (objGrid.objEditFormXML == null)
		{
			objGrid.objEditFormXML = objApplication.createXMLDocument();
			objGrid.objEditFormXML.loadURL(objGrid.objGridEdit.editFormSrc);
		}
	}

	for (objDataNode=objNodes.nextNode(); objDataNode != null; objDataNode=objNodes.nextNode())
	{
		objNewTD = objNewTR.insertCell(-1);

		objNewTD.unselectable = "on";
		objNewTD.noWrap = true;
			
		var objHeadingNode = objHeadingNodes.item(intCtr++);

		if (objHeadingNode.getAttribute("editable") == "true")
			objNewTD.style.cursor = "pointer";

		objNewTD.style.paddingLeft = "5px";
		objNewTD.style.paddingRight = "5px";
		objNewTD.style.backgroundRepeat = "no-repeat";
		objNewTD.style.backgroundPosition = "center";
	
		et_setTDCellProperties(objNewTD, objHeadingNode, objDataNode);

		if (objGrid.objGridEdit != null)
		{
			var objTextBox = objGrid.objEditFormXML.selectSingleNode("//textbox[@ref = '" + objHeadingNode.getAttribute("ref") + "']");

			if (objTextBox == null)
				continue;

			if (objTextBox.getAttribute("disabled") == "true")
				objNewTD.className = "ReadGridCell";
			else
				objNewTD.className = "EditGridCell";
		}
	}
	
	for (intCtr = 0; intCtr < objHeadingNodes.length(); intCtr++)
	{
		var objHeadingNode = objHeadingNodes.item(intCtr);

		if (objHeadingNode.getAttribute("hidden") == "true")
			objNewTR.cells[intCtr].style.display = "none";
	}

	return objNewTR;
}

function et_setTDCellProperties(objTD, objHeadingNode, objDataNode) {

	switch (objHeadingNode.getAttribute("datatype"))
	{
		case "xsd:float":
		case "xsd:double":
		case "xsd:integer":
		case "xsd:short":
		case "xsd:smallint":
		case "xsd:decimal":
			objTD.align = "right";
			objTD.innerHTML = et_applyCellProperty(objDataNode.selectSingleNode("label").getText(), objHeadingNode);
			objTD.unformattedvalue = objDataNode.selectSingleNode("label").getText();
			break;

		case "xsd:boolean":
			if ( objHeadingNode.getAttribute("yesno") == null || objHeadingNode.getAttribute("yesno") == "false") {
				// if this is a checkbox, and has a gif attached, see if its heading node has an onClick, indicating that it is editable.
				var bEditable=true;
			if ((objHeadingNode.getAttribute("onclick") == null) && (objHeadingNode.getAttribute("editable") == null || objHeadingNode.getAttribute("editable") == "false"))
					bEditable=false;						
			
				if ( (objDataNode.selectSingleNode("label").getText() == "-1") ||
					 (objDataNode.selectSingleNode("label").getText() == "true") ) {
					 if (bEditable) 
							objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTicked.gif)";
						else 	
							objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTickedDisabled.gif)";						
					}
				else {
					if (bEditable)
						objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTicked.gif)";
					else	
						objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTickedDisabled.gif)";
					}
				
				objTD.innerHTML = NBSP_CONSTANT;
			}
			else 
				objTD.innerHTML = objDataNode.selectSingleNode("label").getText();	
			break;

		default:   // strings and anything else unknown.
			/* 
			Need to escape the string for 'reserved' characters.
			Need to pass actual single quotes though as the text is parsed when setting through innerHTML and for some reason the ampersand in [ampersand]apos; is re-escaped - for example it becomes [ampersand]amp;apos;
			Strange as this is not the case for '<' ([ampersand]lt;) - it stays as [ampersand]lt;
			Because of this need to pass actual single quotes.
			*/
			var str = et_applyCellProperty(objDataNode.selectSingleNode("label").getText(), objHeadingNode);
			str = escapeXML(str);
			str = unescapeXMLSingleQuote(str);
			objTD.innerHTML = str;
			break;
	}

}

/*
 * Apply any formatting to the cell value dependent on its data type.
 * @param strData Data
 * @param objHeadingNode Node
 * @return Formatted value
 */
function et_applyCellProperty(strData, objHeadingNode) {
	// cast to a string as passing a number class object with value 0 to isBlank causes a "true" to be returned. 
	if (isBlank(String(strData))) {
		return "";
	}

	var strDataType = objHeadingNode.getAttribute("datatype");
	
	if (strDataType == "xsd:string") {
		return strData;
	}
	else if (strDataType == "xsd:float" || strDataType == "xsd:double" || strDataType == "xsd:decimal")
	{
		var strDigitsBeforePoints = objHeadingNode.getAttribute("digits-before-point");
		var strDigitsAfterPoints = objHeadingNode.getAttribute("digits-after-point");
		
		if (!isBlank(strDigitsAfterPoints) && !isBlank(strDigitsBeforePoints) && strDigitsBeforePoints != "-1" && strDigitsAfterPoints != "-1")
			return objApplication.getNumberFormatter().getLocaleNumber(strData, strDigitsAfterPoints);
	}
	else if (strDataType == "xsd:integer" || strDataType == "xsd:short" || strDataType == "xsd:smallint")
	{
		if (objHeadingNode.getAttribute("ref") == "uniqueid" || objHeadingNode.getAttribute("serial-format") == "true")
			return strData;
		else	
			return formatInteger(strData);
	}
	else if (strDataType == "xsd:dateTime") {
		var objEfacsCalendar=objApplication.getCalendarParser();
		if (!isISODate(strData)) 
			return strData;
		else {	
			var objEfacsCalendar=objApplication.getCalendarParser();
			objEfacsCalendar.setDateTimeInISO(strData);
			return objEfacsCalendar.getDateTimeInLocaleFormat();
		}
	}
	
	return strData;
}

function et_selectRow(strUniqueID, flgKeepAlreadySelected) 
{
	if (strUniqueID == null)
		return;

	// Get the html rowindex for the <tr> based on the unique id we are selecting.
	var lngIndex = this.getRowIndex(strUniqueID);
	this.keyboardRowPointer = lngIndex;
	
	// Select the <tr> in the <table>.
	var objSelectedTR = this.objAppWindow.document.getElementById("et_" + this.HTMLdiv.id).tBodies[0].rows[lngIndex];

	et_toggleRowSelected(this, objSelectedTR, flgKeepAlreadySelected);

	// Scroll the new row into view.
	if (this.scrollIntoView)
		objSelectedTR.scrollIntoView(false);
}

/** 
 * Selects the row with passed row index.
 *
 * @param intRowIndex The row index of the row to be highlighted.
 */
function et_selectRowIndex(intRowIndex)
{
	this.keyboardRowPointer = intRowIndex;
	
	// Select the <tr> in the <table>.
	var objSelectedTR = this.objAppWindow.document.getElementById("et_" + this.HTMLdiv.id).tBodies[0].rows[intRowIndex];

	et_toggleRowSelected(this, objSelectedTR);

	// Scroll the new row into view.
	if (this.scrollIntoView)
		objSelectedTR.scrollIntoView(false);
}

/** 
 * Highlighs the row with passed unique id.
 *
 * @param strUID The unique id of the row to be highlighted.
 */
function et_highlightRow(strUID)
{
	// Get the html rowindex for the <tr> based on the unique id we are selecting.
	var lngIndex = this.getRowIndex(strUID);
	
	// Select the <tr> in the <table>.
	var objSelectedTR = this.objAppWindow.document.getElementById("et_" + this.HTMLdiv.id).tBodies[0].rows[lngIndex];

	et_toggleRowSelected(this, objSelectedTR, true, null, false);
}

function et_focusRow(strUniqueID) 
{
	if (this.objGridDataXML == null)
		return;

	if (this.objGridDataXML.selectSingleNode("/grid/row/column[@name = 'uniqueid' and label = '" + strUniqueID + "']").parentNode() == null)
		return;
		
	// Get the html rowindex for the <tr> based on the unique id we are selecting.
	var lngIndex = this.objAppWindow.document.getElementById("et_" + this.HTMLdiv.id + "_uniqueTRid" + strUniqueID).rowIndex - 1;

	// Select the <tr> in the <table>.
	var objSelectedTR = this.objAppWindow.document.getElementById("et_" + this.HTMLdiv.id).tBodies[0].rows[lngIndex];

	// Original colour can vary row by row.
	if (objSelectedTR.getAttribute("xloc") == null) {
		objSelectedTR.setAttribute("xloc", objSelectedTR.currentStyle.color);
	}

	// If this is the first time we are setting background colours, use the
	// className attribute to fecth all the background colours we need.
	// Next time we will be able to use the style.background property to set
	// the background colours as this is much faster than changing the class name
	// every highlight/de-highlight.
	if (m_strRowHighlightedColour == "")
	{
		var strCurrentRowClass = objSelectedTR.className;
		objSelectedTR.removeAttribute("style");
		objSelectedTR.className = "gridRowSelected";
		if (objApplication.browser == APPLICATION_IE) {
			m_strRowSelectedColour = objSelectedTR.currentStyle.backgroundColor;
			m_strRowSelectedTextColour = objSelectedTR.currentStyle.color;
		}
		
		objSelectedTR.className = "gridRowHighlight";
		if (objApplication.browser == APPLICATION_IE)
		m_strRowHighlightedColour = objSelectedTR.currentStyle.backgroundColor;
		objSelectedTR.className = strCurrentRowClass;
	}
	if (m_strRowHighlightedColour != "")
		objSelectedTR.style.backgroundColor = m_strRowHighlightedColour;

	
	var objGrid = et_getGridObject(objSelectedTR);

	// if mouseover function defined call (passing uniqueid)	
	if (objGrid.onmouseover != null) {
		objGrid.onmouseover(objSelectedTR.id.substr(objSelectedTR.id.lastIndexOf("_uniqueTRid") + 11));
	}		

}

function et_blurRow(strUniqueID) 
{
	if (this.objGridDataXML == null)
		return;

	if (this.objGridDataXML.selectSingleNode("/grid/row/column[@name = 'uniqueid' and label = '" + strUniqueID + "']").parentNode() == null)
		return;

	// Get the html rowindex for the <tr> based on the unique id we are selecting.
	var lngIndex = this.objAppWindow.document.getElementById("et_" + this.HTMLdiv.id + "_uniqueTRid" + strUniqueID).rowIndex - 1;

	// Select the <tr> in the <table>.
	var objSelectedTR = this.objAppWindow.document.getElementById("et_" + this.HTMLdiv.id).tBodies[0].rows[lngIndex];

	objSelectedTR.style.backgroundColor = "transparent";
	
	var objGrid = et_getGridObject(objSelectedTR);
	
	// if mouseover function defined call (passing uniqueid)	
	if (objGrid.onmouseout != null) {
		objGrid.onmouseout(objSelectedTR.id.substr(objSelectedTR.id.lastIndexOf("_uniqueTRid") + 11));
	}	

}

// Returns an array of passed column name values for all selected rows.
function et_getSelectedColumnValue(strColumnName)
{
	var intCellIndex = 0;
	
	// Get cell index for required column.
	var intCellIndex = this.getColumnCellIndex(strColumnName);

	return this.getSelectedColumnValueByIndex(intCellIndex);
}

// Returns an array of passed column name values for all selected rows.
function et_getSelectedColumnValueByIndex(intCellIndex, flgUnformatted)
{
	// Now build up an array of selected column values.	
	var arrValues = new Array();
	var objTableRows = this.HTMLtable.tBodies[0].rows;
	var strValue;
	for (var intCtr = 0; intCtr != objTableRows.length; intCtr++)
	{
		if (objTableRows[intCtr].selected == "true")
		{
			objTD = objTableRows[intCtr].cells[intCellIndex];

			if (this.isTreeGrid == true && objTD.childNodes.length > 1)
				strValue = objTD.lastChild.innerHTML;
			else
				strValue = objTD.innerHTML;

			strValue = unescapeXML(strValue);
			
			if (strValue == NBSP_CONSTANT)
				strValue="";
			
			var objHeadTD = this.HTMLtable.tHead.rows[0].cells[intCellIndex];
			if (intCellIndex > 0 &&
				(objHeadTD.type == "xsd:float" || objHeadTD.type == "xsd:double" ||
				 objHeadTD.type == "xsd:integer" || objHeadTD.type == "xsd:short" ||
				 objHeadTD.type == "xsd:smallint" || objHeadTD.type == "xsd:decimal"))
			{
				if (flgUnformatted)
				{
					if (this.isTreeGrid == true && objTD.childNodes.length > 1)
						strValue = objTD.lastChild.unformattedvalue;
					else
						strValue = objTD.unformattedvalue;
				}
				
				var strNumber = Number(util_parseNumber(strValue));
				if (!isNaN(strNumber))
					strValue = strNumber;
			}

			if (strValue == "")
			{
				if (objTD.style.backgroundImage.indexOf("checkBoxTicked") != -1)
					strValue = cb_CHECKED;
				else if (objTD.style.backgroundImage.indexOf("checkBoxNotTicked") != -1)
					strValue = cb_UNCHECKED;
			}
			arrValues[arrValues.length] = strValue;
		}
	}

	return arrValues;
}

/**
 * Set the column label for this field
 * @param strColumn Grid column
 * @param strLabel New label text
 */
function et_setLabelText(strColumn, strLabel) {
	var objHeadingRow = this.HTMLtable.rows[0];
	var intCellIndex = this.getColumnCellIndex(strColumn);
	objHeadingRow.cells[intCellIndex].innerHTML = strLabel;
}

// Returns the value for the passed column name and uniqueid.
function et_getColumnValue(strUniqueID, strColumnName, flgUnformatted)
{
	// Get cell index for required column.
	var intCellIndex = this.getColumnCellIndex(strColumnName);

	// Now get the value for the requested column.	
	var objTableRows = this.HTMLtable.tBodies[0].rows;
	var index = this.getRowIndex(strUniqueID);

	var objTD = objTableRows[index].cells[intCellIndex];
	var strValue;	
	if (this.isTreeGrid == true && objTD.childNodes.length > 1)
		strValue = objTD.lastChild.innerHTML;
	else
		strValue = objTD.innerHTML;

	strValue = unescapeXML(strValue);
	
	if (strValue == NBSP_CONSTANT)
		strValue="";
	
	var objHeadTD = this.HTMLtable.tHead.rows[0].cells[intCellIndex];
	if (intCellIndex > 0 &&
		(objHeadTD.type == "xsd:float" || objHeadTD.type == "xsd:double" ||
		 objHeadTD.type == "xsd:integer" || objHeadTD.type == "xsd:short" ||
	     objHeadTD.type == "xsd:smallint" || objHeadTD.type == "xsd:decimal"))
	{
		if (flgUnformatted)
		{
			if (this.isTreeGrid == true && objTD.childNodes.length > 1)
				strValue = objTD.lastChild.unformattedvalue;
			else
				strValue = objTD.unformattedvalue;
		}
		
		strValue = Number(util_parseNumber(strValue));
	}
	
	if (strValue == "")
	{
		if (objTD.style.backgroundImage.indexOf("checkBoxTicked") != -1)
			strValue = cb_CHECKED;
		else if (objTD.style.backgroundImage.indexOf("checkBoxNotTicked") != -1)
			strValue = cb_UNCHECKED;
	}
	return strValue;
}

/**
 * Sets the value for the passed column name and uniqueid to the supplied value
 * @param strUniqueID Unique id
 * @param strColumnName Column name
 * @param strValue Column value
 * @param flgReadOnly Read only
 */
function et_setColumnValue(strUniqueID, strColumnName, strValue, flgReadOnly)
{
	// Get cell index for required column.
	var intCellIndex = this.getColumnCellIndex(strColumnName);

	// Now get the value for the requested column.	
	var objTableRows = this.HTMLtable.tBodies[0].rows;
	var index = this.getRowIndex(strUniqueID);

	var objTD = objTableRows[index].cells[intCellIndex];
	if (objTD.style.backgroundImage.indexOf("checkBoxTicked") != -1 || objTD.style.backgroundImage.indexOf("checkBoxNotTicked") != -1)
	{
		objTD.innerHTML == "";
		if (strValue == cb_UNCHECKED || strValue == "false")
		{
			if (flgReadOnly == cb_READONLY || (objTD.style.backgroundImage.indexOf("TickedDisabled") != -1 ))
				objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTickedDisabled.gif)";
			else
				objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTicked.gif)";
		}
		else if (strValue == cb_CHECKED || strValue == "true")
		{
			if (flgReadOnly == cb_READONLY || (objTD.style.backgroundImage.indexOf("TickedNotDisabled") != -1 ))
				objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTickedDisabled.gif)";
			else
				objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTicked.gif)";
		}
	}
	else
	{
		objTD.innerHTML = et_applyCellProperty(strValue, this.objGridHeadingsXML.selectNodes("/grid/column").item(intCellIndex));
		
		if (objTD.unformattedvalue != null)
			objTD.unformattedvalue = strValue;
	}
}

/**
 * Sets the value for the passed column name and uniqueid to the supplied value.
 * (As for et_setColumnValue but accesses the row directly.)
 */
function et_setTreeColumnValue(strUniqueID, strColumnName, strValue, flgReadOnly)
{

	// Get cell index for required column.
	var intCellIndex = this.getColumnCellIndex(strColumnName);

	// Now get the value for the requested column.	
	var objRow = this.objAppWindow.document.getElementById("et_grd" + this.id + "_uniqueTRid" + strUniqueID);
	var objTD = objRow.cells[intCellIndex];

	if (objTD.style.backgroundImage.indexOf("checkBoxTicked") != -1 || objTD.style.backgroundImage.indexOf("checkBoxNotTicked") != -1)
	{
		objTD.innerHTML == "";
		if (strValue == cb_UNCHECKED)
		{
			if (flgReadOnly == cb_READONLY || (objTD.style.backgroundImage.indexOf("TickedDisabled") != -1 ))
				objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTickedDisabled.gif)";
			else
				objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTicked.gif)";
		}
		else if (strValue == cb_CHECKED )
		{
			if (flgReadOnly == cb_READONLY || (objTD.style.backgroundImage.indexOf("TickedNotDisabled") != -1 ))
				objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTickedDisabled.gif)";
			else
				objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTicked.gif)";
		}
	}
	else
	{
		objTD.innerHTML = et_applyCellProperty(strValue, this.objGridHeadingsXML.selectNodes("/grid/column").item(intCellIndex));
	}
}

/**
 * Sets the values for all rows in the passed column name to the supplied value
 * @param strColumnName Column name
 * @param strValue Column value
 * @param flgReadOnly Read only
 */
function et_setColumnValues(strColumnName, strValue, flgReadOnly)
{
	// Get cell index for required column.
	var intCellIndex = this.getColumnCellIndex(strColumnName);

	// Now get the value for the requested column.	
	var objTableRows = this.HTMLtable.tBodies[0].rows;
	
	for (var i=0, intLen = objTableRows.length; i < intLen; i++)
	{
		var objTD = objTableRows[i].cells[intCellIndex];
	
		if (objTD.style.backgroundImage.indexOf("checkBoxTicked") != -1 || objTD.style.backgroundImage.indexOf("checkBoxNotTicked") != -1)
		{
			objTD.innerHTML == "";
			if (strValue == cb_UNCHECKED || strValue == "false")
			{
				if (flgReadOnly == cb_READONLY)
					objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTickedDisabled.gif)";
				else
					objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTicked.gif)";
			}
			else if (strValue == cb_CHECKED || strValue == "true")
			{
				if (flgReadOnly == cb_READONLY)
					objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTickedDisabled.gif)";
				else
					objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTicked.gif)";
			}
		}
		else
		{
			objTD.innerHTML = et_applyCellProperty(strValue, this.objGridHeadingsXML.selectNodes("/grid/column").item(intCellIndex));
		}
	}
}

function et_setHeight(strHeight, strAdjustment) {
	var intAdjustment;

	if (isBlank(strAdjustment))
		intAdjustment = 0;
	else
		intAdjustment = parseInt(strAdjustment);

	// Allow for the grid header.
	if (this.hasTitle) {
		intAdjustment += 35;
	}
	
	if (strHeight.indexOf("%") != -1)
	{
		var strPercentValue = parseInt(strHeight);
		var strHeight = ((getDocumentBodyHeight(this.objAppWindow) * strPercentValue / 100) - intAdjustment) + "px";
	}
	
	// Check for negative height.
	if (strHeight.indexOf("-") != -1)
		return;
		
	this.HTMLdiv.style.height = strHeight;
	
	if (this.HTMLdiv.offsetHeight < 50)
		this.HTMLdiv.style.height = "50px";
}

function et_setWidth(strWidth, strAdjustment)
{
	var intAdjustment;

	if (isBlank(strAdjustment))
		intAdjustment = 0;
	else
		intAdjustment = parseInt(strAdjustment);

	/* Extra adjustment for the wrapper div */
	if (this.hasTitle) {
		intAdjustment += 8;
	}
	
	if (strWidth.indexOf("%") != -1)
	{
		var strPercentValue = parseInt(strWidth);
		strWidth = ((getDocumentBodyWidth(this.objAppWindow) * strPercentValue / 100) - intAdjustment) + "px";
	}

	// Check for negative width.
	if (strWidth.indexOf("-") != -1)
		return;
		
	this.HTMLdiv.style.width = strWidth;
}

function et_setColumnOnClick(strColumnRef, strAction) {
	this.objGridHeadingsXML.selectSingleNode("/grid/column[@ref='" + strColumnRef + "']").setAttribute("onclick", strAction);
}

function et_showColumn(strRef)
{
	var objColElement = this.objAppWindow.document.getElementById("grid_col_" + strRef);
	if (objColElement == null)
	{
		this.objAppWindow.alert("Grid.js - cannot find column <" + strRef + "> to show.");
		return;
	}

	objColElement.style.display = "inline";
	var objNode = this.objGridHeadingsXML.selectSingleNode("/grid/column[@ref = '" + strRef + "']");
	var intIndex = objNode.nodeIndex();
	objNode.setAttribute("hidden", "false");

	var objRows = this.HTMLtable.tBodies[0].rows;
	for (var intCtr = 0; intCtr < objRows.length; intCtr++)
	{
		objRows[intCtr].cells[intIndex].style.display = "inline";
	} 
}

function et_hideColumn(strRef)
{
	var objColElement = this.objAppWindow.document.getElementById("grid_col_" + strRef);
	if (objColElement == null)
	{
		this.objAppWindow.alert("Grid.js - cannot find column <" + strRef + "> to hide.");
		return;
	}

	objColElement.style.display = "none";

	var objNode = this.objGridHeadingsXML.selectSingleNode("/grid/column[@ref = '" + strRef + "']");
	var intIndex = objNode.nodeIndex();
	objNode.setAttribute("hidden", "true");
	
	var objRows = this.HTMLtable.tBodies[0].rows;
	for (var intCtr = 0; intCtr < objRows.length; intCtr++)
	{
		objRows[intCtr].cells[intIndex].style.display = "none";
	} 
}

function et_hide()
{
	this.HTMLdiv.style.display = "none";
}

function et_show()
{
	this.HTMLdiv.style.display = "inline";
}

function et_isVisible()
{
	if (this.HTMLdiv.style.display == "none")
		return false;
	else
		return true;
}

/**
 * Add items to the context menu
 * @param strLabel The label
 * @param strMethodName The method name
 * @param strImageName The icon
 * @param strButtonId The button id
 * @param tooltip The tooltip
 * @param actionObject The action object
 * @param flgToggle Whether the button is a toggle button
 * @param strToolbarid The toolbar id
 */
function et_addContextMenuOption(strLabel, strMethodName, strImageName, strButtonId, tooltip, actionObject, flgToggle, strToolbarid, flgDynamic)
{
	// MCB review - temporarily remove eNotes option from context menu.
	if (strLabel == "eNotes")
		return;

	if (isBlank(actionObject) && strMethodName.indexOf(".") != -1)
		actionObject = strMethodName.substring(0, strMethodName.indexOf("."));
	
	this.arrContextOptions[this.arrContextOptions.length] = new GridContextOption(strLabel, strMethodName, strImageName, strButtonId, tooltip, actionObject, flgToggle, strToolbarid, flgDynamic);
}

/**
 * Constructor for a grid context option
 * @param strLabel The label
 * @param strMethodName The method to be called
 * @param strImageName The icon
 * @param strButtonId The button id
 * @param tooltip The tooltip
 * @param actionObject The action object
 * @param flgToggle Whether the corresponding button is a toggle button
 * @param strToolbarid The corresponding toolbar id
 */
function GridContextOption(strLabel, strMethodName, strImageName, strButtonId, tooltip, actionObject, flgToggle, strToolbarid, flgDynamic)
{
	this.label = strLabel;
	this.methodName = strMethodName;
	this.imageName = strImageName;
	this.buttonId = strButtonId;
	this.tooltip = tooltip;
	this.actionObject = actionObject;
	this.flgToggle = flgToggle;
	this.strToolbarid = strToolbarid;
	this.destroy = et_gco_destroy;
	this.isDynamic = flgDynamic;
}

/**
 * Clear the references to grid context option objects
 */
function et_gco_destroy() {
	try {
		this.label = null;
		this.methodName = null;
		this.imageName = null;
		this.buttonId = null;
		this.tooltip = null;
		this.actionObject = null;
		this.strToolbarid = null;
		this.isDynamic = null;
	} catch (error) {
	}
}

function et_doContextMenu(objEvent)
{
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;
	var objGrid = et_getGridObject(objBrowserEvent);

	if (objGrid.arrContextOptions.length == 0)
		return;

	if (objGrid.getSelectedColumnValue("uniqueid").length < 2)
	{
		var objCurrentRow = getParentElement(objBrowserEvent, "tr");
		et_toggleRowSelected(objGrid, objCurrentRow, false, objEvent);
	}

	var objElement = objEvent.srcElement;
	if (objElement.tagName != "TD")
		return;

	var strColumnRef = objGrid.HTMLtable.tHead.rows[0].cells[et_getCellIndex(objElement)].id.replace("grid_col_", "");
	var objHeadNode = objGrid.objGridHeadingsXML.selectSingleNode("/grid/column[@ref = '" + strColumnRef + "']");
	var strInfoPanel = objHeadNode.getAttribute("infopanel");

	var contextMenu  = new ContextMenu();
	var objOption;
	var flgDisabled;
	var flgInfoPanelAdded = false;
	
	// Call any app specific right click method
	if (!isBlank(objGrid.onRightClick)) {
		// remove any dynamic options as they will be re-added
		var arrContextOptionsNew = new Array();
		var x = 0;
		for (var intCtr=0; intCtr < objGrid.arrContextOptions.length; intCtr++) {
			if (objGrid.arrContextOptions[intCtr].isDynamic != true) {
				arrContextOptionsNew[x++] = objGrid.arrContextOptions[intCtr];
			}
		}
		
		objGrid.arrContextOptions = arrContextOptionsNew;
		
		var evalFunction = new Function("objGrid", objGrid.onRightClick + "(objGrid)");
		evalFunction(objGrid);
	}
		
	for (var intCtr=0; intCtr < objGrid.arrContextOptions.length; intCtr++)
	{
		objOption = objGrid.arrContextOptions[intCtr];
		
		if (intCtr == 0 && objOption.label == "--------")
			continue;
		
		if ((objOption.methodName.indexOf(".fireInfoPanel") != -1 && isBlank(strInfoPanel)) || (objOption.methodName.indexOf(".fireInfoPanel") != -1 && flgInfoPanelAdded == true))
			continue;
		
		flgDisabled = false;
		
		if (objOption.buttonId != "" && objOption.buttonId != null)
		{
			if (isHTMLElementVisible(window.document.getElementById(objOption.buttonId)) == false)
				continue;

			flgDisabled = window.document.getElementById(objOption.buttonId).disabled;
		}

		if (objOption.actionObject != null && typeof(objOption.actionObject) == "string")
			objOption.actionObject = eval(objOption.actionObject);

		var objArgs;
		if (objOption.imageName == "InfoPanel")
		{
			objArgs = new Array(objGrid, objGrid.getSelectedColumnValue("uniqueid"), strColumnRef, strInfoPanel);
			flgInfoPanelAdded = true;
		}
		else
			objArgs = new Array(objGrid, objGrid.getSelectedColumnValue("uniqueid"));

		var strMethod = objOption.methodName;
		if (strMethod.indexOf("(") != -1)
			strMethod = strMethod.substring(0, strMethod.indexOf("("));

		contextMenu.addOption(objOption.label, objOption.imageName, eval(strMethod), objArgs, null, null, null, false, null, flgDisabled, objOption.tooltip, objOption.actionObject, objOption.flgToggle, objOption.strToolbarid, objOption.buttonId);
	}
	
	// add field actions
	var objActions = objGrid.objGridHeadingsXML.selectSingleNode("/grid/column[@ref= '" + strColumnRef + "']/actions");
	if (objActions != null) {
		var objActionList = objActions.selectNodes("item");
		var flag = true;
		for (objAction = objActionList.nextNode(); objAction != null; objAction = objActionList.nextNode()) {
			var strActionLabel = objAction.getAttribute("label");
			var strActionApp = objAction.getText();
			var strActionMode = objAction.getAttribute("mode");
			var strImage = objAction.getAttribute("image");
			
			if (strActionApp == "appCallMan" && ! objApplication.Modules("0071a-cti"))
				continue; // No CTI module
			
			if (flag) {
				contextMenu.addOption("--------");
				flag = false;
			}
			
			var objFieldAction =  new FieldAction(strActionLabel, strActionApp, strActionMode, strImage);
			if (strActionApp == "appCallMan")
				contextMenu.addOption(objFieldAction.strLabel, strImage, et_triggerAction, new Array(objGrid.getSelectedColumnValue(strColumnRef)[0], objFieldAction, objGrid, strColumnRef), objFieldAction.strMode, objFieldAction.strLabel, null, true, 1);				
			else
				contextMenu.addOption(objFieldAction.strLabel, strImage, et_triggerAction, new Array(objGrid.getSelectedColumnValue(strColumnRef)[0], objFieldAction, objGrid, strColumnRef));
		}
	}
	
	if (contextMenu.options.length > 0) {
		contextMenu.show(getPosX(objEvent), getPosY(objEvent));
	}
}

function et_fireInfoPanel()
{
	var objGrid = arguments[0].params[0];
	var strUID = arguments[0].params[1][0];
	var strColumnRef = arguments[0].params[2];
	var strInfoPanel = arguments[0].params[3];
	
	var objHeadNode = objGrid.objGridHeadingsXML.selectSingleNode("/grid/column[@ref = '" + strColumnRef + "']");
	var objInputs = objHeadNode.selectNodes("info-panel-inputs/info-panel-input");
	
	var objRow = objGrid.getRow(strUID);
	var strKeyValues = "";
	if (objInputs.length() == 0)
		strKeyValues = "&value0=" + replaceForURL(b64Encode(objRow.getRowValue(strColumnRef)));
	else
	{
		var intCtr = 0;
		for (var objInput = objInputs.nextNode(); objInput != null; objInput = objInputs.nextNode())
		{
			var strVal = objRow.getRowValue(objInput.getAttribute("ref"));
			strKeyValues += "&value" + intCtr + "=" + replaceForURL(b64Encode(strVal));
			intCtr++;
		}
	}
		
	var strTitle = replaceForURL(b64Encode(objHeadNode.selectSingleNode("caption").getText()));
	
	var objTopWindow = window;
	for (var objWindow = window.parent; objWindow != null; objWindow = objWindow.opener)
	{
		objTopWindow = objWindow;

		var objApplet = objTopWindow.document.getElementById(objApplication ? (objApplication.browser == APPLICATION_IE ? "EfacsApplet" : "EfacsAppletNN") : (navigator.appName == "Netscape" ? "EfacsAppletNN" : "EfacsApplet"))
		if (objApplet != null)
			break;
	}
	
	var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/InfoPanels_HTML/" + strInfoPanel + ".html?panel=" + strInfoPanel + strKeyValues + "&title=" + strTitle;
	objApplication.openChildWindow(objTopWindow, strURL, objApplication.User.company + objApplication.User.userID + strInfoPanel);
}

function et_getRowIndex(strUniqueID)
{
	var retval = 0;
	
	// Get current row index from current uniqueid.
	var objRows = this.HTMLtable.tBodies[0].rows;
	for (var intCtr = 0; intCtr < objRows.length; intCtr++)
	{
		if (unescapeXML(objRows[intCtr].cells[0].innerHTML) == strUniqueID)
		{
			retval = intCtr;
			break;
		}
	}
	return retval;
}

function et_getRowCount()
{
	return this.HTMLtable.tBodies[0].rows.length;
}

// Returns an array of all values for the specified column.
function et_getColumnValues(strColumnName, flgUnformatted)
{
	var arrColumnValues = new Array();
	
	// Get cell index for required column.
	var intCellIndex = this.getColumnCellIndex(strColumnName);

	// Now get the value for the requested column.	
	var objTableRows = this.HTMLtable.tBodies[0].rows;
	for (var index = 0; index < objTableRows.length; index++)
	{
		var objTD = objTableRows[index].cells[intCellIndex];
		var strValue;
		if (this.isTreeGrid == true && objTD.childNodes.length > 1)
			strValue = objTD.lastChild.innerHTML;
		else
			strValue = objTD.innerHTML;

		strValue = unescapeXML(strValue);
		
		if (strValue == NBSP_CONSTANT)
			strValue="";
		
		var objHeadTD = this.HTMLtable.tHead.rows[0].cells[intCellIndex];
		if (intCellIndex > 0 &&
			(objHeadTD.type == "xsd:float" || objHeadTD.type == "xsd:double" ||
			 objHeadTD.type == "xsd:integer" || objHeadTD.type == "xsd:short" ||
			 objHeadTD.type == "xsd:smallint" || objHeadTD.type == "xsd:decimal"))
		{
			if (flgUnformatted)
			{
				if (this.isTreeGrid == true && objTD.childNodes.length > 1)
					strValue = objTD.lastChild.unformattedvalue;
				else
					strValue = objTD.unformattedvalue;
			}
			
			strValue = Number(util_parseNumber(strValue));
		}
		
		if (strValue == "")
		{
			if (objTD.style.backgroundImage.indexOf("checkBoxTicked") != -1)
				strValue = cb_CHECKED;
			else if (objTD.style.backgroundImage.indexOf("checkBoxNotTicked") != -1)
				strValue = cb_UNCHECKED;
		}
		
		arrColumnValues[index] = strValue;
	}
	return arrColumnValues;
}

// Gets the cell index for the specified column
function et_getColumnCellIndex(strColumnName)
{
	var intCellIndex = 0;

	var objCells = this.HTMLtable.tHead.rows[0].cells;
	for (var intCtr = 0; intCtr < objCells.length; intCtr++)
	{
		if (objCells[intCtr].id.replace("grid_col_", "") == strColumnName)
		{
			intCellIndex = intCtr;
			break;
		}
	}

	return intCellIndex;
}

/** Returns an array of row objects.  The rows returned are those 
 * that match the supplied criteria
 * @param strColumnName The column
 * @param strValue The value to match
 * @param flgUnformatted Get the unformatted value
 * @return Array of rows
 */
function et_getMatchedRows(strColumnName, strValue, flgUnformatted)
{
	var arrRows = new Array();

	// Get cell index for required column.
	var intCellIndex = this.getColumnCellIndex(strColumnName);

	// Now try to match the value to that supplied.	
	var objTableRows = this.HTMLtable.tBodies[0].rows;

	for (var index = 0; index < objTableRows.length; index++)
	{
		var objTD = objTableRows[index].cells[intCellIndex];
		var strCellValue;
		// REVIEW This could be improved to work for editable grids
		// Check for tree grid column. If so then will have value in the last child LABEL element.
		if (this.isTreeGrid == true && objTD.childNodes.length > 0)
			strCellValue = objTD.lastChild.innerHTML;
		else
			strCellValue = objTD.innerHTML;

		strCellValue = unescapeXML(strCellValue);

		var objHeadTD = this.HTMLtable.tHead.rows[0].cells[intCellIndex];
		if (intCellIndex > 0 &&
			(objHeadTD.type == "xsd:float" || objHeadTD.type == "xsd:double" ||
			 objHeadTD.type == "xsd:integer" || objHeadTD.type == "xsd:short" ||
			 objHeadTD.type == "xsd:smallint" || objHeadTD.type == "xsd:decimal"))
		{
			if (flgUnformatted)
			{
				if (this.isTreeGrid == true && objTD.childNodes.length > 1)
					strValue = objTD.lastChild.unformattedvalue;
				else
					strValue = objTD.unformattedvalue;
			}
		}
		
		if (strCellValue == NBSP_CONSTANT)
			strCellValue="";

		if (strCellValue == "")
		{
			if (objTD.style.backgroundImage.indexOf("checkBoxTicked") != -1)
				strCellValue = cb_CHECKED;
			else if (objTD.style.backgroundImage.indexOf("checkBoxNotTicked") != -1)
				strCellValue = cb_UNCHECKED;
		}
		if (strValue == strCellValue)
		{
			// For those rows where a match has been found create Row objects		
			var row = new Row(objTableRows[index], this);
				
			arrRows[arrRows.length] = row;
		}
	}
	return arrRows;
}
/** Get the max unique ID value
 * @return Maximum unique ID
 */
function et_getMaxUniqueID()
{
	var arrIDs = this.getColumnValues("uniqueid");
	var intMaxID = 0;
	for (var index = 0; index < arrIDs.length; index++)
	{
		if (Number(arrIDs[index]) > intMaxID) 
		{
			intMaxID = Number(arrIDs[index]);
		}
	}
	return intMaxID;
}

/** Get all the rows
 * @return Array of rows
 */
function et_getRows()
{
	var arrRows = new Array();

	// Now try to match the value to that supplied.	
	var objRows = this.HTMLtable.tBodies[0].rows;

	for (var index = 0; index < objRows.length; index++)
	{
		var row = new Row(objRows[index], this);
			
		arrRows[arrRows.length] = row;
	}
	return arrRows;
}

/** Get a row
 * @param lngUniqueId The unique ID
 * @return The row
 */
function et_getRow(lngUniqueId)
{
	if (this.arrSelectedRows[lngUniqueId] == null)
	{
		var intRowIndex = this.getRowIndex(lngUniqueId);
		var objRow = this.HTMLtable.tBodies[0].rows[intRowIndex];
		
		var row = new Row(objRow, this);
		
		this.arrSelectedRows[lngUniqueId] = row;
	}
	else
		row = this.arrSelectedRows[lngUniqueId];
			
	return row;
}

// Constructor for a row object
function Row(objHTMLElement, objGrid)
{
	this.Grid		= objGrid;
	this.columnNames	= new Array();
	this.values			= new Array();
	this.getRowValue	= et_row_getRowValue;
	this.HTMLElement	= objHTMLElement;
	this.rulesApplied	= new Array();
	this.destroy		= et_row_destroy;
}

/**
 * Clear references tothe row object
 */
function et_row_destroy() {
	try {
		this.Grid			= null;
		this.columnNames	= new Array();
		this.values			= new Array();
		this.HTMLElement	= null;
		if (this.rulesApplied != null) {
			for (var i = 0, len = this.rulesApplied.length; i < len; i++) {
				this.rulesApplied[i] = null;
			}
		}
		this.rulesApplied	= new Array();
	} catch (error) {
	}
}

/** Get a column value from this row
 */
function et_row_getRowValue(strColumn, flgUnformatted)
{
	var intCellIndex = this.Grid.getColumnCellIndex(strColumn);
	var objTD = this.HTMLElement.cells[intCellIndex];
	
	var strValue;
	
	if (this.Grid.isTreeGrid == true && objTD.childNodes.length > 1)
		strValue = objTD.lastChild.innerHTML;
	else
		strValue = objTD.innerHTML;

	strValue = unescapeXML(strValue);
	
	var objHeadTD = this.Grid.HTMLtable.tHead.rows[0].cells[intCellIndex];
	if (intCellIndex > 0 &&
		(objHeadTD.type == "xsd:float" || objHeadTD.type == "xsd:double" ||
		 objHeadTD.type == "xsd:integer" || objHeadTD.type == "xsd:short" ||
		 objHeadTD.type == "xsd:smallint" || objHeadTD.type == "xsd:decimal"))
	{		
		if (flgUnformatted)
		{
			if (this.Grid.isTreeGrid == true && objTD.childNodes.length > 1)
				strValue = objTD.lastChild.unformattedvalue;
			else
				strValue = objTD.unformattedvalue;
		}
						
		strValue = Number(util_parseNumber(strValue));
		if (isNaN(strValue))
			strValue = objTD.innerHTML;
	}

	if (strValue == NBSP_CONSTANT)
		strValue="";

	if (strValue == "")
	{
		if (objTD.style.backgroundImage.indexOf("checkBoxTicked") != -1)
			strValue = cb_CHECKED;
		else if (objTD.style.backgroundImage.indexOf("checkBoxNotTicked") != -1)
			strValue = cb_UNCHECKED;
	}

	return strValue;
}

/** Swap grid rows
 */
function et_swapRows(intFromIndex, intToIndex)
{
	this.HTMLtable.tBodies[0].rows[intFromIndex].swapNode(this.HTMLtable.tBodies[0].rows[intToIndex]);
}

/** Load data from data-engine
 */
function et_setupWithDataEngine()
{
	this.DataEngine.standardTransform = false;

	if (this.DataEngine.arrXSLTParamNames.length == 0)
	{
		this.DataEngine.addXSLTParam("localeLanguageCode", objApplication.User.localeid);
		this.DataEngine.addXSLTParam("baseURL", window.document.URL);
		this.DataEngine.addXSLTParam("relativeURL", "../XML/xmlRegionalSettings.xml");
		this.DataEngine.addXSLTParam("gridID", this.id);
		this.DataEngine.addXSLTParam("gridURL", "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + this.strSrc.replace("..", ""));
	}

	var strHTML = this.DataEngine.populateEngine();
	
	if (objApplication.hadCriticalError)
		return;

	if (!isBlank(strHTML) && strHTML.substring(0, 6) != "<error")
	{
		this.HTMLdiv.innerHTML = escapeStringDoubleSpaces(strHTML);
		this.HTMLtable = this.objAppWindow.document.getElementById("et_grd" + this.id);
	}
	else
		this.setupTableHeadings();

	this.setup();
}

/**
 * Internal function to resize the last column so that it fits all available
 * grid space.
 * Not switched on by default.
 * Only relevent if objGrid.stretchLastColumn == false.
 * 
 * @param objEvent The window event object which caused this resize.
 */
function et_doResizeLastColumn(objEvent)
{
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;

	var objGrid = window[objBrowserEvent.id.replace("grd", "")];
	if (objGrid.objAppWindow.flgSkipResizingLastGridColumn == true || objGrid.stretchLastColumn == false)
		return;

	objGrid.objAppWindow.flgSkipResizingLastGridColumn = true;
	
	var objHeadRow = objGrid.HTMLtable.tHead.rows[0];
	
	for (var intCellCtr = objHeadRow.cells.length; intCellCtr > 0; intCellCtr--)
	{
		var objHeadCell = objHeadRow.cells[intCellCtr - 1];
		if (objHeadCell.style.display != "none")
			break;
	}

	// If we cannot find the first none-visible tHead cell then assume it is the second cell 
	// (which is usually the case for tree-views with hidden column headers).
	if (intCellCtr == 0)
		intCellCtr = 2;
	
	var intCurrentCellWidth = objHeadCell.offsetWidth;
	if (intCurrentCellWidth == 0)
		intCurrentCellWidth = objGrid.HTMLtable.tBodies[0].rows[0].cells[intCellCtr - 1].offsetWidth;
	
	var intNewWidth = intCurrentCellWidth + (objGrid.HTMLdiv.offsetWidth - objHeadRow.offsetWidth) - 4;
	
	if (intNewWidth > 50)
		objHeadCell.style.width = intNewWidth;

	objGrid.objAppWindow.flgSkipResizingLastGridColumn = false;
}

/**
 * Internal function called when the grid loses focus.
 * Calls externally defined onblur method in application code.
 * 
 * @param objEvent The window event object.
 */
function et_doOnBlur(objEvent)
{
	if (! objEvent) objEvent = window.event; // Get event details for IE
	var objBrowserEvent = objEvent.srcElement ? objEvent.srcElement : objEvent.target;

	var objGrid = window[objBrowserEvent.id.replace("grd", "")];
	var evalFunction = new Function(objGrid.onblur);
	evalFunction();
}

/** 
 * Fires any attached ADAPT javascript.
 *
 * @param flgEventType Binary operator parameter determines which event to fire.
 * @return Returns false if the adapt javascript decided to cancel the event.
 */
function et_performADAPTScript(flgEventType)
{
	var strMethodName;

	if (flgEventType & ADAPT_ONROWCLICK) {
		strMethodName = this.id + "_onRowClick";
	} else if (flgEventType & ADAPT_ONROWDBLCLICK) {
		strMethodName = this.id + "_onRowDblClick";
	} else if (flgEventType & ADAPT_ONBEGINROWEDIT) {
		strMethodName = this.id + "_onBeginRowEdit";
	} else {
		alert("Grid event type not supported");
	}
	
	if (typeof(strMethodName) != "undefined" && this.objAppWindow[strMethodName] != null) {
		if (this.objAppWindow[strMethodName](this) == false) {
			return false;
		}
	}
	
	return true;
}

/**
 *	Sets up a new Rule for this Grid.
 *	@param strID - A unique string reference for this Rule.
 *	@param ruleScript - A predicate consisting of a string of valid JavaScript.
 *	@param ruleType - The type of rule being applied, i.e. HIDE/HIGHLIGHT.
 *	@param cssClassName - A className reference supplying HIGHLIGHT colours.
 */
function et_setRule(strID, ruleScript, ruleType, cssClassName)
{	
	// If this Rule already exists then we simply turn it on, otherwise we create a new Rule.
	var exists = false;
	for (var i=0; i<this.arrRules.length; i++)
	{
		var rule = this.arrRules[i];
		var strRuleID = rule.ruleID;
		if (String(strRuleID) == String(strID))
		{
			exists = true;
			rule.ruleApply = true;
			this.toggleRule(rule);
			break;
		}
	}
	
	if (!exists)
		this.addNewRule(strID, ruleScript, ruleType, cssClassName);
}

/**
 *	Applies all rules to the specified grid row.
 *	@param objRow - The Grid row to apply the rules to.
 */
function et_applyAllRules(objRow)
{
	// Loop through all rules and apply each to the specified row.
	for (var i=0; i<this.arrRules.length; i++)
	{
		var objRule = this.arrRules[i];
		
		this.setRule(objRule.ruleID, objRule.ruleScript, objRule.ruleType, objRule.ruleClass);
	}
}

/**
 *	Gets all Rules.
 *	@return An array of the current Rules that have been applied to the Grid.
 */
function et_getAllRules()
{
	return this.arrRules;
}

/** 
 *	Applies a new Rule to the Grid.
 *	@param strID - A unique string reference for this Rule.
 *	@param ruleScript - A predicate consisting of a string of valid JavaScript.
 *	@param ruleType - The type of rule being applied, i.e. HIDE/HIGHLIGHT.
 *	@param cssClassName - A className reference supplying HIGHLIGHT colours. 
 */
function et_addNewRule(strID, ruleScript, ruleType, cssClassName)
{
	// Create a new Rule object and apply this to each row of the Grid.
	var objRule = new Rule(strID, ruleType, ruleScript, true, cssClassName, this);
	this.arrRules[this.arrRules.length] = objRule;
	
	var objRows = this.getRows();	

	for (var i=0; i<objRows.length; i++)
	{	
		var objRow = objRows[i];		
		if (this.processRule(objRule, objRow) == true)
			objRule.arrRows[objRule.arrRows.length] = objRow;
	}	
}

/** Process all the rules on a row
 * @param objRow The grid row to apply the rule to
 */
function et_processAllRules(objRow) {
	// Loop through all rules and apply each to the specified row.
	for (var i=0; i<this.arrRules.length; i++)
	{
		var objRule = this.arrRules[i];
		
		this.processRule(objRule, objRow);
	}
}

/**
 *	Processes the Rule.
 *	@param objRule - The Rule object to be applied.
 *	@param objRow - The Grid row for which the objRule is to be applied.
 */
function et_processRule(objRule, objRow)
{
	// Extract the JavaScript expression from the Rule.
	var strExpression = objRule.getRuleExpression(objRow);
	
	// Evaluate the expression to determine whether the Rule is to be applied to this objRow.
	if (this.objAppWindow.eval(strExpression))
	{
		this.applyRule(objRow, objRule);
		return true;
	}
	return false;
}

/**
 *	Applies the specified Rule to the specified Grid row.
 *	@param objRow - The specified Grid row.
 *	@param objRule - The specified Rule.
 */
function et_applyRule(objRow, objRule)
{
	// Get the type of Rule to be applied.
	var ruleCommand = objRule.ruleType;
	switch (ruleCommand)
	{
		case "HIDE" :
		{
			if (objRule.ruleApply == true || objRule.ruleApply == "true")
				objRow.HTMLElement.style.display = "none";				
			else {
				if (this.isTreeGrid) {
					var objTreeNode = this.Tree.createTreeNode(objRow.HTMLElement);
					var objParentNode = objTreeNode.getParentNode();
					if (objParentNode.isCollapsed() || objParentNode.objHTMLElement.style.display == "none") {
						objRow.HTMLElement.style.display = "none";
					} else {
						objRow.HTMLElement.style.display = "inline";
					}
				} else {
					objRow.HTMLElement.style.display = "inline";
				}
			}
		}
		break;

		case "HIGHLIGHT" :
		{
			// If the Rule is a HIGHLIGHT Rule then we supply a className to specify a highlight colour.
			if (objRule.ruleApply == true || objRule.ruleApply == "true")			
				objRow.HTMLElement.className = objRule.ruleClass;
			else
				objRow.HTMLElement.className = "";
		}
		break;
	}
	
	// If this Rule is being switched on, then keep a record of this Rule against the Grid row.
	if (objRule.ruleApply == true || objRule.ruleApply == "true")
	{
		var exists = false;
		for (var i=0; i<objRow.rulesApplied.length; i++)
		{
			if (String(objRow.rulesApplied[i]) == String(objRule.ruleID))
			{
				exists = true;
				break;
			}
		}
		if (!exists)
			objRow.rulesApplied[objRow.rulesApplied.length] = objRule.ruleID;
	}
	else
	{
		// If the Rule is being switched off then remove the Rule from the Grid row
		for (var i=0; i<objRow.rulesApplied.length; i++)
		{
			var strRuleID = objRow.rulesApplied[i];
			if (String(strRuleID) == String(objRule.ruleID))
			{
				for (var f=i; f<objRow.rulesApplied.length; f++)
				{
					objRow.rulesApplied[f] = objRow.rulesApplied[f+1];
				}
			}
		}
		if (objRow.rulesApplied.length > 0)
			objRow.rulesApplied.length = objRow.rulesApplied.length-1;
	}

}

/**
 *	Removes the specified Rule.
 *	@param strID - A unique string reference for this Rule.
 */
function et_removeRule(strID)
{
	// Switch off the specified Rule
	for (var i=0; i<this.arrRules.length; i++)
	{
		var rule = this.arrRules[i];
		if (String(rule.ruleID) == String(strID))
		{
			rule.ruleApply = false;
			this.toggleRule(rule);
		}
	}
	
	// Now re-apply the remaining Rules
	for (var i=0; i<this.arrRules.length; i++)
	{
		var rule = this.arrRules[i];
		if (String(rule.ruleID) != String(strID))
		{
			if (rule.ruleApply == true || rule.ruleApply == "true")
				this.toggleRule(rule);
		}
	}
}

/**
 *	Turns the specified Rule on or off.
 *	@param objRule - The Rule to turn on/off.
 */
function et_toggleRule(objRule)
{
	for (var i=0; i<objRule.arrRows.length; i++)
	{
		var objRow = objRule.arrRows[i];
		this.applyRule(objRow, objRule);
	}
}

/*
 *	Constructor for a Rule object.
 *	@param rID - Unique string reference for this Rule.
 *	@param rType -	type of rule to be applied, i.e. HIDE/HIGHLIGHT.
 *	@param rScript - Predicate of valid JavaScript.
 *	@param flgApply - Boolean to turn on/off this Rule.
 *	@param cssClassName - ClassName supplying HIGHLIGHT colour.
 */
function Rule(rID, rType, rScript, flgApply, cssClassName, objGrid)
{
	this.ruleID		= rID;
	this.Grid		= objGrid;
	this.ruleType 	= rType;
	this.ruleScript = rScript;
	this.arrScriptFragments = new Array(); // Fragments of script that dwell beteen column names
	this.arrScriptVarIdx = new Array(); // Grid column names
	this.ruleApply 	= flgApply;
	this.ruleClass 	= cssClassName;
	this.arrRows	= new Array();
	this.getRuleExpression = et_rule_getRuleExpression;
	this.breakScript	= et_rule_breakScript;
	this.destroy = et_rule_destroy;

	// Break the script into fragments
	this.breakScript();
}

/**
 * Clear references to the rule object
 */
function et_rule_destroy() {
	try {
		this.ruleID		= null;
		this.Grid		= null;
		this.ruleType 	= null;
		this.ruleScript = null;
		if (this.arrScriptFragments != null) {
			for (var i = 0, len = this.arrScriptFragments.length; i < len; i++)
				this.arrScriptFragments[i] = null;
		}
		this.arrScriptFragments = new Array();
		
		if (this.arrScriptVarIdx != null) {
			for (var i = 0, len = this.arrScriptVarIdx.length; i < len; i++)
				this.arrScriptVarIdx[i] = null;
		}
		this.arrScriptVarIdx = new Array();
		
		this.ruleApply 	= null;
		this.ruleClass 	= null;
		if (this.arrRows != null) {
			for (var i = 0, len = this.arrRows.length; i < len; i++)
				this.arrRows[i] = null;
		}
		this.arrRows	= new Array();
	} catch (error) {
	}
}

/** Break the script into sections for quick building of expressions
 */
function et_rule_breakScript()
{
	var strRule = this.ruleScript;
	var intCurrPos = 0;

	// Substitute values for the supplied column references contained in {$...}
	var index = strRule.indexOf("{$", intCurrPos);
	while (index != -1)
	{
		this.arrScriptFragments[this.arrScriptFragments.length] = strRule.substring(intCurrPos, index);

		var pos = strRule.indexOf("}", index);
		if (pos == -1)
		{
			alert("Error in Rule script");
			return;
		}

		var strColName = strRule.substring(index+2, pos);
		this.arrScriptVarIdx[this.arrScriptVarIdx.length] = this.Grid.getColumnCellIndex(strColName);

		intCurrPos = pos+1;
		index = strRule.indexOf("{$", intCurrPos);
	}
	this.arrScriptFragments[this.arrScriptFragments.length] = strRule.substring(intCurrPos);
}

/** Get the expression for this rule on this row
 * @param objRow the row to build the expression for
 * @return the rule javascript expression
 */
function et_rule_getRuleExpression(objRow)
{
	var strExpression = this.arrScriptFragments[0];
	for (var i = 0; i < this.arrScriptVarIdx.length; i++) {
		var cellIndex=this.arrScriptVarIdx[i];
		var strColName=this.Grid.objGridHeadingsXML.selectNodes("/grid/column").item(cellIndex).getAttribute("ref");
		var strColDataType=this.Grid.objGridHeadingsXML.selectNodes("/grid/column").item(cellIndex).getAttribute("datatype");
		var colValue= objRow.getRowValue (strColName);
		if (strColDataType=="xsd:dateTime" && !(isBlank(colValue))) {
			var objEfacsCalendar=objApplication.getCalendarParser();
			objEfacsCalendar.setDateTimeInLocaleFormat(colValue);
			colValue=objEfacsCalendar.getDateTimeInMilliseconds();	
		}

		// Add the value and then the script fragment that comes after it
		// NB there is always 1 more fragment to variable!
		strExpression += "'" + colValue + "'" + this.arrScriptFragments[i + 1];
	}
	return strExpression;
}
/**
 *	Gets the rows that this Rule has affected.
 *	@param strRuleID - Unique string identifier for this Rule.
 *	@return An array of Grid rows affected by this Rule.
 */
function et_getRuleRows(strRuleID)
{
	// Locate the appropriate Rule and return an array of Grid rows affected by this Rule.
	for (var i=0; i<this.arrRules.length; i++)
	{
		var objRule = this.arrRules[i];
		if (String(objRule.ruleID) == String(strRuleID))
			return objRule.arrRows;
	}
	return null;
}

/**
 *	Selects first row in grid.
 */
function et_selectTopRow()
{
    var objRows = this.HTMLtable.tBodies[0].rows;

    if (objRows.length == 0)
        return;

    this.selectRow(objRows[0].cells[0].innerHTML);
}

/**
 * Determines whether the editable grid form is currently valid
 * if a row is currently being edited.
 *
 * @return True if valid, false if not.
 */
function et_validate()
{
	var flgValid = true;
	
	if (this.objGridEdit != null && this.objGridEdit.isVisible() == true)
	{
		// Force any outstanding blurs on the form fields.
		var objChangeEvent = this.objAppWindow.document.createEventObject();
		objChangeEvent.keyCode = 9;
		var objTempField = this.objGridEdit.objForm.fields[this.objGridEdit.intFieldIndex];
		if (objTempField.HTMLElement.unformattedHTMLValue != null)
		{
			objTempField.HTMLElement.value = objTempField.HTMLElement.unformattedHTMLValue;
			objTempField.HTMLElement.unformattedHTMLValue = null;
		}
		objTempField.HTMLElement.fireEvent("onchange", objChangeEvent)

		flgValid = this.objGridEdit.updateEditFormGridValues();
	}
	
	if (flgValid == true)
	{
		var objRows = this.HTMLtable.tBodies[0].rows;
		for (var i=0, intLen = objRows.length; i < intLen; i++)
		{
			var objCells = objRows[i].cells;
			for (var j=0, intJLen = objCells.length; j < intJLen; j++)
			{
				if (objCells[j].className == "InvalidEditGridCell")
					return false;
			}
		}
	}
	
	return flgValid;
}

/**
 * Activates the editable grid form for a row edit.
 *
 * @param strUID The rows uniqueid.
 */
function et_beginRowEdit(strUID, flgFromGridValidate)
{
	this.objAppWindow.m_objEditableGrid = this;
	var intRowIndex = this.getRow(strUID).HTMLElement.rowIndex - 1;
	var objTD = this.HTMLtable.tBodies[0].rows[intRowIndex].cells[1];
	this.objAppWindow.m_objEditableGrid.objGridEdit.activateEditForm(objTD, flgFromGridValidate);
}

/** Trigger an application associated with an action
 * @params Parameter Array - contains the application name to launch, action label and the FormField object the context menu belongs too
 */
function et_triggerAction(objContextMenuOption) {
	var objField = objContextMenuOption.params[2].getSelectedColumnValue(objContextMenuOption.params[3]);
	var objAction = objContextMenuOption.params[1];
	
	// ensure an action is picked
	if (objAction != null) {
		var appName = objAction.strAppName;
		
		var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Applications_HTML/" + appName + ".html?key0=" + replaceForURL(b64Encode(objField[0]));
		if (!isBlank(objApplication.appID)) {
			strURL += "&appid=" + objApplication.appID;
			strURL += "&menuid=" + objApplication.menuID;
		}

		var objTopWindow = getTopWindow();
		
		if (appName == "appCallMan") {
			var traderID;
			var contactidID;
			
			if (objTopWindow.objCTI.callState == CTI_CALLSTATUS_ANSWERED)
				return eMsgBox(fl("CTICALLACTIVE"), 0, msg_Critical, window);
				
			strURL += "&mode=CONTEXT";
			
			if (objContextMenuOption.cascadeLevel == 2) {
				traderID = objContextMenuOption.params[2].getSelectedColumnValue("traderid")[0]
				contactID = objContextMenuOption.params[2].getSelectedColumnValue(objContextMenuOption.params[3])[0]
			}
			else {
				traderID = objContextMenuOption.params[2].getSelectedColumnValue(objContextMenuOption.params[3])[0];
				contactID = objContextMenuOption.parentContextLabel;
			}
			var fixedNumber = objContextMenuOption.params[0];
			
			var traderType = this.CTIType == "CUSTOMERCONTACTNUMBERS" ? "C" : this.CTIType == "SUPPLIERCONTACTNUMBERS" ? "S" : "HQ";
			
			strURL += "&traderid=" + replaceForURL(b64Encode(traderID));
			strURL += "&tradertype=" + replaceForURL(b64Encode(traderType));
			strURL += "&contactid=" + replaceForURL(b64Encode(contactID));
			strURL += "&fixednumber=" + replaceForURL(b64Encode(fixedNumber));
			
			objApplication.openChildWindow(objTopWindow, strURL);
		}
		else {
			strURL += "&mode=" + objAction.strMode;
			objApplication.openChildWindow(objTopWindow, strURL);
		}
	}
}

/** FieldAction object constructor
 * @param strLabel Action label
 * @param strAppName Application name
 * @param strMode Mode Additional information for this call
 * @param strImage Context menu icon
 */
function FieldAction(strLabel, strAppName, strMode, strImage) {
	this.strLabel = strLabel;
	this.strAppName = strAppName;
	this.strMode = strMode;
	this.strImage = strImage;
	this.destroy = et_FieldAction_destroy;
}

/**
 * Clear the references to the FieldAction objects
 */
function et_FieldAction_destroy() {
	this.strLabel = null;
	this.strAppName = null;
	this.strMode = null;
	this.strImage = null;
}

/**
 * Marks a grid column as disabled.
 *
 * @param strColumnRef The column reference.
 */
function et_disableColumn(strColumnRef)
{
	if (this.objGridEdit == null)
		return;

	if (this.objEditFormXML == null)
	{
		this.objEditFormXML = objApplication.createXMLDocument();
		this.objEditFormXML.loadURL(this.objGridEdit.editFormSrc);
	}
	this.objEditFormXML.selectSingleNode("//textbox[@ref = '" + strColumnRef + "']").setAttribute("disabled", "true");
}

/**
 * Marks a grid cell as disabled. If using a check box, set the desired state before calling this routine. 
 *
 * @param strUniqueID The unique ID for the grid row
 * @param strColumnRef The column reference.
 */
function et_disableCell(strUniqueID, strColumnRef)
{
	// Get cell index for required column.
	var intCellIndex = this.getColumnCellIndex(strColumnRef);
	var objTableRows = this.HTMLtable.tBodies[0].rows;
	var index = this.getRowIndex(strUniqueID);
	var objTD = objTableRows[index].cells[intCellIndex];

	// if its a checkbox - this image is then checked in doBodyClick
	if (objTD.style.backgroundImage.indexOf("checkBoxTicked") != -1)
		objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxTickedDisabled.gif)";
	if (objTD.style.backgroundImage.indexOf("checkBoxNotTicked") != -1)
		objTD.style.backgroundImage = "url(http://CT-US-SQL01/efacs/English/GIF/gifcheckBoxNotTickedDisabled.gif)";
}

/**
 * Validates all editable grid rows.
 */
function et_validateAllRows()
{
	if (this.objGridEdit == null)
		return;

	var objRows = this.HTMLtable.tBodies[0].rows;
	this.beginRowEdit(objRows[0].cells[0].innerHTML, true);
}

/**
 * Function called internally after edit form iframe has loaded.
 * Performs validation on each cell in each row.
 *
 * @return True if all rows valid - false if not.
 */
function et_doValidateAllRows()
{
	var strStatusMessage = null;
	var flgValid = true;
	var objRows = m_objEditableGrid.HTMLtable.tBodies[0].rows;

	m_objEditableGrid.objAppWindow.objStatusBar.flgDoBeep = false;
	
	var objFields = m_objEditableGrid.objGridEdit.objForm.fields;
	for (var i=0, intLen = objRows.length; i < intLen; i++)
	{
		for (var j=0, intCellLen = objFields.length; j < intCellLen; j++)
		{
			var objField = objFields[j];
			var objHTMLElement = objField.HTMLElement;
			
			if (objHTMLElement.blnIsDisabled == "true" || objField.isVisible() == false)
				continue;

			var objGridCell = objRows[i].cells[j + 1];

			if (objField.lookupInputs.length > 0)
				objHTMLElement.unformattedHTMLValue = null;

			var strCellValue = objGridCell.innerHTML;
			if (objField.strDataType == "xsd:integer" || objField.strDataType == "xsd:short" || objField.strDataType == "xsd:smallint" ||
				objField.strDataType == "xsd:float" || objField.strDataType == "xsd:decimal" || objField.strDataType == "xsd:double") 
				strCellValue = util_parseNumber(strCellValue);
			objField.setValue(strCellValue);

			if (objField.isInvalid)
			{
				objGridCell.className = "InvalidEditGridCell";
				flgValid = false;
				if (strStatusMessage == null)
					strStatusMessage = m_objEditableGrid.objAppWindow.document.getElementById("sbmessage").innerHTML;
				break;
			}
			else if (objGridCell.className == "InvalidEditGridCell")
				objGridCell.className = "EditGridCell";
		}
	}
	m_objEditableGrid.objAppWindow.objStatusBar.flgDoBeep = true;

	if (strStatusMessage != null)
		m_objEditableGrid.objAppWindow.objStatusBar.error(strStatusMessage);
	else
		m_objEditableGrid.objAppWindow.objStatusBar.clear();

	return flgValid;
}

/**
 * Column sorting routine. Available for use from front end.
 * @param strColumnID - The grid column to be sorted by.
 * @param flgDescending - Boolean flag to decide whether sorting should be descending.
 */
function et_sortByColumn(strColumnID, flgDescending) 
{
	var i;
	var objGridTable = this.HTMLtable.tHead;
	var objGridSortElement = this.objAppWindow.document.getElementById("grid_col_" + strColumnID);
	if (flgDescending == null)
		flgDescending = false;
		
	if (this.objGridEdit != null) {
		objGridSortElement._descending = !flgDescending;
		var objParentNode = objGridSortElement.parentNode;
		for (i = 0; i < objParentNode.cells.length; i++){
			if (objParentNode.cells[i] == objGridSortElement) break;
		}
	}else{
		objGridSortElement._descending = flgDescending;
		i = et_setColumnDirection(objGridTable, objGridSortElement);
	}
	
	if (objGridSortElement != null) {
		var table = getParentElement(objGridSortElement, "table");
		et_sortTable(table, i, objGridSortElement._descending, objGridSortElement.type);
	}
}


/**
 * Clear reference to the grid object
 */
function et_destroy() {
	try {
		this.DOM					= null;
		this.objGridEdit			= null;
		this.objEditFormXML			= null;
		this.objGridHeadingsXML		= null;
		this.objGridDataXML			= null;
		this.objAppData				= null;
		this.onRowSelect			= null;
		this.onRowDblClick			= null;
		this.onDelKeyPressed		= null;
		this.onColumnResize			= null;
		this.onmouseover			= null;	
		this.onmouseout				= null;	
		this.onchange				= null;
		this.Tree					= null;
		this.grdSplitterBar			= null;
	
		if (this.arrRules != null) {
			for (var i = 0, len = this.arrRules.length; i < len; i++) {
				this.arrRules[i].destroy();
				this.arrRules[i] = null;
			}
		}
		this.arrRules				= new Array();
		
		if (this.DataEngine	!= null) {
			this.DataEngine.destroy();
			this.DataEngine	= null;
		}
		
		if (this.arrContextOptions != null) {
			for (var i = 0, len = this.arrContextOptions.length; i < len; i++) {
				this.arrContextOptions[i].destroy();
				this.arrContextOptions[i] = null;
			}
		}
		this.arrContextOptions		= new Array();
	
		if (this.arrSelectedRows != null) {
			for (var i = 0, len = this.arrSelectedRows.length; i < len; i++) {
				if (this.arrSelectedRows[i] != null)
					this.arrSelectedRows[i].destroy();
				this.arrSelectedRows[i] = null;
			}
		}
		this.arrSelectedRows		= new Array();

		if (this.HTMLtable != null) {

			removeEvent(this.HTMLtable.tHead, "onmousedown", this.objAppWindow.et_doHeaderMouseDown);
			removeEvent(this.HTMLtable.tHead, "onmouseup", this.objAppWindow.et_doMouseUp);
			removeEvent(this.HTMLtable.tHead, "ondblclick", this.objAppWindow.et_doHeaderDblClick);
			removeEvent(this.HTMLtable.tHead, "onmouseover", this.objAppWindow.et_doHeaderMouseOver);
			removeEvent(this.HTMLtable.tHead, "onmouseout", this.objAppWindow.et_doHeaderMouseOut);

			if (this.HTMLtable.tBodies != null && this.HTMLtable.tBodies[0] != null) {
				removeEvent(this.HTMLtable.tBodies[0], "onmouseover", this.objAppWindow.et_doHighlightOn);
				removeEvent(this.HTMLtable.tBodies[0], "onmouseout", this.objAppWindow.et_doHighlightOff);
				removeEvent(this.HTMLtable.tBodies[0], "onclick", this.objAppWindow.et_doBodyClick);
				removeEvent(this.HTMLtable.tBodies[0], "ondblclick", this.objAppWindow.et_doBodyDblClick);
				removeEvent(this.HTMLtable.tBodies[0], "oncontextmenu", this.objAppWindow.et_doContextMenu);
			}
			if (this.HTMLtable.rows != null && this.HTMLtable.rows[0] != null) {
				if (this.HTMLtable.rows[0].cells != null) {
					for (var i = 0, len = this.HTMLtable.rows[0].cells.length; i < len; i++) {
						this.HTMLtable.rows[0].cells[i].onmousemove = null;
					}
				}
			}
			this.HTMLtable = null;
		}
		if (this.HTMLdiv != null) {
			removeEvent(this.HTMLdiv, "onresize", this.objAppWindow.et_doResizeLastColumn);
			removeEvent(this.HTMLdiv, "onblur", this.objAppWindow.et_doOnBlur);
			this.HTMLdiv.onkeydown = null;
			this.HTMLdiv.onfocus = null;
			if (this.HTMLdiv.style != null) {
				this.HTMLdiv.style.backgroundColor = "";
			}
			if (this.HTMLdiv.children != null && this.HTMLdiv.children[0] != null) {
				if (this.HTMLdiv.children[0].tHead != null && this.HTMLdiv.children[0].tHead.rows != null && this.HTMLdiv.children[0].tHead.rows[0] != null) {
					if (this.HTMLdiv.children[0].tHead.rows[0].cells != null) {
						if (this.HTMLdiv.children[0].tHead.rows[0].cells[0] != null &&
							this.HTMLdiv.children[0].tHead.rows[0].cells[0].onmousemove != null) {
							
							for (var i = 0, len = this.HTMLdiv.children[0].tHead.rows[0].cells.length; i < len; i++) {
								this.HTMLdiv.children[0].tHead.rows[0].cells[i].onmousemove = null;
							}
						}
					}
				}
			}
			this.HTMLdiv = null;
		}

		if (this.objAppWindow != null && this.objAppWindow.document != null && this.objAppWindow.document.body != null) {
			removeEvent(this.objAppWindow.document.body, "onmouseup", this.objAppWindow.et_doMouseUp);
			removeEvent(this.objAppWindow.document.body, "onmousemove", this.objAppWindow.et_doMouseMove);
			this.objAppWindow.document.body.onclick = null;
			this.objAppWindow.document.body.onfocus = null;
			this.objAppWindow.document.body.onblur = null;
			this.objAppWindow.document.body.onchange = null;
			this.objAppWindow.document.body.onmousedown = null;
			this.objAppWindow.document.body.onmouseup = null;
			this.objAppWindow.document.body.onmouseover = null;
			this.objAppWindow.document.body.onkeypress = null;
			this.objAppWindow.document.body.onkeydown = null;
			this.objAppWindow.document.body.onkeyup = null;
			this.objAppWindow.document.body.ondblclick = null;
			this.objAppWindow.document.body.onresize = null;
			this.objAppWindow.document.body.ondragover = null;
			this.objAppWindow.document.body.onbeforeunload = null;
			this.objAppWindow.document.body.onload = null;
			this.objAppWindow.document.body.onunload = null;
		}
		
		this.onblur					= null;
		this.id 					= null;
		this.objAppWindow			= null;
	} catch(error) {
	}
}


	

/**
 * Constructor for the grid edit object.
 *
 * @param objGrid Reference to the parent grid object.
 */
function GridEdit(objGrid)
{
	// Properties
	this.objGrid				= objGrid
	this.objForm				= null;
	this.editFormSrc			= null;
	this.editFormSchema			= null;
	this.editFormClass			= null;
	this.validateMethod			= null;
	this.onEditBegin			= null;
	this.onEditEnd				= null;
	this.onNewRecord			= null;
	this.intRowIndex			= null;
	this.intFieldIndex			= null;
	this.strUID					= null;
	
	// Methods
	this.activateEditForm			= GridEdit_activateEditForm;
	this.updateEditFormGridValues	= GridEdit_updateEditFormGridValues;
	this.resizeFormFields			= GridEdit_resizeFormFields;
	this.isVisible					= GridEdit_isVisible;
	this.hide						= GridEdit_hide;
	this.positionIFrame				= GridEdit_positionIFrame;
	this.scrollFieldIntoView		= GridEdit_scrollFieldIntoView;
	this.fireValidateMethod			= GridEdit_fireValidateMethod;
	this.fireOnEditBegin			= GridEdit_fireOnEditBegin;
	this.fireOnEditEnd				= GridEdit_fireOnEditEnd;
	this.fireOnNewRecord			= GridEdit_fireOnNewRecord;
	this.setFocusFirstField			= GridEdit_setFocusFirstField;
	this.setFocusLastField			= GridEdit_setFocusLastField;
	this.editableFieldCount			= GridEdit_editableFieldCount;
}

/**
 * Loads the grid edit form into its correpsonding IFrame.
 *
 * @param objTD The grid cell clicked on for editing.
 * @return False if activate failed due to form already being invalid, else true.
 */
function GridEdit_activateEditForm(objTD, flgFromGridValidate)
{
	var objWindow = this.objGrid.objAppWindow;

	if (this.objForm == null)
	{
		this.intFieldIndex = et_getCellIndex(objTD) - 1;
		this.intRowIndex = objTD.parentNode.rowIndex - 1;
		this.strUID = objTD.parentNode.cells[0].innerHTML;

		this.objGrid.sortable = "false";
		this.objGrid.scrollIntoView = false;
		
		window["frm" + this.objGrid.id] = objApplication.Forms("frm" + this.objGrid.id);
		this.objForm = window["frm" + this.objGrid.id];

		if (this.objForm == null) {
			window["frm" + this.objGrid.id] = objApplication.addForm(objWindow.document.getElementById("frmfrm" + this.objGrid.id), objWindow);
			this.objForm = window["frm" + this.objGrid.id];
		} else {
			this.objForm.flgCreatedFields = false;
		}
		this.objForm.strSrc = this.editFormSrc;
		this.objForm.editMode = "add";
		this.objForm.objGridEdit = this;
		this.objForm.schemaName = this.editFormSchema;

		this.objForm.fields = new Array();
		var strSchemaName = this.objForm.schemaName;
		if (isBlank(strSchemaName))
			strSchemaName = "none";

		var strURL = "http://" + objApplication.Connection.applicationServer + "/efacs/servlet/FormProcessorServlet" +
			"?formID=" + replaceForURL(b64Encode(this.objForm.id)) +
			"&schemaName=" + replaceForURL(b64Encode(strSchemaName.toLowerCase())) +
			"&xsltURL=" + replaceForURL(b64Encode("http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/XSLT/xsltEditableGridTranslator.xslt")) +
			"&formURL=" + replaceForURL(b64Encode("http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Forms/" + this.objForm.strSrc)) +
			"&languageLocation=" + replaceForURL(b64Encode("http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory)) +
			"&sessionString=" + replaceForURL(b64Encode(objApplication.Connection.strConnectionString)) +
			"&localeid=" + replaceForURL(b64Encode(objApplication.User.localeid)) +
			"&nocache=true";
		
		if (this.editFormClass != null)
		{
			strURL += "&editMode=add";
			strURL += "&className=" + replaceForURL(b64Encode(this.editFormClass));
			if (strSchemaName != "none")
				strURL += "&includeBeanData=true";
		}

		this.objForm.formGroup.src = strURL;
		
		addEvent(this.objGrid.HTMLdiv, "onscroll", GridEdit_onScroll);
		addEvent(this.objGrid.objAppWindow, "onscroll", GridEdit_onBodyScroll);

		GridEdit_waitForEditableGridForm(flgFromGridValidate);
	}
	else
	{
		if (this.isVisible() == true)
		{
			// Force any outstanding blurs on the form fields.
			var objChangeEvent = this.objGrid.objAppWindow.document.createEventObject();
			objChangeEvent.keyCode = 9;
			var objTempField = this.objForm.fields[this.intFieldIndex];
			if (objTempField.HTMLElement.unformattedHTMLValue != null)
			{
				objTempField.HTMLElement.value = objTempField.HTMLElement.unformattedHTMLValue;
				objTempField.HTMLElement.unformattedHTMLValue = null;
			}
		}

		// May be currently editing another row - update values if required.
		if (this.updateEditFormGridValues() == false)
			return false;

		// Point to the new grid row.		
		this.intFieldIndex = et_getCellIndex(objTD) - 1;
		this.intRowIndex = objTD.parentNode.rowIndex - 1;
		this.strUID = objTD.parentNode.cells[0].innerHTML;

		// Move to the new grid row for editing.
		GridEdit_editableGridFormSetup(false, flgFromGridValidate);
	}
	
	return true;
}

/**
 * Waits for dynamic form to be loaded into the form IFrame.
 * Not prototyped so uses m_objEditableGrid.
 */
function GridEdit_waitForEditableGridForm(flgFromGridValidate)
{
	if (m_objEditableGrid.objGridEdit.objForm.flgCreatedFields != true)
		setTimeout("GridEdit_waitForEditableGridForm(" + flgFromGridValidate + ")", 50);
	else
	{
		if (m_objEditableGrid.objGridEdit.objForm.objFrameWindow.document.body.children[0].tagName != "TABLE")
		{
			var strError = "Form file missing or failed to load. Application will close.";
			eMsgBox(strError, vbOKOnly, msg_Critical, m_objEditableGrid.objAppWindow);
			objApplication.hadCriticalError = true;
			objApplication.closeApplication();
		}
		else
			GridEdit_editableGridFormSetup(true, flgFromGridValidate);
	}
}

/**
 * Sets up the grid edit forms postion and populates form.
 * Not prototyped so uses m_objEditableGrid.
 * @param flgInitialCall First time
 * @param flgFromGridValidate Validation fired from the grid
 */
function GridEdit_editableGridFormSetup(flgInitialCall, flgFromGridValidate)
{
	var objForm = m_objEditableGrid.objGridEdit.objForm;

	if (flgInitialCall)
	{
		objForm.postProcess();

		if (m_objEditableGrid.objEditFormXML == null)
		{
			m_objEditableGrid.objEditFormXML = objApplication.createXMLDocument();
			m_objEditableGrid.objEditFormXML.loadURL(m_objEditableGrid.objGridEdit.editFormSrc);
		}

		for (var i = 0, intLen = objForm.fields.length; i < intLen; i++)
		{
			var objField = objForm.fields[i];
			if (i > 0)
				objField.HTMLElement.style.borderLeft = "none";
				
			addEvent(objField.HTMLElement, "onfocus", GridEdit_formFieldOnFocus);
			
			if (m_objEditableGrid.objEditFormXML.selectSingleNode("//textbox[@ref = '" + objField.strRef + "']").getAttribute("disabled") == "true")
				objField.disable();
		}
		
		addEvent(objForm.objFrameWindow.document.body, "onkeydown", GridEdit_formFieldOnKeyDown);
		m_objEditableGrid.objGridEdit.resizeFormFields();
	}

	// Postion IFrame over correct grid row.
	m_objEditableGrid.objGridEdit.positionIFrame();

	var arrOldValues = new Array();
	// Set the form field values from the grid data.
	for (var i = 0, intLen = objForm.fields.length; i < intLen; i++)
	{
		arrOldValues[arrOldValues.length] = objForm.fields[i].HTMLElement.unformattedHTMLValue;
	}
	
	// Set the form field values from the grid data.
	for (var i = 0, intLen = objForm.fields.length; i < intLen; i++)
	{
		var objField = objForm.fields[i];
		
		var strValue;
		
		if (objField.strDataType == "xsd:float" || objField.strDataType == "xsd:double" ||
			 objField.strDataType == "xsd:integer" || objField.strDataType == "xsd:short" ||
			 objField.strDataType == "xsd:smallint" || objField.strDataType == "xsd:decimal")
			strValue = m_objEditableGrid.getColumnValue(m_objEditableGrid.objGridEdit.strUID, objField.strRef, true);
		else
			strValue = m_objEditableGrid.getColumnValue(m_objEditableGrid.objGridEdit.strUID, objField.strRef);
			
		if (strValue == NBSP_CONSTANT)
			strValue = "";
		
		if (objField.HTMLElement.unformattedHTMLValue != arrOldValues[i])
			continue;

		if (objField.lookupInputs.length > 0)
			objField.HTMLElement.unformattedHTMLValue = null;
		m_objEditableGrid.objAppWindow.objStatusBar.flgDoBeep = false;
		objField.setValue(strValue);
		m_objEditableGrid.objAppWindow.objStatusBar.flgDoBeep = true;
		objField.isInteractivelyDirty = false;
	}

	m_objEditableGrid.objGridEdit.fireOnEditBegin();
	// fire adapt
	m_objEditableGrid.performADAPTScript(ADAPT_ONBEGINROWEDIT);
	
	if (flgFromGridValidate)
	{
		et_doValidateAllRows();
		return;
	}

	objForm.formGroup.style.visibility = "visible";

	// Set focus on correct field corresponding to the grid cell clicked.
	var objField = objForm.fields[m_objEditableGrid.objGridEdit.intFieldIndex];
	if (objField.HTMLElement.blnIsDisabled == "false")
		objField.focus();
}

/**
 * Applies edit form values to the grid and hides the edit form.
 *
 * @return False if update failed due to form being invalid, else true.
 */
function GridEdit_updateEditFormGridValues()
{
	if (this.isVisible() == false)
		return true;
	
	 if (this.objForm.validate() == false)
		return false;

	if (this.fireValidateMethod() == false)
		return false;

	// Commit form data back into the grid.
	for (var i = 0, intLen = this.objForm.fields.length; i < intLen; i++)
	{
		var objField = this.objForm.fields[i];
		var objGridCell = this.objGrid.HTMLtable.tBodies[0].rows[this.intRowIndex].cells[i + 1];
		if (objGridCell.className == "InvalidEditGridCell")
			objGridCell.className = "EditGridCell";

		var strFieldValue = NBSP_CONSTANT;
		if (!isBlank(objField.getValue()))
			strFieldValue = objField.getValue();
		this.objGrid.setColumnValue(this.strUID, objField.strRef, strFieldValue);
	}

	return true;
}

/**
 * Resizes form fields to exactly overlay the grid cells.
 */
function GridEdit_resizeFormFields()
{
	var objHeadCells = this.objGrid.HTMLtable.tHead.rows[0].cells;
	for (var i = 1, intLen = objHeadCells.length; i < intLen; i++)
	{
		var objFieldTD = this.objForm.objFrameWindow.document.body.children[0].tBodies[0].rows[0].cells[(i * 2) - 1];
		if (objHeadCells[i].style.display == "none")
		{
			objFieldTD.style.display = "none";
		}
		var intInputWidth = objHeadCells[i].offsetWidth;
		for (var objButton = objFieldTD.children[0].nextSibling; objButton != null && objButton.tagName == "BUTTON"; objButton = objButton.nextSibling)
		{
			if (objButton.style.display != "none") {
				intInputWidth -= objButton.offsetWidth;
			}
		}

		objFieldTD.children[0].style.width = intInputWidth;
	}
	
	this.objForm.formGroup.style.width = this.objGrid.HTMLtable.offsetWidth + 50;
}

/**
 * Returns whether the editable grid form is currently on display.
 *
 * @return True if edit form is currently visible, false if not.
 */
function GridEdit_isVisible()
{
	if (this.objForm == null || this.objForm.formGroup.style.visibility == "hidden")
		return false;
	else
		return true;
}

/**
 * Fired when a key-down is detected in the form field.
 * Not prototyped so uses m_objEditableGrid.
 *
 * @param objEvent The window event object.
 */
function GridEdit_formFieldOnKeyDown(objEvent)
{
	if (objEvent == null)
		objEvent = window.event;
	
	if (objEvent.keyCode == 27)				// ESCAPE key abandons current row edit.
	{
		m_objEditableGrid.objGridEdit.hide();
		objEvent.cancelBubble = true;
		objEvent.returnValue = false;
	}
	else if (objEvent.keyCode == 13)		// ENTER key confirms current row edit.
	{
		// Force any outstanding blurs on the form fields.
		var objChangeEvent = m_objEditableGrid.objAppWindow.document.createEventObject();
		objChangeEvent.keyCode = 9;
		var objTempField = m_objEditableGrid.objGridEdit.objForm.fields[m_objEditableGrid.objGridEdit.intFieldIndex];
		objTempField.HTMLElement.fireEvent("onchange", objChangeEvent)

		if (m_objEditableGrid.objGridEdit.updateEditFormGridValues() == true)
			m_objEditableGrid.objGridEdit.hide();
		else
			m_objEditableGrid.objGridEdit.objForm.fields[m_objEditableGrid.objGridEdit.intFieldIndex].focus();

		objEvent.cancelBubble = true;
		objEvent.returnValue = false;
	}
	else if (objEvent.keyCode == 38 ||		// UP ARROW
			 objEvent.keyCode == 40 ||		// DOWN ARROW
			 objEvent.keyCode == 33 ||		// PAGE UP
			 objEvent.keyCode == 34 ||		// PAGE DOWN
			 ((objEvent.keyCode == 35 || objEvent.keyCode == 36) && objEvent.ctrlKey == true))	// CTRL END and CTRL HOME
	{
		// Force any outstanding blurs on the form fields.
		m_objEditableGrid.objGridEdit.objForm.objFrameWindow.document.body.focus();

		if (m_objEditableGrid.objGridEdit.objForm.validate() == true)
		{
			if (objEvent.keyCode == 40 && m_objEditableGrid.objGridEdit.intRowIndex == m_objEditableGrid.HTMLtable.tBodies[0].rows.length - 1)
			{
				m_objEditableGrid.objGridEdit.fireOnNewRecord();
				m_objEditableGrid.selectRowIndex(m_objEditableGrid.objGridEdit.intRowIndex);
			}
			else
			{
				var objTR = m_objEditableGrid.HTMLtable.tBodies[0].rows[m_objEditableGrid.objGridEdit.intRowIndex];
				var objTD = objTR.cells[m_objEditableGrid.objGridEdit.intFieldIndex + 1];
				var objGridEvent = m_objEditableGrid.objAppWindow.document.createEventObject();

				objGridEvent.keyCode = objEvent.keyCode;
				objTD.fireEvent("onkeydown", objGridEvent);

				objGridEvent.keyCode = 13;
				objTD.fireEvent("onkeydown", objGridEvent);

				if (objEvent.keyCode == 35)
					m_objEditableGrid.objGridEdit.setFocusLastField();
				else if (objEvent.keyCode == 36)
					m_objEditableGrid.objGridEdit.setFocusFirstField();
			}
		}
		else
			m_objEditableGrid.objGridEdit.objForm.fields[m_objEditableGrid.objGridEdit.intFieldIndex].focus();

		objEvent.cancelBubble = true;
		objEvent.returnValue = false;
	}
	else if (objEvent.keyCode == 35 && objEvent.ctrlKey == false)	// END key
	{
		m_objEditableGrid.objGridEdit.setFocusLastField();
	}
	else if (objEvent.keyCode == 36 && objEvent.ctrlKey == false)	// HOME key
	{
		m_objEditableGrid.objGridEdit.setFocusFirstField();
	}
	else if (objEvent.keyCode == 9)			// TAB key
	{
		if (objEvent.shiftKey == false)
		{
			var intFieldIndex = m_objEditableGrid.objGridEdit.intFieldIndex + 1;
			var intRowIndex = m_objEditableGrid.objGridEdit.intRowIndex + 1;
			
			for ( ; ; )
			{
				if (intFieldIndex >= m_objEditableGrid.objGridEdit.objForm.fields.length)
					break;

				var objField = m_objEditableGrid.objGridEdit.objForm.fields[intFieldIndex];
				if (objField.HTMLElement.blnIsDisabled == "true" || objField.isVisible() == false)
					intFieldIndex ++;
				else
					break;
			}
			
			if (intFieldIndex >= m_objEditableGrid.objGridEdit.objForm.fields.length)
			{
				if (m_objEditableGrid.objGridEdit.editableFieldCount() == 1) {
					// Force any outstanding blurs on the form fields.
					var objChangeEvent = m_objEditableGrid.objAppWindow.document.createEventObject();
					objChangeEvent.keyCode = 9;
					var objTempField = m_objEditableGrid.objGridEdit.objForm.fields[m_objEditableGrid.objGridEdit.intFieldIndex];
					objTempField.HTMLElement.fireEvent("onchange", objChangeEvent)
				}

				// External onchange event may have cancelled row edit so check if form is null.
				if (m_objEditableGrid.objGridEdit.objForm != null) {
					if (m_objEditableGrid.objGridEdit.objForm.validate() == true) {
						// TAB only moves to the next record (and so acts as confirm) if there is only 1 editable box. 
						// More than 1 and tab keeps scrolling between the fields
						if (m_objEditableGrid.objGridEdit.editableFieldCount() == 1) {
							intFieldIndex = 0;

							if (intRowIndex >= m_objEditableGrid.getRowCount())
								intRowIndex = 0;
							
							var objTD = m_objEditableGrid.HTMLtable.tBodies[0].rows[intRowIndex].cells[intFieldIndex + 1];
							if (m_objEditableGrid.objGridEdit.activateEditForm(objTD) == true)
								m_objEditableGrid.selectRow(objTD.parentElement.cells[0].innerHTML);
							
						}
						m_objEditableGrid.objGridEdit.setFocusFirstField();
					}
					else
						m_objEditableGrid.objGridEdit.objForm.fields[m_objEditableGrid.objGridEdit.intFieldIndex].focus();
				}
				
				objEvent.cancelBubble = true;
				objEvent.returnValue = false;
			}
		}
		else
		{
			var intFieldIndex = m_objEditableGrid.objGridEdit.intFieldIndex - 1;
			var intRowIndex = m_objEditableGrid.objGridEdit.intRowIndex - 1;
			
			for ( ; ; )
			{
				if (intFieldIndex < 0)
					break;

				var objField = m_objEditableGrid.objGridEdit.objForm.fields[intFieldIndex];
				if (objField.HTMLElement.blnIsDisabled == "true" || objField.isVisible() == false)
					intFieldIndex --;
				else
					break;
			}

			if (intFieldIndex < 0)
			{
				if (m_objEditableGrid.objGridEdit.editableFieldCount() == 1) {
					// Force any outstanding blurs on the form fields.
					var objChangeEvent = m_objEditableGrid.objAppWindow.document.createEventObject();
					objChangeEvent.keyCode = 9;
					var objTempField = m_objEditableGrid.objGridEdit.objForm.fields[m_objEditableGrid.objGridEdit.intFieldIndex];
					objTempField.HTMLElement.fireEvent("onchange", objChangeEvent)
				}

				// External onchange event may have cancelled row edit so check if form is null.
				if (m_objEditableGrid.objGridEdit.objForm != null) {
					if (m_objEditableGrid.objGridEdit.objForm.validate() == true) {
						if (m_objEditableGrid.objGridEdit.editableFieldCount() == 1) {
							intFieldIndex = m_objEditableGrid.objGridEdit.objForm.fields.length - 1;

							for ( ; ; )
							{
								if (intFieldIndex < 0)
									break;

								var objField = m_objEditableGrid.objGridEdit.objForm.fields[intFieldIndex];
								if (objField.HTMLElement.blnIsDisabled == "true" || objField.isVisible() == false)
									intFieldIndex --;
								else
									break;
							}
							
							if (intRowIndex < 0)
								intRowIndex = m_objEditableGrid.getRowCount() - 1;

							var objTD = m_objEditableGrid.HTMLtable.tBodies[0].rows[intRowIndex].cells[intFieldIndex + 1];
							if (m_objEditableGrid.objGridEdit.activateEditForm(objTD) == true)
								m_objEditableGrid.selectRow(objTD.parentElement.cells[0].innerHTML);
						}
						m_objEditableGrid.objGridEdit.setFocusLastField();
					}
					else
						m_objEditableGrid.objGridEdit.objForm.fields[m_objEditableGrid.objGridEdit.intFieldIndex].focus();
				}
				
				objEvent.cancelBubble = true;
				objEvent.returnValue = false;
			}
		}
	}
}

/**
 * Hides the editable grid form.
 */
function GridEdit_hide()
{
	if (this.isVisible() == false)
		return;

	for (var i=0, intLen = this.objForm.fields.length; i < intLen; i++)
	{
		var objField = this.objForm.fields[i];
		var objGridCell = this.objGrid.HTMLtable.tBodies[0].rows[this.intRowIndex].cells[i + 1];
		
		if (objField.lookupInputs.length > 0)
			objField.HTMLElement.unformattedHTMLValue = null;
			
		if (objField.strDataType == "xsd:float" || objField.strDataType == "xsd:double" ||
			 objField.strDataType == "xsd:integer" || objField.strDataType == "xsd:short" ||
			 objField.strDataType == "xsd:smallint" || objField.strDataType == "xsd:decimal")
			objField.setValue(this.objGrid.getColumnValue(this.strUID, objField.strRef, true));
		else
			objField.setValue(this.objGrid.getColumnValue(this.strUID, objField.strRef));

		if (objField.isInvalid)
			objGridCell.className = "InvalidEditGridCell";
		else if (objGridCell.className == "InvalidEditGridCell")
			objGridCell.className = "EditGridCell";
	}

	this.objForm.formGroup.style.visibility = "hidden";
	this.fireOnEditEnd();

	try {
		this.objForm.objWindow.objStatusBar.clear();
		this.objGrid.HTMLdiv.focus();
	} catch (error) {
	}
}

/**
 * Fired when a form field receives the focus. Maintains intFieldIndex property.
 * Not prototyped so uses m_objEditableGrid.
 *
 * @param objEvent The window event object.
 */
function GridEdit_formFieldOnFocus(objEvent)
{
	if (objEvent == null)
		objEvent = window.event;

	m_objEditableGrid.objGridEdit.intFieldIndex = Math.round(et_getCellIndex(objEvent.srcElement.parentNode) / 2) - 1;

	m_objEditableGrid.objGridEdit.scrollFieldIntoView();
}

/**
 * Fired when the grid div is scrolled - need to scroll
 * absolute positioned IFrame correspondingly.
 * Not prototyped so uses m_objEditableGrid.
 *
 * @param objEvent The window event object.
 */
function GridEdit_onScroll(objEvent)
{
	if (m_objEditableGrid.objGridEdit.isVisible() == false)
		return;

	m_objEditableGrid.objGridEdit.positionIFrame();
}

/**
 * Absolute positions IFrame over correct grid row.
 */
function GridEdit_positionIFrame()
{
	// Move IFrame to correct position.
	var intScrollTop = this.objGrid.HTMLdiv.scrollTop;
	var intIFrameTop = getOffsetTopFromElement(this.objGrid.HTMLtable.tBodies[0].rows[this.intRowIndex], "mainBodyTag") - (intScrollTop + 1);
	var intScrollLeft = this.objGrid.HTMLdiv.scrollLeft;
	var intIFrameLeft = (getOffsetLeftFromElement(this.objGrid.HTMLdiv, "mainBodyTag") + 1) - intScrollLeft;
	var intGridTop = getOffsetTopFromElement(this.objGrid.HTMLdiv, "mainBodyTag");
	// MCB review - offsetWidth for tabbed dialogs returning incorrect value by 1px ?
	if (getParentElement(this.objGrid.HTMLdiv, "TABLE", "tabbeddialog") != null)
		intIFrameLeft ++;

	var objIFrame = this.objForm.formGroup;
	objIFrame.style.top = intIFrameTop;
	objIFrame.style.left = intIFrameLeft;

	// Now do the clip.	
	var intRight = this.objGrid.HTMLdiv.offsetWidth + intScrollLeft - 1;
	if (this.objGrid.HTMLdiv.scrollHeight > this.objGrid.HTMLdiv.offsetHeight)
		intRight -= 16;

	var intBottom = (intGridTop + this.objGrid.HTMLdiv.offsetHeight) - (intIFrameTop + 1);
	if (this.objGrid.HTMLdiv.scrollWidth > this.objGrid.HTMLdiv.offsetWidth)
		intBottom -= 16;
	var intTop = intGridTop - (intIFrameTop - 2);

	objIFrame.style.clip = "rect(" + intTop + " " + intRight + " " + intBottom + " " + Number(intScrollLeft + 1) + ")";
}

/**
 * Prevents the window itself from scrolling.
 *
 * @param objEvent The window event object.
 */
function GridEdit_onBodyScroll(objEvent)
{
	window.scrollTo(0, 0);
}

/**
 * Scrolls the current focus field into view with the grid div.
 */
function GridEdit_scrollFieldIntoView()
{
	var objTD = this.objGrid.HTMLtable.tBodies[0].rows[this.intRowIndex].cells[this.intFieldIndex + 1];
	var intCellOffsetLeft = getOffsetLeftFromElement(objTD, "et_grd" + this.objGrid.id);
	var intCellOffsetTop = getOffsetTopFromElement(objTD, "et_grd" + this.objGrid.id);

	// Horrizontally.
	// Check for too far right.
	if (intCellOffsetLeft + objTD.offsetWidth > this.objGrid.HTMLdiv.offsetWidth + this.objGrid.HTMLdiv.scrollLeft - 15)
	{
		var intPos = intCellOffsetLeft + objTD.offsetWidth;
		if (this.objGrid.HTMLdiv.scrollWidth > this.objGrid.HTMLdiv.offsetWidth)
			intPos += 15;
		this.objGrid.HTMLdiv.scrollLeft = (intPos - this.objGrid.HTMLdiv.offsetWidth) + 3;
	}
	else	// Check for too far left.
	{
		var intPos = intCellOffsetLeft - 5;
		if (intPos < this.objGrid.HTMLdiv.scrollLeft)
			this.objGrid.HTMLdiv.scrollLeft = intPos;
	}

	// Vertically.
	var intCellPos = (intCellOffsetTop + objTD.offsetHeight) - this.objGrid.HTMLdiv.scrollTop;
	// Check for too far down.
	if (intCellPos > this.objGrid.HTMLdiv.offsetHeight - 17)
	{
		var intScrollTop = (intCellOffsetTop + objTD.offsetHeight) - (this.objGrid.HTMLdiv.offsetHeight - 17);
		this.objGrid.HTMLdiv.scrollTop = intScrollTop;
	}

	// Check for too far up.
	var intPos = intCellOffsetTop - 16;
	if (intPos < this.objGrid.HTMLdiv.scrollTop)
		this.objGrid.HTMLdiv.scrollTop = intPos;
}

/**
 * Called when a form row is updated. Calls any externally defined method.
 *
 * @return True if change is accepted, false to cancel the row change.
 */
function GridEdit_fireValidateMethod() {
	if (this.validateMethod == null) {
		return true;
	}
	
	var lngUniqueID = this.strUID;
	var objForm = this.objForm;
	var methodName = this.validateMethod.replace(/(\(\));*/, "");
	if (methodName.indexOf("(") != -1) {
		// Doesn't appear to be any code that would reach this branch. Leave in for now.
		var evalFunction = new Function("lngUniqueID", "objForm", methodName.replace(")", ", lngUniqueID, objForm)"));
		if (evalFunction(lngUniqueID, objForm) == false) {
			this.setFocusFirstField();
			return false;
		}
	} else {
		if (window[methodName](lngUniqueID, objForm) == false) {
			this.setFocusFirstField();
			return false;
		}
	}

	return true;
}

/**
 * Sets focus on the first editable form field.
 */
function GridEdit_setFocusFirstField()
{
	for (var i = 0, intLen = this.objForm.fields.length; i < intLen; i++)
	{
		var objField = this.objForm.fields[i];
		if (objField.HTMLElement.blnIsDisabled == "false" && objField.isVisible() == true)
		{
			objField.focus();
			break;
		}
	}
}

/**
 * Sets focus on the last editable form field.
 */
function GridEdit_setFocusLastField()
{
	for (var i = this.objForm.fields.length - 1; i >= 0; i--)
	{
		var objField = this.objForm.fields[i];
		if (objField.HTMLElement.blnIsDisabled == "false" && objField.isVisible() == true)
		{
			objField.focus();
			break;
		}
	}
}

/**
 * Get the number of editable fields for the grid
 * @return Number of editable fields
 */
function GridEdit_editableFieldCount() {
	var objField;
	var editableFields = 0;
	for (var x = 0; x < m_objEditableGrid.objGridEdit.objForm.fields.length; x++) {
		objField = m_objEditableGrid.objGridEdit.objForm.fields[x];
		if (objField.HTMLElement.blnIsDisabled != "true" && objField.isVisible() == true) {
			editableFields++;
		}
	}
	return editableFields;
}

/**
 * Called when a grid row is about to be edited.
 */
function GridEdit_fireOnEditBegin() {
	if (this.onEditBegin == null) {
		return;
	}

	var objForm = this.objForm;
	var lngUniqueID = this.strUID;
	var methodName = this.onEditBegin.replace(/(\(\));*/, "");
	if (methodName.indexOf("(") != -1) {
		// Doesn't appear to be any code that would reach this branch. Leave in for now.
		var evalFunction = new Function("lngUniqueID", "objForm", methodName.replace(")", ", lngUniqueID, objForm)"));
		evalFunction(lngUniqueID, objForm);
	} else {
		window[methodName](lngUniqueID, objForm);
	}
}

/**
 * Called when a grid row is either confirmed or cancelled and the row edit is done.
 */
function GridEdit_fireOnEditEnd() {
	if (this.onEditEnd == null) {
		return;
	}

	var objForm = this.objForm;
	var lngUniqueID = this.strUID;
	var methodName = this.onEditEnd.replace(/(\(\));*/, "");
	if (methodName.indexOf("(") != -1) {
		// Doesn't appear to be any code that would reach this branch. Leave in for now.
		var evalFunction = new Function("lngUniqueID", "objForm", methodName.replace(")", ", lngUniqueID, objForm)"));
		evalFunction(lngUniqueID, objForm);
	} else {
		window[methodName](lngUniqueID, objForm);
	}
}

/**
 * Called when a new grid row is required.
 */
function GridEdit_fireOnNewRecord() {
	if (this.onNewRecord == null) {
		return;
	}

	window[this.onNewRecord.replace(/(\(\));*/, "")]();
}



var m_objCaretPos;

/** 
 * Constructor for IEEditor object
 *
 * @param objTextEditor Reference to the wrapper TextEditor object.
 */
function IEEditor(objTextEditor)
{
	this.objTextEditor			= objTextEditor;
	this.name					= "TextEditor";
	this.editDiv				= null;

	//methods
	this.createEditorHTML		= iee_createEditorHTML;
	this.setNotesText			= iee_setNotesText;
	this.getText				= iee_getText;
	this.getBase64EncodedText	= iee_getBase64EncodedText;
	this.hideGroup				= iee_hideGroup;
	this.showGroup				= iee_showGroup;
	this.setCombos				= iee_setCombos;
	this.changeEditorMode		= iee_changeEditorMode;
	this.displayDiv				= iee_displayDiv;
	this.getFontList			= iee_getFontList;
	this.getFontSizeList		= iee_getFontSizeList;
	this.bold					= iee_bold;
	this.italic					= iee_italic;
	this.underline				= iee_underline;
	this.cut					= iee_cut;
	this.copy					= iee_copy;
	this.paste					= iee_paste;
	this.alignLeft				= iee_alignLeft;
	this.alignRight				= iee_alignRight;
	this.alignCenter			= iee_alignCenter;
	this.setFontFamily			= iee_setFontFamily;
	this.setFontSize			= iee_setFontSize;
	this.insertDate				= iee_insertDate;
	this.createTable			= iee_createTable;
	this.addHTML				= iee_addHTML;
	this.pickColourRGB			= iee_pickColourRGB;
	this.pickColourHex			= iee_pickColourHex;
	this.processText			= iee_processText;
	this.storeText				= iee_storeText;
	this.initCaretPosition		= iee_initCaretPosition;
}

/**
 * Returns editable div.
 *
 * @return The editable DIV HTML string.
 */
function iee_createEditorHTML()
{
	return "<div id='" + this.objTextEditor.id + "_notes_div_edit' onselect='iee_saveCaret(this)'" +
		   "onclick='iee_saveCaret(this)' onkeypress='iee_onkeypress(this)' onkeyup='iee_saveCaret(this)' class='enotes-div-edit' contenteditable='true' onfocusout='iee_storeText(this)'>.</div>";
}

/**
 * Sets the text editor content.
 *
 * @param strHTML The HTML editor content.
 */
function iee_setNotesText(strHTML)
{
	this.objTextEditor.objWindow.document.getElementById(this.objTextEditor.id + "_notes_div_edit").innerHTML = strHTML;
}

/**
 * Returns the current text editor content.
 *
 * @return Text editor content.
 */
function iee_getText()
{
	var retVal;

	if (this.objTextEditor.flgEditorDisplay == true)
		retVal = this.objTextEditor.objWindow.document.getElementById(this.objTextEditor.id + "_notes_div_display").innerHTML;
	else
		retVal = this.objTextEditor.objWindow.document.getElementById(this.objTextEditor.id + "_notes_div_edit").innerHTML;

	if (retVal.substring(0, 3).toLowerCase() != "<p>")
		retVal = "<p>" + retVal + "</p>";

	var regEx = /<BR>/g;
	retVal = retVal.replace(regEx, "<br>");
	var regEx = /<P>/g;
	retVal = retVal.replace(regEx, "<p>");
	var regEx = /<\/P>/g;
	retVal = retVal.replace(regEx, "</p>");

	return "<html><head></head><body>" + retVal + "</body></html>";
}

/**
 * Returns the text contained in the editor as a base-64 encoded string.
 *
 * @return The base64 encoded string.
 */
function iee_getBase64EncodedText()
{
	return b64Encode(this.getText());
}

/**
 * Hides second group of buttons on text editor toolbar.
 *
 * @param objToolbar The toolbar reference.
 */
function iee_hideGroup(objToolbar)
{
	objToolbar.hideGroup("2");
}

/**
 * Shows second group of buttons on text editor toolbar.
 *
 * @param objToolbar The toolbar reference.
 */
function iee_showGroup(objToolbar)
{
	objToolbar.showGroup("2");
	objToolbar.suppressGroupLabels("2");
}

/**
 * Takes references and populates combo boxes.
 */
function iee_setCombos()
{
	var fontcombo = this.objTextEditor.objWindow.document.getElementById(this.objTextEditor.id + "cmbFont");
	var sizecombo = this.objTextEditor.objWindow.document.getElementById(this.objTextEditor.id + "cmbSize");
	var appletParam = this.objTextEditor.objWindow.document.getElementById(this.objTextEditor.id + "_notes");

	var sFont = this.getFontList();
	var sFonts = sFont.split("|");
	for (loop=0; loop < sFonts.length - 1;loop++)
	{			
		fontcombo.options[loop] = new Option(sFonts[loop]);
		if(sFonts[loop] == "Times New Roman")
		{
			fontcombo.options[loop].selected=true;
		}
	}		
	var sSize = this.getFontSizeList();
	var sSizes = sSize.split("|");
	for (loop=0; loop < sSizes.length - 1;loop++)
	{
		sizecombo.options[loop] = new Option(sSizes[loop]);
	}
}

/**
 * Changes editor mode.
 */
function iee_changeEditorMode()
{
}

/**
 * Initialise applet when text editor div is displayed.
 */
function iee_displayDiv()
{
	if (!this.objTextEditor.flgLoaded)
		this.objTextEditor.initialiseApplet();
}

/**
 * Returns font list.	
 *
 * @return The pipe separated list of fonts.
 */
function iee_getFontList()
{
	return "Arial|Arial Black|Arial Narrow|Book Antiqua|Bookman Old Style|Century Gothic|Comic Sans MS|Courier New|Default|Dialog|DialogInput|Garamond|Georgia|Haettenschweiler|Impact|Lucida Bright|Lucida Console|Lucida Sans|Lucida Sans Typewriter|Lucida Sans Unicode|Marlett|Microsoft Sans Serif|Monospaced|Monotype Corsiva|MS Outlook|Palatino Linotype|SansSerif|Serif|Symbol|Tahoma|Times New Roman|Trebuchet MS|Verdana|Webdings|Wingdings|Wingdings 2|Wingdings 3|";
}

/**
 * Returns font size list.
 *
 * @return The pipe separated list of font sizes.
 */
function iee_getFontSizeList()
{
	return "10|12|15|18|24|36|48|";
}

/**
 * Toggles bold property for highlighted text.
 */
function iee_bold()
{
	this.objTextEditor.objWindow.document.execCommand("Bold");
}

/**
 * Toggles italic property for highlighted text.
 */
function iee_italic()
{
	this.objTextEditor.objWindow.document.execCommand("Italic");
}

/**
 * Toggles underline property for highlighted text.
 */
function iee_underline()
{
	this.objTextEditor.objWindow.document.execCommand("Underline");
}

/**
 * Cuts highlighted text.
 */
function iee_cut()
{
	this.objTextEditor.objWindow.document.execCommand("Cut");
}

/**
 * Copies highlighted text.
 */
function iee_copy()
{
	this.objTextEditor.objWindow.document.execCommand("Copy");
}

/**
 * Pastes text from clipboard at current cursor location.
 */
function iee_paste()
{
	if (m_objCaretPos != null && m_objCaretPos.text == "")
		m_objCaretPos.select();

	this.objTextEditor.objWindow.document.execCommand("Paste");
}

/**
 * Aligns highlighted text to the left.
 */
function iee_alignLeft()
{
	this.objTextEditor.objWindow.document.execCommand("JustifyLeft");
}

/**
 * Aligns highlighted text to the right.
 */
function iee_alignRight()
{
	this.objTextEditor.objWindow.document.execCommand("JustifyRight");
}

/**
 * Centers the highlighted text.
 */
function iee_alignCenter()
{
	this.objTextEditor.objWindow.document.execCommand("JustifyCenter");
}

/**
 * Sets font name for highlighted text.
 *
 * @param strFontName The font name.
 */
function iee_setFontFamily(strFontName)
{
	this.objTextEditor.objWindow.document.execCommand("FontName", false, strFontName);
}

/**
 * Sets font size for highlighted text.
 *
 * @param intFontSize The font size.
 */
function iee_setFontSize(intFontSize)
{
	this.objTextEditor.objWindow.document.execCommand("FontSize", false, this.objTextEditor.cmbSize.selectedIndex + 1);
}

/**
 * Inserts date at current cursor location.
 *
 * @param strDate The date string
 */
function iee_insertDate(strDate)
{
	if (m_objCaretPos == null || m_objCaretPos.htmlText == "")
		this.initCaretPosition();
	
	m_objCaretPos.pasteHTML(strDate);
}

/**
 * Private method.
 * Saves current cursor location.
 *
 * @param objElement The html element containing cursor.
 */
function iee_saveCaret(objElement)
{
	m_objCaretPos = objElement.ownerDocument.selection.createRange();
}

/**
 * Private method.
 * Intercepts carriage return key presses and inserts a br instead of the default p tag.
 *
 * @param objElement The html element containing cursor.
 */
function iee_onkeypress(objEditDiv)
{
	if (event.keyCode == 13 && m_objCaretPos != null)			// ENTER KEY
	{
		var intPos = -1;
		
		if (m_objCaretPos.text == "")
		{
			m_objCaretPos.text = "~";
			m_objCaretPos.moveStart('character', -1);
			m_objCaretPos.select();
		}
		
		m_objCaretPos.pasteHTML("<br>");
		
		event.returnValue = false;
		event.cancelBubble = true;
	}
}

/**
 * Inserts a HTML table at current cursor location.
 *
 * @param strTableHTML The table html string.
 */
function iee_createTable(strTableHTML)
{
	this.addHTML(strTableHTML);
}

/**
 * Adds HTML at current cursor location.
 *
 * @param strHTML The html string.
 */
function iee_addHTML(strHTML)
{		
	if (m_objCaretPos == null || m_objCaretPos.htmlText == "")
		this.initCaretPosition();
		
	m_objCaretPos.pasteHTML(strHTML);
	
}

/**
 * Sets foreground colour for highlighted text.
 *
 * @param r The red value.
 * @param g The blue value.
 * @param b The green value.
 */
function iee_pickColourRGB(r, g, b)
{
}

/**
 * Sets foreground colour for highlighted text.
 *
 * @param hexValue The r,g,b hex value.
 */
function iee_pickColourHex(hexValue)
{
	this.objTextEditor.objWindow.document.execCommand("ForeColor", false, hexValue);
}

/**
 * Performs any editor specific text manipulation.
 * Called before saving and setting notes text into the editor.
 *
 * @param strHTML The preprocessed HTML.
 * @return The processed HTML.
 */
function iee_processText(strHTML)
{
	return strHTML;
}

/**
 * Call the text editor storeText method which updates/adds the editor text to the 
 * XMLDetail XML island.
 *
 * @param objElement - The element from which the texteditor reference is obtained.
 */
function iee_storeText(objElement) {
	var objThisTextEditor = eval(objElement.id.replace("_notes_div_edit", ""));
	objThisTextEditor.storeText();
}

/**
 * Initialises the editor caret position to the start of the eNotes editor.
 * Only called when user attempts to carry out an action which doesn't require editor keypress.
 */
function iee_initCaretPosition() {
	this.objTextEditor.objWindow.document.getElementById(this.objTextEditor.id + "_notes_div_edit").focus();
	iee_saveCaret(this.objTextEditor.objWindow.document.getElementById(this.objTextEditor.id + "_notes_div_edit"));
}

	

/** 
 * Constructor for InfoPanel
 * @param InfoPanelID Information panel ID from the calling application
 * @param objappWindow Application window
 * @param strURL URL containing parameters for the information panel
 */
function InfoPanel(InfoPanelID, objAppWindow, strURL)
{
	this.AppWindow				= objAppWindow;
	this.dataEngine				= null;
	this.title					= "";
	this.backgroundColour		= "";
	this.timeoutID				= null;
	this.Form					= null;
	this.run					= InfoPanel_run;
	this.pause					= InfoPanel_pause;
	this.initialise				= InfoPanel_initialise;
	this.addPrompt				= InfoPanel_addPrompt;
	this.id						= InfoPanelID;
	
	this.arrTypes				= new Array();
	this.arrColumns				= new Array();
	this.arrTables				= new Array();
	this.url					= strURL;
	this.arrGallery				= new Array();
	this.popOutWindow			= InfoPanel_popOutWindow;
	this.getGalleryDetails		= InfoPanel_getGalleryDetails;
	this.arrValues				= new Array();
	this.loadGalleyDoc			= InfoPanel_loadGalleyDoc;
	this.hasPermission 			= InfoPanel_hasPermission;
	this.nextImage				= InfoPanel_nextImage;
	this.previousImage			= InfoPanel_previousImage;
	this.imageIndex				= 0;
	this.strFirstTable			= "";
	this.getTableName			= InfoPanel_getTableName;
	this.lastViewedImage		= -1;
}
/** 
 * Called to display the information panel, when a workflowtask id and step are passed in the information panel becomes a
 * workflow task viewer, it then hides the navigation, hold and timestamp buttons
 */
function InfoPanel_run()
{
	var strCol;
	var objDataEngineXML;
	var objField;
	// workflow task code
	if (typeof(ParseStringFromURL("workflowtask", this.url)) != 'undefined') {
		this.AppWindow.document.getElementById("hrsep").style.display = "none";		
		this.AppWindow.document.getElementById("infopanelcontrols").style.display = "none";
		
		var instance = ParseStringFromURL("workflowtask", this.url);
		var step = ParseStringFromURL("step", this.url);
		var objNotesData = new RPCObject("EMediaDetail",window);  
		objNotesData.execute("load", objApplication.Connection.strConnectionString, "workflowstep","InstructionsHeader", instance, step, "", "");
		var loadElement = objNotesData.getReturnedXMLDom();	
		var objTextNode = loadElement.selectSingleNode("//emediadetails/emediadetail/data/value");
		if (objTextNode != null) {
			this.AppWindow.document.getElementById("headertext").style.display = "inline";
			this.AppWindow.document.getElementById("headersi").innerHTML = objTextNode.getText();
		}
		this.pause();
	} 
	
	this.dataEngine.caseSensitive = true;

	for (var i = 0; i < 12; i++) {
		if (typeof(ParseStringFromURL("value" + i, this.url)) == 'undefined') {
			break;
		}
		this.arrValues[i] = unescapeXML(b64Decode(undoReplaceForURL(ParseStringFromURL("value" + i, this.url))));
		this.dataEngine.addInputParameter("value" + i, 
										this.arrValues[i], 
										this.arrTables[i], 
										this.arrColumns[i], 
										this.arrTypes[i]);
	}

	objDataEngineXML = objApplication.createXMLDocument(this.dataEngine.populateEngine());

	var objNodes = objDataEngineXML.selectNodes("//row/column");
	for (var n = 0, intLen = objNodes.length(); n < intLen; n++)
	{
		strCol = objNodes.item(n).getAttribute("ref");
		objField = this.Form.getFieldByRef(strCol);
		
		// ignore the column if it is not present on the infopanel.
		if (objField != null) {
			objField.setValue(objNodes.item(n).getText());

		// Creates a span and sets innerText = to textbox value - 
		// with this we can determine the required width for the textbox.
			var newElem = this.AppWindow.document.createElement("SPAN");
			newElem.style.visibility = "hidden";
			newElem.innerHTML = escapeXML(objField.getHTMLElement().value);
			this.AppWindow.document.body.appendChild(newElem);

			var strTableName = this.getTableName(objField.strRef);
			if (strTableName == this.strFirstTable) {

				objField.HTMLElement.style.fontWeight = "bold";
				newElem.style.fontWeight = "bold";
				objField.HTMLElement.style.fontSize = "larger";
				newElem.style.fontSize = "larger";
				var objLabel = this.Form.objFrameWindow.document.getElementById("lbl_" + objField.HTMLElement.id);
				objLabel.style.fontWeight = "bold";
				objLabel.style.fontSize = "larger";
			}

			if (objField.HTMLElement.type != "checkbox" && objField.HTMLElement.type != "radio")
				objField.getHTMLElement().style.width = newElem.offsetWidth + "px";
			this.AppWindow.document.body.removeChild(newElem);
		}
	}

	if (objApplication.Modules("0020a-docm"))
		this.getGalleryDetails();
		
	var objGalleryContainer = eval("ccInfoGallery" + this.id);

	if (this.arrGallery.length > 0) {
		objGalleryContainer.objHTMLElement.style.display = "inline";
		this.loadGalleyDoc(this.arrGallery[0]);
		window.document.getElementById(objGalleryContainer.id + "imgPrevious").title = fl("PREVIOUSDOCUMENT");
		window.document.getElementById(objGalleryContainer.id + "imgNext").title = fl("NEXTDOCUMENT");
		window.document.getElementById(objGalleryContainer.id + "imgPopOut").title = fl("POPOUTDOC");
	} else {
		objGalleryContainer.objHTMLElement.style.display = "none";
	}

	this.Form.disable();
	
	for (var n = 0, intLen = this.Form.fields.length; n < intLen; n++) 
	{
		var objFormField = this.Form.fields[n];
		objFormField.disableAddressLookup(true);
		objFormField.disableDatePicker(true);
		objFormField.HTMLElement.style.border = "none";
		objFormField.HTMLElement.style.backgroundColor = "transparent";
	}

	this.AppWindow.focus();
}

function InfoPanel_addPrompt(strTable, strColumn, strType)
{
	if (this.arrTables.length == 0)
		this.strFirstTable = strTable;
	this.arrTables[this.arrTables.length] = strTable;
	this.arrColumns[this.arrColumns.length] = strColumn;
	this.arrTypes[this.arrTypes.length] = strType;
}

function InfoPanel_pause()
{
	this.AppWindow.clearTimeout(this.timeoutID);
}
function InfoPanel_initialise()
{
	this.timeoutID = this.AppWindow.setTimeout("window.close()", 20000);

	if (this.backgroundColour != "")
		this.AppWindow.document.body.style.backgroundColor = this.backgroundColour;
}

/**
 * Allows the currently displayed document to be expanded
 */
function InfoPanel_popOutWindow()
{
	if (this.hasPermission(this.arrGallery[this.imageIndex], "readdocs") == "false")
	{
		return;
	}
	var strURL = "../Applications_HTML/appDocumentView.html";
	strURL += "?docID=" + replaceForURL(b64Encode(this.arrGallery[this.imageIndex]));

    objApplication.openChildWindow(window, strURL);
}

/**
 * Gets details of the documents (if any) that should be shown in the gallery
 */
function InfoPanel_getGalleryDetails()
{
	if (isBlank(this.strFirstTable)) {
		this.arrGallery = new Array();
		return;
	}
	
	// We've got a table name so see if there are any items in the corresponding _docs table
	// that are flagged as being in the gallery.
	var strXML = "<keys>";
	for (var i = 0, intLen = this.arrTables.length; i < intLen; i++)
	{
		if (!isBlank(this.arrValues[i])) {
			if (this.arrTables[i] == this.strFirstTable)
				strXML += "<key ref='" + this.arrColumns[i] + "' value='" + escapeXML(this.arrValues[i]) + "' datatype='" + this.arrTypes[i] + "'/>";
		}
		else
			break;
	} 
	strXML += "</keys>";
	
	var objRPCObject = new RPCObject("DocumentRegister");
    objRPCObject.execute("getGalleryDetails", objApplication.Connection.strConnectionString, this.strFirstTable, strXML);
    
	if (objRPCObject.FAILED) {
		this.arrGallery = new Array();
        return false;
    }
    
    // Should return an XML string with details of any document ids
   	var objXML = objRPCObject.getReturnedXMLDom();
	var objNodes = objXML.selectNodes("/documentids/documentid");

	for (var intCtr = 0, intLen = objNodes.length(); intCtr < intLen; intCtr++)
	{
		this.arrGallery[this.arrGallery.length] = objNodes.item(intCtr).getAttribute("id");
	}
}

/** 
 * Loads the document.
 * @param strDocumentID The id of the document to be loaded.
 */
function InfoPanel_loadGalleyDoc(strDocumentID) {

	if (this.lastViewedImage == this.imageIndex)
		return;

	var objGalleryContainer = eval("ccInfoGallery" + this.id);

	if (!objGalleryContainer.isVisible)
		return;

	if (this.hasPermission(strDocumentID, "readdocs") == "false")
	{
		document.getElementById("ccInfoGalleryView" + this.id).src = "../HTML/htmBlankNoPermissions.htm";
		objGalleryContainer.setTitle(fl("DOCUMENTXOFY", (this.imageIndex + 1), this.arrGallery.length));
		return;
	}

	var div = eval("divDocServletGalleryView" + this.id);

	if (div.children && div.children.length > 0 && div.children[0].tagName == "FORM") {
		var objOldNode = div.children[0];
		div.removeChild(objOldNode);
	}

	var objNode = document.createElement("form");
	objNode.id = "frmDocServletGalleryView";
	objNode.name = "frmDocServletGalleryView";
	objNode.action = "http://" + objApplication.Connection.applicationServer + "/efacs/servlet/DocumentServlet";
	objNode.target = "ccInfoGalleryView" + this.id;
	objNode.method = "POST";
	var objInputNode = document.createElement("input");
	objInputNode.type = "hidden";
	objInputNode.name = "sessionstring";
	objInputNode.id = "sessionstring";
	objInputNode.value = objApplication.Connection.strConnectionString;
	var objInputNode2 = document.createElement("input");
	objInputNode2.type = "hidden";
	objInputNode2.name = "documentid";
	objInputNode2.id = "documentid";
	objInputNode2.value = strDocumentID;
	objNode.appendChild(objInputNode);
	objNode.appendChild(objInputNode2);

	div.appendChild(objNode);	
	objNode.submit();

	objGalleryContainer.setTitle(fl("DOCUMENTXOFY", (this.imageIndex + 1), this.arrGallery.length));
}

/**
 * Checks whether the user has the specified permission for the cabinet the document is in
 * @param strDocumentID The document id
 * @param strPermissionType The permission type (adddocs, readdocs, modifydocs or removedocs)
 * @return "true" or "false" depending on whether the users roles.
 */
function InfoPanel_hasPermission(strDocumentID, strPermissionType)
{
	var objRPCObject = new RPCObject("documentregister");
	return objRPCObject.execute("hasPermissionByDocument", objApplication.Connection.strConnectionString, strDocumentID, strPermissionType);
}

/**
 * Move to the next image
 */
function InfoPanel_nextImage()
{
	this.lastViewedImage = this.imageIndex;
	
	if (this.imageIndex < this.arrGallery.length - 1)
		this.imageIndex++;
	else 
		this.imageIndex = 0;

	this.loadGalleyDoc(this.arrGallery[this.imageIndex]);
}

/**
 * Move to the previous image
 */
function InfoPanel_previousImage()
{
	this.lastViewedImage = this.imageIndex;
	
	if (this.imageIndex != 0)
		this.imageIndex--;
	else 
		this.imageIndex = this.arrGallery.length - 1;
	this.loadGalleyDoc(this.arrGallery[this.imageIndex]);
}

/**
 * Get the table name for the specified column
 * @param strColumnName The column name
 * @return the table name
 */
function InfoPanel_getTableName(strColumnName)
{
	for (var i = 0, intLen = this.arrColumns.length; i < intLen; i++) {
		if (this.arrColumns[i] == strColumnName)
			return this.arrTables[i];
	}
	
	return "";
}



var m_objLicencedTextEditor = null;

/** 
 * Constructor for LicencedEditor object
 *
 * @param objTextEditor Reference to the wrapper TextEditor object.
 */
function LicencedEditor(objTextEditor)
{
	m_objLicencedTextEditor		= objTextEditor;
	this.name					= "edit-on-pro-signed";
	this.appletElement			= null;

	//methods
	this.createEditorHTML		= le_createEditorHTML;
	this.setNotesText			= le_setNotesText;
	this.getText				= le_getText;
	this.getBase64EncodedText	= le_getBase64EncodedText;
	this.hideGroup				= le_hideGroup;
	this.showGroup				= le_showGroup;
	this.setCombos				= le_setCombos;
	this.changeEditorMode		= le_changeEditorMode;
	this.displayDiv				= le_displayDiv;
	this.replaceText			= le_replaceText;
	this.bold					= le_bold;
	this.italic					= le_italic;
	this.underline				= le_underline;
	this.cut					= le_cut;
	this.copy					= le_copy;
	this.paste					= le_paste;
	this.alignLeft				= le_alignLeft;
	this.alignRight				= le_alignRight;
	this.alignCenter			= le_alignCenter;
	this.setFontFamily			= le_setFontFamily;
	this.setFontSize			= le_setFontSize;
	this.insertDate				= le_insertDate;
	this.createTable			= le_createTable;
	this.addHTML				= le_addHTML;
	this.pickColourRGB			= le_pickColourRGB;
	this.pickColourHex			= le_pickColourHex;
	this.processText			= le_processText;
}

/**
 * Returns applet html for the licenced editor.
 *
 * @return The applet html string.
 */
function le_createEditorHTML()
{
	var objApplet = new Applet(m_objLicencedTextEditor.id + "_notes", this.name, "100%", "100%");

	objApplet.addParam('code', 'EditorApplet');
	objApplet.addParam('mayscript', 'true');
	objApplet.addParam('viewastext', 'true');
	objApplet.addParam('localeurl', '../XML/locale_ex_EP.xml');
	objApplet.addParam('toolbarurl', '../Toolbars/eopToolbar.xml');
	objApplet.addParam('spellcheckerproperties', ''); // Path to the spellchecker properties .txt file
	objApplet.addParam('sourceview', 'false');
	objApplet.addParam('defaultfontcolor', 'black');
	objApplet.addParam('defaultbackgroundcolor', 'white');
	objApplet.addParam('defaultlinkcolor', 'blue');
	objApplet.addParam('defaultfontsize', '12');
	objApplet.addParam('defaultfontface', 'serif');
	objApplet.addParam('bodyonly', 'true');
	objApplet.addParam('textmode', 'false');
	objApplet.addParam('xhtmlmode', 'true');
	objApplet.addParam('inserttext_html', 'true');
	objApplet.addParam('gethtmldataurl', '');
	objApplet.addParam('sethtmldataurl', '');
	objApplet.addParam('simpletable', 'true');
	objApplet.addParam('nbspfill', 'false');
	objApplet.addParam('tablenbspfill', 'false');
	objApplet.addParam('oneditorloaded', 'editorLoaded');
	objApplet.addParam('ondataloaded', 'dataLoaded');
	objApplet.addParam('imageroot', '../GIF/eop');
	objApplet.addParam('licensekey', '../XML/licensekey.xml');
	objApplet.addParam('stylemapping', '../XML/eopParagraphStyle.xml');
	objApplet.addArchive('edit-on-pro-signed');
	objApplet.addArchive('ssce');

	return objApplet.getHTML();;
}

/**
 * Sets the text editor content.
 *
 * @param strHTML The HTML editor content.
 */
function le_setNotesText(strHTML)
{
	this.appletElement.setHTMLData("http://",strHTML);
}

/**
 * Returns the current text editor content.
 *
 * @return Text editor content.
 */
function le_getText()
{
	return this.appletElement.getHTMLData("http://");
}

/**
 * Returns the text contained in the editor as a base-64 encoded string.
 *
 * @return The base64 encoded string.
 */
function le_getBase64EncodedText()
{
	return b64Encode(this.getText());
}

/**
 * Hides second group of buttons on text editor toolbar.
 *
 * @param objToolbar The toolbar reference.
 */
function le_hideGroup(objToolbar)
{
	objToolbar.hideGroup("2");
}

/**
 * Shows second group of buttons on text editor toolbar.
 *
 * @param objToolbar The toolbar reference.
 */
function le_showGroup(objToolbar)
{
	objToolbar.showGroup("2");
	objToolbar.suppressGroupLabels("2");
}

/**
 * Takes references and populates combo boxes.
 */
function le_setCombos()
{
}

/**
 * Changes editor mode.
 */
function le_changeEditorMode()
{
	if (!m_objLicencedTextEditor.flgEditorDisplay && (!m_objLicencedTextEditor.appletReady || (String(this.replaceText(generateHTML(this.getText()))) != String(m_objLicencedTextEditor.objTextEditor.objWindow.document.getElementById(m_objLicencedTextEditor.id + "_notes_div_display").innerHTML))))
	{
		m_objLicencedTextEditor.initialiseApplet();
	}
}

/**
 * Initialise applet when text editor div is displayed.
 */
function le_displayDiv()
{
}

/**
 * Corrects case for some html tags.
 *
 * @param strHTML The html string to be searched.
 * @return The replaced html string.
 */
function le_replaceText(strHTML)
{
	var newStrHTML = strHTML;

	while (newStrHTML.indexOf("<p>") != -1)
		newStrHTML = newStrHTML.replace("<p>", "<P>");

	while (newStrHTML.indexOf("</p>") != -1)
		newStrHTML = newStrHTML.replace("</p>", "</P>");

	while (newStrHTML.indexOf("<b>") != -1)
		newStrHTML = newStrHTML.replace("<b>", "<B>");

	while (newStrHTML.indexOf("</b>") != -1)
		newStrHTML = newStrHTML.replace("</b>", "</B>");

	while (newStrHTML.indexOf("<i>") != -1)
		newStrHTML = newStrHTML.replace("<i>", "<I>");

	while (newStrHTML.indexOf("</i>") != -1)
		newStrHTML = newStrHTML.replace("</i>", "</I>");

	while (newStrHTML.indexOf("<u>") != -1)
		newStrHTML = newStrHTML.replace("<u>", "<U>");

	while (newStrHTML.indexOf("</u>") != -1)
		newStrHTML = newStrHTML.replace("</u>", "</U>");

	while (newStrHTML.indexOf("</P>\n") != -1)
		newStrHTML = newStrHTML.replace("</P>\n", "</P>");

	while (newStrHTML.indexOf("</P>\r\n") != -1)
		newStrHTML = newStrHTML.replace("</P>\r\n", "</P>");
	
	return newStrHTML;
}

/**
 * Fired when licenced editor has been loaded.
 *
 * @param objApplet Reference to the java applet.
 */
function editorLoaded(objApplet)
{
}

/**
 * Fired when licenced editor data has been loaded.
 *
 * @param objApplet Reference to the java applet.
 */
function dataLoaded(objApplet)
{
	m_objLicencedTextEditor.strOriginalNotes = m_objLicencedTextEditor.objEditor.getText();
}

/**
 * Toggles bold property for highlighted text.
 */
function le_bold()
{
	this.appletElement.bold();
}

/**
 * Toggles italic property for highlighted text.
 */
function le_italic()
{
	this.appletElement.italic();
}

/**
 * Toggles underline property for highlighted text.
 */
function le_underline()
{
	this.appletElement.underline();
}

/**
 * Cuts highlighted text.
 */
function le_cut()
{
	this.appletElement.cut();
}

/**
 * Copies highlighted text.
 */
function le_copy()
{
	this.appletElement.copy();
}

/**
 * Pastes text from clipboard at current cursor location.
 */
function le_paste()
{
	this.appletElement.paste();
}

/**
 * Aligns highlighted text to the left.
 */
function le_alignLeft()
{
	this.appletElement.alignLeft();
}

/**
 * Aligns highlighted text to the right.
 */
function le_alignRight()
{
	this.appletElement.alignRight();
}

/**
 * Centers the highlighted text.
 */
function le_alignCenter()
{
	this.appletElement.alignCenter();
}

/**
 * Sets font name for highlighted text.
 *
 * @param strFontName The font name.
 */
function le_setFontFamily(strFontName)
{
	this.appletElement.setFontFamily(strFontName);
}

/**
 * Sets font size for highlighted text.
 *
 * @param intFontSize The font size.
 */
function le_setFontSize(intFontSize)
{
	this.appletElement.setFontSize(intFontSize);
}

/**
 * Inserts date at current cursor location.
 *
 * @param strDate The date string
 */
function le_insertDate()
{
	this.appletElement.insertDate();
}

/**
 * Inserts a HTML table at current cursor location.
 *
 * @param strTableHTML The table html string.
 */
function le_createTable(strTableHTML)
{
	this.appletElement.createTable(strTableHTML);
}

/**
 * Adds HTML at current cursor location.
 *
 * @param strHTML The html string.
 */
function le_addHTML(strHTML)
{
	this.appletElement.addHTML(strHTML);
}

/**
 * Sets foreground colour for highlighted text.
 *
 * @param r The red value.
 * @param g The blue value.
 * @param b The green value.
 */
function le_pickColourRGB(r, g, b)
{
}

/**
 * Sets foreground colour for highlighted text.
 *
 * @param hexValue The r,g,b hex value.
 */
function le_pickColourHex(hexValue)
{
}

/**
 * Performs any editor specific text manipulation.
 * Called before saving and setting notes text into the editor.
 *
 * @param strHTML The preprocessed HTML.
 * @return The processed HTML.
 */
function le_processText(strHTML)
{
	return strHTML;
}

	
	

// ADAPT constants.
var ADAPT_ONBEFOREMOVELEFT = 0x1;
var ADAPT_ONAFTERMOVELEFT = 0x2;
var ADAPT_ONBEFOREMOVERIGHT = 0x4;
var ADAPT_ONAFTERMOVERIGHT = 0x8;
var ADAPT_ONBEFOREMOVEALLLEFT = 0x16;
var ADAPT_ONAFTERMOVEALLLEFT = 0x32;
var ADAPT_ONBEFOREMOVEALLRIGHT = 0x64;
var ADAPT_ONAFTERMOVEALLRIGHT = 0x128;

/** 
 * Constructor for the ListPicker object
 *
 * @param objectID The list picker id.
 * @param grdSourceGrid A reference to the list picker source grid.
 * @param grdDestinationGrid A reference to the list picker destination grid.
 * @param qrySourceQuery A reference to the list picker source query.
 * @param qryDestinationQuery A reference to the list picker destination query.
 * @param objAppWindow The window object.
 */
function ListPicker(objectID, grdSourceGrid, grdDestinationGrid, qrySourceQuery, qryDestinationQuery, objAppWindow) {

// properties
	this.objAppWindow			= objAppWindow;
	this.id 					= objectID;
	this.HTMLElement			= window.document.getElementById(objectID);
	
	this.flgIsDirty				= false;
	
	this.sourceGrid				= grdSourceGrid;
	this.destinationGrid		= grdDestinationGrid;
	this.sourceGrid.isListPicker		= true;
	this.destinationGrid.isListPicker	= true;
	this.sourceQuery			= qrySourceQuery;
	this.destinationQuery		= qryDestinationQuery;
	
	this.onMoveUp				= null;
	this.onMoveDown				= null;
	this.onBeforeMoveLeft		= null;
	this.onBeforeMoveRight		= null;
	this.onAfterMoveRight		= null;
	this.onAfterMoveLeft		= null;
	this.onBeforeMoveAllRight	= null;
	this.onBeforeMoveAllLeft	= null;
	this.onAfterMoveAllRight	= null;
	this.onAfterMoveAllLeft		= null;

// methods
	this.initialise				= lp_Initialise;

	this.moveLeft				= lp_MoveLeft;
	this.moveRight				= lp_MoveRight;
	this.allMoveLeft			= lp_AllMoveLeft;
	this.allMoveRight			= lp_AllMoveRight;
	this.moveUp					= lp_MoveUp;
	this.moveDown				= lp_MoveDown;
	this.swapRowsInGrid			= lp_SwapRowsInGrid;

	this.setButtonStates		= lp_SetButtonStates;
	this.disableButton			= lp_DisableButton;
	this.showButton				= lp_ShowButton;
	this.hideButton				= lp_HideButton;
	this.enableButton			= lp_EnableButton;
	this.isDirty				= lp_IsDirty;
	this.setAsNotDirty		= lp_SetAsNotDirty;
	
	this.selectAllRows			= lp_SelectAllRows;
	this.hide					= lp_hide;
	this.show					= lp_show;
	this.toXML					= lp_toXML;
	this.performADAPTScript		= lp_performADAPTScript;
}

/** 
 * Used by ADAPT - returns a tree formatted xml representation of this object.
 *
 * @return The tree formatted xml representation of this object.
 */
function lp_toXML()
{
	var strUID = this.id.replace("lp", "");
	
	var strXML = "<node uid='" + strUID + "' level='3'>";
	strXML += "<vals>";
	strXML += "<val id='label'>" + strUID + "</val>";
	strXML += "<val id='name'>" + strUID + "</val>";
	strXML += "<val id='event1' parameter-name='objListPicker'>onBeforeMoveLeft</val>";
	strXML += "<val id='event2' parameter-name='objListPicker'>onAfterMoveLeft</val>";
	strXML += "<val id='event3' parameter-name='objListPicker'>onBeforeMoveRight</val>";
	strXML += "<val id='event4' parameter-name='objListPicker'>onAfterMoveRight</val>";
	strXML += "<val id='event5' parameter-name='objListPicker'>onBeforeMoveAllLeft</val>";
	strXML += "<val id='event6' parameter-name='objListPicker'>onAfterMoveAllLeft</val>";
	strXML += "<val id='event7' parameter-name='objListPicker'>onBeforeMoveAllRight</val>";
	strXML += "<val id='event8' parameter-name='objListPicker'>onAfterMoveAllRight</val>";
	strXML += "</vals>";
	strXML += "</node>";

	return strXML;
}

function lp_Initialise(flgSourceOnly)
{
	this.sourceGrid.onRowDblClick = this.id.replace("lp", "") + ".moveLeft()";
	this.sourceGrid.onRowSelect = this.id.replace("lp", "") + ".setButtonStates()";
	this.destinationGrid.onRowDblClick = this.id.replace("lp", "") + ".moveRight()";
	this.destinationGrid.onRowSelect = this.id.replace("lp", "") + ".setButtonStates()";

	this.flgIsDirty = false;

	this.sourceQuery = eval(this.sourceQuery);
	this.destinationQuery = eval(this.destinationQuery);

	this.sourceQuery.dataEngine.standardTransform = false;
	this.sourceQuery.search(false);
	
	if (!flgSourceOnly == true)
	{
		this.destinationQuery.dataEngine.standardTransform = false;
		this.destinationQuery.search(false);
	}

	this.setButtonStates();
}

function lp_MoveLeft() 
{
	var retVal = this.performADAPTScript(ADAPT_ONBEFOREMOVELEFT);
	if (retVal == false)
		return;

	if (!isBlank(this.onBeforeMoveLeft))
	{
		if (eval(this.onBeforeMoveLeft) == false)
			return;
	}
	
	this.swapRowsInGrid(this.sourceGrid, this.destinationGrid);
	this.flgIsDirty = true;
	
	if (!isBlank(this.onAfterMoveLeft))
		eval(this.onAfterMoveLeft);

	this.performADAPTScript(ADAPT_ONAFTERMOVELEFT);
}

function lp_MoveRight() 
{
	var retVal = this.performADAPTScript(ADAPT_ONBEFOREMOVERIGHT);
	if (retVal == false)
		return;
	
	if (!isBlank(this.onBeforeMoveRight))
	{
		if (eval(this.onBeforeMoveRight) == false)
			return;
	}
	
	this.swapRowsInGrid(this.destinationGrid, this.sourceGrid);
	this.flgIsDirty = true;
	
	if (!isBlank(this.onAfterMoveRight))
		eval(this.onAfterMoveRight);

	this.performADAPTScript(ADAPT_ONAFTERMOVERIGHT);
}

function lp_AllMoveLeft() 
{
	var retVal = this.performADAPTScript(ADAPT_ONBEFOREMOVEALLLEFT);
	if (retVal == false)
		return;

	if (!isBlank(this.onBeforeMoveAllLeft))
	{
		if (eval(this.onBeforeMoveAllLeft) == false)
			return;
	}

	this.swapRowsInGrid(this.sourceGrid, this.destinationGrid, this.sourceGrid.getColumnValues("uniqueid"));
	this.flgIsDirty = true;
	
	if (!isBlank(this.onAfterMoveAllLeft))
		eval(this.onAfterMoveAllLeft);

	this.performADAPTScript(ADAPT_ONAFTERMOVEALLLEFT);
}

function lp_AllMoveRight() 
{
	var retVal = this.performADAPTScript(ADAPT_ONBEFOREMOVEALLRIGHT);
	if (retVal == false)
		return;

	if (!isBlank(this.onBeforeMoveAllRight))
	{
		if (eval(this.onBeforeMoveAllRight) == false)
			return;
	}	

	this.swapRowsInGrid(this.destinationGrid, this.sourceGrid, this.destinationGrid.getColumnValues("uniqueid"));
	this.flgIsDirty = true;
	
	if (!isBlank(this.onAfterMoveAllRight))
		eval(this.onAfterMoveAllRight);
	
	this.performADAPTScript(ADAPT_ONAFTERMOVEALLRIGHT)
}

function lp_SwapRowsInGrid(objSourceGrid, objDestinationGrid, arrUniqueIds)
{
	if (arrUniqueIds == null)
		arrUniqueIds = objSourceGrid.getSelectedColumnValue("uniqueid");
	
	var intNewIndex = objSourceGrid.getRowIndex(arrUniqueIds[0]);
	var intMaxUID = objDestinationGrid.getMaxUniqueID() + 1;

	for (var intCtr = 0 ; intCtr < arrUniqueIds.length; intCtr++)
	{
		var intFromIndex = objSourceGrid.getRowIndex(arrUniqueIds[intCtr]);

		var objTmpRow = objDestinationGrid.HTMLtable.tBodies[0].insertRow(-1);
		var objFromRow = objSourceGrid.HTMLtable.tBodies[0].rows[intFromIndex];

		objTmpRow.swapNode(objFromRow);
		objSourceGrid.HTMLtable.tBodies[0].deleteRow(intFromIndex);

		objFromRow.id = "et_grd" + objDestinationGrid.id + "_uniqueTRid" + intMaxUID;
		objFromRow.removeAttribute("style");
		objFromRow.removeAttribute("selected");
		objFromRow.childNodes(0).removeAttribute("id");
		objFromRow.childNodes(0).innerHTML = intMaxUID++;
	}

	this.setButtonStates();

	if (objSourceGrid.HTMLtable.tBodies[0].rows[intNewIndex] != null)
		objSourceGrid.selectRow(objSourceGrid.HTMLtable.tBodies[0].rows[intNewIndex].cells[0].innerHTML);
	else if (intNewIndex > 0 && objSourceGrid.HTMLtable.tBodies[0].rows[intNewIndex - 1] != null)
		objSourceGrid.selectRow(objSourceGrid.HTMLtable.tBodies[0].rows[intNewIndex - 1].cells[0].innerHTML);

	var strUID = objDestinationGrid.HTMLtable.tBodies[0].rows[objDestinationGrid.getRowCount() - 1].cells[0].innerHTML;
	objDestinationGrid.selectRow(strUID);	
}

function lp_SetButtonStates()
{
	// Source grid - if no rows in source grid then disable move all left button.
	if (this.sourceGrid.getRowCount() == 0)
		this.disableButton("AllMoveLeft");
	else
		this.enableButton("AllMoveLeft");

	// Source grid - if no rows currently highlighted then disable move left button.
	if (this.sourceGrid.getSelectedColumnValue("uniqueid").length > 0)
		this.enableButton("MoveLeft");
	else
		this.disableButton("MoveLeft");
	
	// Destination grid - if no rows in destination grid then disable move all right button.
	if (this.destinationGrid.getRowCount() == 0)
		this.disableButton("AllMoveRight");
	else
		this.enableButton("AllMoveRight");

	// Destination grid - if no rows currently highlighted then disable move right button.
	intUniqueId = this.destinationGrid.getSelectedColumnValue("uniqueid")[0];

	if (intUniqueId != null)
	{
		this.enableButton("MoveRight");

		var intRowIndex = this.destinationGrid.getRowIndex(intUniqueId);

		if (intRowIndex == 0)
			this.disableButton("MoveUp");
		else
			this.enableButton("MoveUp");

		if (intRowIndex == this.destinationGrid.getRowCount() - 1)
			this.disableButton("MoveDown");
		else
			this.enableButton("MoveDown");
	}
	else
	{
		this.disableButton("MoveRight");
		this.disableButton("MoveUp");
		this.disableButton("MoveDown");
	}
}

/**
 * Disables the list-picker button specified by 'strDirection'.
 *
 * @param strDirection - the button to disable.
 */
function lp_DisableButton(strDirection)
{
	var btn = window.document.getElementById("btn" + strDirection + "_" + this.id.replace("lp", ""));

	if (btn != null && btn.disabled == false)
	{
        btn.style.filter="progid:DXImageTransform.Microsoft.AlphaImageLoader(src='../PNG/pngLP" + strDirection + "_disabled.png', sizingmethod='scale')";
        btn.style.cursor = "default";
		btn.disabled = true;
	}
}

/**
 * Enables the list-picker button specified by 'strDirection'.
 *
 * @param strDirection - the button to enable.
 */
function lp_EnableButton(strDirection)
{
	var btn = window.document.getElementById("btn" + strDirection + "_" + this.id.replace("lp", ""));

	if (btn != null && btn.disabled == true)
	{
        btn.style.filter="progid:DXImageTransform.Microsoft.AlphaImageLoader(src='../PNG/pngLP" + strDirection + ".png', sizingmethod='scale')";
        btn.style.cursor = "hand";
		btn.disabled = false;
	}
}

/**
 * Hide a button
 * @param strDirection The name of the button
 */
function lp_HideButton(strDirection)
{
	var objBtn = window.document.getElementById("btn" + strDirection + "_" + this.id.replace("lp", ""));
	
	if (objBtn != null)
		objBtn.style.display = "none";
}

/**
 * Show a button
 * @param strDirection The name of the button
 */
function lp_ShowButton(strDirection)
{
	var objBtn = window.document.getElementById("btn" + strDirection + "_" + this.id.replace("lp", ""));

	if (objBtn != null)
		objBtn.style.display = "inline";
}

function lp_MoveUp()
{
	var intUniqueId = parseInt(this.destinationGrid.getSelectedColumnValue("uniqueid")[0]);
	var intSwapIndex = this.destinationGrid.getRowIndex(intUniqueId);

	this.destinationGrid.swapRows(intSwapIndex, intSwapIndex - 1);

	this.setButtonStates();
	
	if (!isBlank(this.onMoveUp))
		eval(this.onMoveUp);
}

function lp_MoveDown()
{
	var intUniqueId = parseInt(this.destinationGrid.getSelectedColumnValue("uniqueid")[0]);
	var intSwapIndex = this.destinationGrid.getRowIndex(intUniqueId);

	this.destinationGrid.swapRows(intSwapIndex, intSwapIndex + 1);

	this.setButtonStates();
	
	if (!isBlank(this.onMoveDown))
		eval(this.onMoveDown);
}

function lp_SelectAllRows(arrParams) {
	var objGrid = arrParams[0];
	objGrid.selectAllRows();
}

function lp_IsDirty() {
	return this.flgIsDirty;
}

function lp_SetAsNotDirty() {
	this.flgIsDirty = false;
}

function lp_hide()
{
	this.HTMLElement.style.display = "none";
}

function lp_show()
{
	this.HTMLElement.style.display = "inline";
}

/** 
 * Fires any attached ADAPT javascript.
 *
 * @param flgEventType Binary operator parameter determines which event to fire.
 * @return Returns false if the adapt javascript decided to cancel the event.
 */
function lp_performADAPTScript(flgEventType)
{
	var strMethodName;
	var strId = this.id.replace("lp", "");

	if (flgEventType == ADAPT_ONBEFOREMOVELEFT) {
		strMethodName = strId + "_onBeforeMoveLeft";
	} else if (flgEventType == ADAPT_ONAFTERMOVELEFT) {
		strMethodName = strId + "_onAfterMoveLeft";
	} else if (flgEventType == ADAPT_ONBEFOREMOVERIGHT) {
		strMethodName = strId + "_onBeforeMoveRight";
	} else if (flgEventType == ADAPT_ONAFTERMOVERIGHT) {
		strMethodName = strId + "_onAfterMoveRight";
	} else if (flgEventType == ADAPT_ONBEFOREMOVEALLLEFT) {
		strMethodName = strId + "_onBeforeMoveAllLeft";
	} else if (flgEventType == ADAPT_ONAFTERMOVEALLLEFT) {
		strMethodName = strId + "_onAfterMoveAllLeft";
	} else if (flgEventType == ADAPT_ONBEFOREMOVEALLRIGHT) {
		strMethodName = strId + "_onBeforeMoveAllRight";
	} else if (flgEventType == ADAPT_ONAFTERMOVEALLRIGHT) {
		strMethodName = strId + "_onAfterMoveAllRight";
	} else {
		alert("List picker event type not supported");
	}
	
	if (typeof(strMethodName) != "undefined" && this.objAppWindow[strMethodName] != null) {
		if (this.objAppWindow[strMethodName](this) == false) {
			return false;
		}
	}
	
	return true;
}



//--------------------------------------------------------------------------------
// Main constructor for "MSDocument" object

function MSDocument(strXML)
{
	// Properties
	this.document				= new ActiveXObject("microsoft.xmldom");
	this.document.async			= false;
	this.document.resolveExternals = false;
	
	if (!isBlank(strXML))
		this.document.loadXML(strXML);
	
	// Methods
	this.appendChild			= MSDocument_appendChild;
	this.childNodes				= MSDocument_childNodes;
	this.cloneNode				= MSDocument_cloneNode;
	this.createElement			= MSDocument_createElement;
	this.documentElement		= MSDocument_documentElement;
	this.firstChild				= MSDocument_firstChild;
	this.getText				= MSDocument_getText;
	this.hasChildNodes			= MSDocument_hasChildNodes;
	this.insertBefore			= MSDocument_insertBefore;
	this.lastChild				= MSDocument_lastChild;
	this.load					= MSDocument_load;
	this.loadURL				= MSDocument_loadURL;
	this.getAttribute			= MSDocument_getAttribute;
	this.getFullURL				= MSDocument_getFullURL;
	this.loadXML				= MSDocument_loadXML;
	this.loadXMLWithUniqueIDs	= MSDocument_loadXMLWithUniqueIDs;
	this.nextSibling			= MSDocument_nextSibling;
	this.nodeName				= MSDocument_nodeName;
	this.nodeIndex				= MSDocument_nodeIndex;
	this.ownerDocument			= MSDocument_ownerDocument;
	this.parentNode				= MSDocument_parentNode;
	this.previousSibling		= MSDocument_previousSibling;
	this.removeAttribute		= MSDocument_removeAttribute;
	this.removeChild			= MSDocument_removeChild;
	this.replaceChild			= MSDocument_replaceChild;
	this.selectSingleNode		= MSDocument_selectSingleNode;
	this.selectNodes			= MSDocument_selectNodes;
	this.setAttribute			= MSDocument_setAttribute;
	this.setText				= MSDocument_setText;
	this.transformNode			= MSDocument_transformNode;
	this.transformNodeToObject	= MSDocument_transformNodeToObject;
	this.xml					= MSDocument_xml;
	this.save					= MSDocument_save;
}

function MSDocument_appendChild(newChild)
{
	return new MSNode(this.document.documentElement.appendChild(newChild.node), this);
}
	
function MSDocument_childNodes()
{
	return new MSNodeList(this.document.documentElement.childNodes, this);
}

function MSDocument_cloneNode(flgDeep)
{
	if (flgDeep == null)
		flgDeep = true;

	return new MSNode(this.document.documentElement.cloneNode(flgDeep), this);
}

function MSDocument_createElement(name)
{
	var newelem = this.document.createElement(name);
	return new MSNode(newelem, this);
}

function MSDocument_documentElement()
{
	if (this.document.xml == "")
		return;

	return new MSNode(this.document.documentElement, this);
}

function MSDocument_firstChild()
{
	if (this.document.documentElement.firstChild == null)
		return;

	return new MSNode(this.document.documentElement.firstChild, this);
}

function MSDocument_getAttribute(name)
{
	return this.document.documentElement.getAttribute(name);
}

function MSDocument_getText()
{
	return this.document.documentElement.text;
}

function MSDocument_hasChildNodes()
{
	return this.document.documentElement.hasChildNodes();
}

function MSDocument_insertBefore(newChild, refNode)
{
	return new MSNode(this.document.documentElement.insertBefore(newChild.node, refNode.node), this);
}

function MSDocument_lastChild()
{
	return new MSNode(this.document.documentElement.lastChild, this);
}

function MSDocument_load(strLoadPath)
{
	return this.document.load(strLoadPath);
}

function MSDocument_loadURL(strURL, baseURL)
{
	var strFullURL;
	
	if (baseURL != null)
		strFullURL = this.getFullURL(strURL, baseURL)
	else
		strFullURL = strURL;

	return this.document.load(strFullURL);
}

function MSDocument_getFullURL(relativeURL, baseURL) {

    // Strip to '?'
    // baseURLIndex is the last character we will use from the base URL
    var baseURLIndex = baseURL.lastIndexOf('?');
    if (baseURLIndex == -1)
        baseURLIndex = baseURL.length;
    
    var baseURLSeparatorIndex = baseURL.lastIndexOf('/', baseURLIndex);
    if (baseURLSeparatorIndex != -1) {
        baseURLIndex = baseURLSeparatorIndex;
    }
    
    // Index is how far we have got through the relative URL
    var index = 0;
    // nextSeparatorIndex is the position of the next '/'
    var nextSeparatorIndex;
    
    // Loop through the relative URL by the separator '/'
    // for each ".." element move
    while((nextSeparatorIndex = relativeURL.indexOf('/', index)) != -1) {
        // Now strip this element from the URL
        var urlPart = relativeURL.substring(index, nextSeparatorIndex);

        // if this element is ".." strip 1 part from the base URL
        // if this element is "." just remove
        // in all other cases we will finish.
        if (urlPart == "..") {
            baseURLIndex = baseURL.lastIndexOf('/', baseURLIndex - 1);
            index = nextSeparatorIndex + 1;
        } else if (urlPart == ".") {
            index = nextSeparatorIndex;
        } else {
            break;
        }
    }
    
    return baseURL.substring(0, baseURLIndex) + "/" + relativeURL.substring(index);
}

function MSDocument_loadXML(strXML)
{
	return this.document.loadXML(strXML);
}

function MSDocument_loadXMLWithUniqueIDs(strXML, uniqueid)
{
	this.document.loadXML(strXML);

	var objNodes = this.document.selectNodes("//*[@etype='item' and not(@uniqueid)]");
	for (var objNode = objNodes.nextNode; objNode != null; objNode = objNodes.nextNode)
		objNode.setAttribute("uniqueid", ++uniqueid)

	return uniqueid;
}

function MSDocument_nextSibling()
{
	return;
}

function MSDocument_nodeIndex()
{
	return 0;
}

function MSDocument_nodeName()
{
	return this.document.documentElement.nodeName;
}

function MSDocument_ownerDocument()
{
	return this;
}

function MSDocument_parentNode()
{
	return null;
}

function MSDocument_previousSibling()
{
	return null;
}

function MSDocument_removeAttribute(name)
{
	this.document.documentElement.removeAttribute(name);
}

function MSDocument_removeChild(childNode)
{
	this.document.documentElement.removeChild(childNode.node);
}

function MSDocument_replaceChild(newChild, oldChild)
{
	return new MSNode(this.document.documentElement.replaceChild(newChild, oldChild), this);
}

function MSDocument_save(path)
{
	var retval = false;
	
	try {
		this.document.save(path);
		retval = true;
	} catch(error) {
		eMsgBox(fl("CANNOTSAVEDOM", path), 0, msg_Critical, window);
	}
	return retval;
}

function MSDocument_selectSingleNode(strPath)
{
	if (this.document.xml == "")
		return;

	while (strPath.indexOf("name()") != -1)
		strPath = strPath.replace("name()", "nodeName()");

	var objNode = this.document.documentElement.selectSingleNode(strPath);

	if (objNode == null)
		return null;

	return new MSNode(objNode, this);
}

function MSDocument_selectNodes(strPath)
{
	if (this.document.xml == "")
		return new MSNodeList(this.document.selectNodes(strPath), this);
	else
	{
		while (strPath.indexOf("name()") != -1)
			strPath = strPath.replace("name()", "nodeName()");

		return new MSNodeList(this.document.documentElement.selectNodes(strPath), this);
	}
}

function MSDocument_setAttribute(name, value)
{
	this.document.documentElement.setAttribute(name, value);
}

function MSDocument_setText(newText)
{
	return this.document.documentElement.text = newText;
}

function MSDocument_transformNode(stylesheet)
{
	return this.document.documentElement.transformNode(stylesheet.document);
}

function MSDocument_transformNodeToObject(stylesheet)
{
	return new MSDocument(this.document.documentElement.transformNode(stylesheet.document));
}

function MSDocument_xml()
{
	return this.document.xml;
}

 

//--------------------------------------------------------------------------------
// Main constructor for "MSNode" object

function MSNode(objNode, objDoc)
{
	// Properties
	this.node					= objNode;
	this.MSDocument				= objDoc;

	// Methods
	this.appendChild			= MSNode_appendChild;
	this.childNodes				= MSNode_childNodes;
	this.cloneNode				= MSNode_cloneNode;
	this.firstChild				= MSNode_firstChild;
	this.getAttribute			= MSNode_getAttribute;
	this.getText				= MSNode_getText;
	this.hasChildNodes			= MSNode_hasChildNodes;
	this.insertBefore			= MSNode_insertBefore;
	this.lastChild				= MSNode_lastChild;
	this.nextSibling			= MSNode_nextSibling;
	this.nodeIndex				= MSNode_nodeIndex;
	this.nodeName				= MSNode_nodeName;
	this.ownerDocument			= MSNode_ownerDocument;
	this.parentNode				= MSNode_parentNode;
	this.previousSibling		= MSNode_previousSibling;
	this.removeAttribute		= MSNode_removeAttribute;
	this.removeChild			= MSNode_removeChild;
	this.replaceChild			= MSNode_replaceChild;
	this.selectSingleNode		= MSNode_selectSingleNode;
	this.selectNodes			= MSNode_selectNodes;
	this.setAttribute			= MSNode_setAttribute;
	this.setText				= MSNode_setText;
	this.setCDATAText			= MSNode_setCDATAText;
	this.transformNode			= MSNode_transformNode;
	this.transformNodeToObject	= MSNode_transformNodeToObject;
	this.xml					= MSNode_xml;
}

function MSNode_appendChild(newChild)
{
	if (newChild.node != null)
		return new MSNode(this.node.appendChild(newChild.node), this.MSDocument);
	else
		return new MSNode(this.node.appendChild(newChild.document.documentElement), this.MSDocument);
		
}

function MSNode_childNodes()
{
	return new MSNodeList(this.node.childNodes, this.MSDocument);
}

function MSNode_cloneNode(flgDeep)
{
	if (flgDeep == null)
		flgDeep = true;

	return new MSNode(this.node.cloneNode(flgDeep));
}

function MSNode_firstChild()
{
	if (this.node.firstChild == null)
		return;

	return new MSNode(this.node.firstChild, this.MSDocument);
}

function MSNode_getAttribute(name)
{
	return this.node.getAttribute(name);
}

function MSNode_getText()
{
	if (this.node == null)
		return null;

	return this.node.text;
}

function MSNode_hasChildNodes()
{
	return this.node.hasChildNodes();
}

function MSNode_insertBefore(newChild, refNode)
{
	return new MSNode(this.node.insertBefore(newChild.node, refNode.node), this.MSDocument);
}

function MSNode_lastChild()
{
	if (this.node.lastChild == null)
		return;

	return new MSNode(this.node.lastChild, this.MSDocument);
}

function MSNode_nextSibling()
{
	if (this.node.nextSibling == null)
		return;

	return new MSNode(this.node.nextSibling, this.MSDocument);
}

function MSNode_nodeIndex()
{
	var objParentNode = this.node.parentNode;
	var objNodes = objParentNode.childNodes;
	var intCtr = -1;
	
	for (var objNode = objNodes.nextNode; objNode != null; objNode = objNodes.nextNode)
	{
		intCtr ++;

		if (this.node == objNode)
			break;
	}
	return intCtr;
}

function MSNode_nodeName()
{
	return this.node.nodeName;
}

function MSNode_ownerDocument()
{
	return this.MSDocument;
}

function MSNode_parentNode()
{
	return new MSNode(this.node.parentNode, this.MSDocument);
}

function MSNode_previousSibling()
{
	if (this.node.previousSibling == null)
		return;

	return new MSNode(this.node.previousSibling, this.MSDocument);
}

function MSNode_removeAttribute(name)
{
	this.node.removeAttribute(name);
}

function MSNode_removeChild(childNode)
{
	this.node.removeChild(childNode.node);
}

function MSNode_replaceChild(newChild, oldChild)
{
	return new MSNode(this.node.replaceChild(newChild.node, oldChild.node), this.MSDocument);
}

function MSNode_selectSingleNode(strPath)
{
	while (strPath.indexOf("name()") != -1)
		strPath = strPath.replace("name()", "nodeName()");

	var objNode = this.node.selectSingleNode(strPath);
	
	if (objNode == null)
		return null;

	return new MSNode(objNode, this.MSDocument);
}

function MSNode_selectNodes(strPath)
{
	while (strPath.indexOf("name()") != -1)
		strPath = strPath.replace("name()", "nodeName()");

	return new MSNodeList(this.node.selectNodes(strPath), this.MSDocument);
}

function MSNode_setAttribute(name, value)
{
	this.node.setAttribute(name, value);
}

function MSNode_setText(newText)
{
	if (newText == null)
	{
		this.node.text = "";
		return null;
	}
	else
		// in case the input is a number. The Node tends to force the data
		// into a locale format if it detects the type of the data as numeric.
		return this.node.text = String (newText);
}

/**
 * Sets a CDATA section on the current node.
 *
 * @param newText The text to be contained within the CDATA section.
 */
function MSNode_setCDATAText(newText)
{
	if (newText == null)
	{
		this.node.text = "";
		return null;
	}
	else
	{
		var objCDATASection = this.MSDocument.document.createCDATASection(String (newText));
		this.node.appendChild(objCDATASection);
		return newText;
	}
}

function MSNode_transformNode(stylesheet)
{
	return this.node.transformNode(stylesheet.document);
}

function MSNode_transformNodeToObject(stylesheet)
{
	return new MSDocument(this.node.transformNode(stylesheet.document));
}

function MSNode_xml()
{
	return this.node.xml;
}

 

//--------------------------------------------------------------------------------
// Main constructor for "MSNodeList" object

function MSNodeList(objNodeList, objDoc)
{
	// Properties
	this.nodelist				= objNodeList;
	this.MSDocument				= objDoc;
	this.currentelement			= -1;
	
	// Methods
	this.item					= MSNodeList_item;
	this.length					= MSNodeList_length;
	this.nextNode				= MSNodeList_nextNode;
	this.previousNode			= MSNodeList_previousNode;
	this.reset					= MSNodeList_reset;

}

function MSNodeList_item(itemNumber)
{
	if (this.nodelist(itemNumber) == null)
		return;
	else
		return new MSNode(this.nodelist(itemNumber), this.MSDocument);
}

function MSNodeList_length()
{
	if (this.nodelist == null)
		return 0;

	return this.nodelist.length;
}

function MSNodeList_nextNode()
{
	if (this.nodelist.length == 0)
		return null;

	if (this.currentelement < this.nodelist.length - 1)
		this.currentelement ++;
	else
		return null;
	
	return new MSNode(this.nodelist(this.currentelement), this.MSDocument);
}

function MSNodeList_previousNode()
{
	if (this.currentelement > 0)
		this.currentelement --;
	else
		return null;
	
	return new MSNode(this.nodelist(this.currentelement), this.MSDocument);
}

function MSNodeList_reset()
{
	this.currentelement = -1;
}

 
	

// Message Button Constants

var BUTTON_MASK = 0xF;
var vbOKOnly = 0x0;
var vbOK = 0x0;
var vbOKCancel = 0x1;
var vbCancel = 0x2;
var vbAbortRetryIgnore = 0x2;
var vbYesNoCancel = 0x3;
var vbYesNo = 0x4;
var vbRetryCancel = 0x5;
var vbYes = 0x6;
var vbNo = 0x7;
var vbAllYesNoCancel = 0x8;
var vbAll = 0x9;
var vbNoButtons = 0xA;
// Message Icon Constants

var msg_None = 0;
var msg_Critical = 1;
var msg_Question = 2;
var msg_Exclamation = 3;
var msg_Information = 4;

/** 
 * Constructor for the Message object
 *
 * @param	messageID		The message identifier
 *			objAppWindow	The window object
 */
function Message(messageID, objAppWindow)
{
	this.show					= Message_show;
	this.setWindow				= Message_setWindow;
	this.setText				= Message_setText;
	this.setType				= Message_setType;
	this.setButtons				= Message_setButtons;
	this.setLocation			= Message_setLocation;
	this.setParameters			= Message_setParameters;
	this.addButton				= Message_addButton;
	
	this.id 					= messageID;
	this.AppWindow				= objAppWindow;
	this.messageText			= "";
	this.messageButtons			= vbOK;
	this.messageType			= msg_None;
	this.messageLocation		= "";
	this.messageTitle			= "";
	this.parameters				= null;
	this.buttonHTML				= Message_addButtons(this.messageButtons);
	this.iconHTML				= "";
	this.messageHTML			= "";
	this.destroy				= Message_destroy;
}

/** 
 * Displays the message
 *
 * @return	message return value
 */
function Message_show()
{
	var featureError = false;
	var strMessageText = "";

	if (this.parameters != null)
	{
		var strMessage = "this.AppWindow.fl(this.messageText";
		
		for (var i=0; i<this.parameters.length; i++)
		{
			strMessage += ", '";
			strMessage += this.parameters[i] + "'";
		}
		
		strMessage += ")";
			
		strMessageText = eval(strMessage);
	}
	else
		strMessageText = this.AppWindow.fl(this.messageText);

	this.messageHTML = "<table><tr>" + Message_formatMessage(strMessageText) + "</tr></table>";

	if (this.messageType == msg_Exclamation || this.messageType == msg_Critical)
		objApplication.EfacsApplet.beep();

	if (this.messageLocation != "")
		return Message_displayMessageFromLocation(this.id, this.messageLocation, this.AppWindow, true);
	else
	{
		if (strMessageText.indexOf("[INVALIDFEATURE]") != -1) 
		{
			this.messageHTML = "<table><tr>" + Message_formatMessage(fl("INVALIDFEATURE")) + "</tr></table>";
			featureError = true;
		}

		var retVal = Message_displayMessageFromLocation(this.id, "../Messages_HTML/msgGeneric.html", this.AppWindow);

		if (featureError) 
		{
			objApplication.hadCriticalError = true;
			objApplication.closeApplication();
		}

		return retVal;
	}
}

/** 
 * Sets the window where the message will be displayed
 *
 * @param	objWindow	current window
 */
function Message_setWindow(objWindow)
{
	this.AppWindow = objWindow;
}

/** 
 * Sets the message text
 *
 * @param	strMessageText	message text
 */
function Message_setText(strMessageText)
{
	this.messageText = strMessageText;
}

/** 
 * Sets the message buttons
 *
 * @param	intMessageButtons	message buttons
 */
function Message_setButtons(intMessageButtons)
{
	this.messageButtons = intMessageButtons;
	this.buttonHTML = Message_addButtons(intMessageButtons);
}

/** 
 * Sets the message type
 *
 * @param	intMessageType	message type
 */
function Message_setType(intMessageType)
{
	this.messageType = intMessageType;	
	this.iconHTML = Message_displayIcon(intMessageType);
	this.messageTitle = Message_determineTitle(intMessageType);
}

/** 
 * Sets the location of the message template.  This template could
 * contain a more detailed content for the message
 *
 * @param	strMessageLocation	url to the message template
 */
function Message_setLocation(strMessageLocation)
{
	this.messageLocation = strMessageLocation;	
}

/** 
 * Sets the parameters that are to be included in the message.
 */
function Message_setParameters()
{
	var arrParameters = new Array();
	
	for (var i=0; i<arguments.length; i++)
		arrParameters[i] = arguments[i];
	
	this.parameters = arrParameters;	
}

/** 
 * Displays the message using the specified message template
 *
 * @param	messageID			message identifier
 *			strURL				url of the message template
 *			objAppWindow		current window
 *			bUsePersistedSize	whether to use the default message window size or a persisted size
 *
 * @return	message return value
 */
function Message_displayMessageFromLocation(messageID, strURL, objAppWindow, bUsePersistedSize)
{
	var strSize;

	strURL = strURL + "?messageid=" + messageID;

	if (bUsePersistedSize)
		strSize = null;
	else
		strSize = "dialogWidth=400px; dialogHeight=160px;";
		
	return objApplication.openModalWindow(objAppWindow, strURL, null, true, strSize);
}

/** 
 * Formats the message content
 *
 * @param	strText		message text
 *
 * @return	formatted message content
 */
function Message_formatMessage(strText)
{
	var intPosStTr;
	var strTemp;
	var strReturn;
		
	intPosStTr = strText.indexOf("[STACKTRACE]");

	if (intPosStTr < 0)
	{
		strReturn = "<td id='Message' class='DialogMessage' >" + strText + "<p/><p/></td></tr></table>";
	}
	else
	{
		strTemp = "<td id='Message'><table><tr><td id='MessageTop' class='DialogMessage'>" + strText.substring(0,intPosStTr - 6) +  "</td></tr>";
		strTemp = strTemp + "<tr><td id='StackTrace' class='SearchLink'>[STACKTRACE]</td></tr>";
		strTemp = strTemp + "<tr><td id='MessageBottom' class='DialogMessage'><span>" + strText.substring(intPosStTr + 12) +  "<p/><p/></td></tr></table></td></tr></table>";
		strReturn = strTemp;
	}

	return strReturn;
}

/** 
 * Determines which message icon to display based on the message type
 *
 * @param	lngType		message type
 *
 * @return	icon html
 */
function Message_displayIcon(lngType)
{
	var strImagePath;

	switch(Number(lngType)) 
	{
		case msg_Critical:
			strImagePath = "../GIF/gifCritical.gif";
			break;
			
		case msg_Question:
			strImagePath = "../GIF/gifQuestion.gif";
			break;

		case msg_Exclamation:
			strImagePath = "../GIF/gifExclamation.gif";
			break;

		case msg_Information:
			strImagePath = "../GIF/gifInformation.gif";
			break;

		default:
			strImagePath = "../GIF/gifEmptyIcon.gif";
			break;
	}
        
	if (String(strImagePath.length) > 0)
		return "<IMG ID='imgIcon' SRC='" + strImagePath + "' CLEAR='left'></IMG>";
    
    return "";
}
   
/** 
 * Determines which buttons should be displayed
 *
 * @param	lngButtons		message buttons
 *
 * @return	buttons html
 */
function Message_addButtons(lngButtons) 
{
	var strButtons = "";

	switch (lngButtons & BUTTON_MASK) 
	{
		case vbOKOnly, vbOK:
			strButtons = strButtons + Message_addButton(fl("OK"), "0", "Ok");
			objApplication.dialogReturnValue = vbOK;
			break;
			
		case vbOKCancel:
			strButtons = strButtons + Message_addButton(fl("OK"), "0", "Ok");
			strButtons = strButtons + Message_addButton(fl("CANCEL"), "2", "Cancel");
			objApplication.dialogReturnValue = vbCancel;
			break;
			
		case vbAbortRetryIgnore:
			strButtons = strButtons + Message_addButton(fl("ABORT"), "3");
			strButtons = strButtons + Message_addButton(fl("RETRY"), "4");
			strButtons = strButtons + Message_addButton(fl("IGNORE"), "5");
			objApplication.dialogReturnValue = 5;
			break;
			
		case vbAllYesNoCancel:
			strButtons = strButtons + Message_addButton(fl("YESTOALL"), "9");
			strButtons = strButtons + Message_addButton(fl("YES"), "6");
			strButtons = strButtons + Message_addButton(fl("NO"), "7");
			strButtons = strButtons + Message_addButton(fl("CANCEL"), "2", "Cancel");
			objApplication.dialogReturnValue = vbCancel;
			break;
			
		case vbYesNoCancel:
			strButtons = strButtons + Message_addButton(fl("YES"), "6");
			strButtons = strButtons + Message_addButton(fl("NO"), "7");
			strButtons = strButtons + Message_addButton(fl("CANCEL"), "2", "Cancel");
			objApplication.dialogReturnValue = vbCancel;
			break;
			
		case vbYesNo:
			strButtons = strButtons + Message_addButton(fl("YES"), "6");
			strButtons = strButtons + Message_addButton(fl("NO"), "7");
			objApplication.dialogReturnValue = vbNo;
			break;
			
		case vbRetryCancel:
			strButtons = strButtons + Message_addButton(fl("RETRY"), "4");
			strButtons = strButtons + Message_addButton(fl("CANCEL"), "2", "Cancel");
			objApplication.dialogReturnValue = vbCancel;
			break;
		
		case vbNoButtons:
			//No standard buttons, buttons added via application.
			break;
	}
    
	return strButtons;
}
    
/** 
 * Builds the button html
 *
 * @param	strCaption			button caption
 *			strValueToReturn	message return value
 *			strButtonImage		button image
 *          strWidth            button width
 *			@return				button html
 */
function Message_addButton(strCaption, strValueToReturn, strButtonImage, strWidth) 
{
	strCaption = String(strCaption);
	strValueToReturn = String(strValueToReturn);

	var strHTML = "<button type='button' onmouseover='ButtonMouseOver(this)' onmouseout='ButtonMouseOut(this)' ";
	strHTML += "id='cmd" + strCaption + "' ";
	strHTML += "class='button ScreenButton' language='javascript' ";
	strHTML += "onclick='Message_buttonClick(" + strValueToReturn + ")' ";
	
	if (strWidth)
		strHTML += " style='width:" + strWidth + "px;";
	else
		strHTML += " style='width:60px;";
	
	if (strButtonImage != null){
		strHTML += "background-image: url(../GIF/gif" + strButtonImage + ".gif);";
		strHTML += "padding-left:18px;padding-right:0px;text-indent:0px;";
	}else
		strHTML += "text-align=center;padding-left:0px;padding-right:0px;text-indent:0px;";
		
	strHTML += "'>" + strCaption + "</button>";
	
	return strHTML;
}

/**
 * Performs required actions on button click 
 * @param  retval  The value returned from the message box
 */
function Message_buttonClick(retval) {
	objApplication.dialogReturnValue = retval;
	if (typeof(window_onmessagebuttonclick) != "undefined")
	{
		if (window_onmessagebuttonclick(retval) == "false")
			return;
	}
	window.close();
}

/** 
 * Determines the title for the message based on the message type
 *
 * @param	lngType		message type
 *
 * @return	message title
 */
function Message_determineTitle(lngType) 
{
	switch(Number(lngType))
	{
		case msg_Critical:
			return fl("ERROR");
		case msg_Question:
			return fl("QUESTION");
		case msg_Exclamation: 
			return fl("WARNING");
		case msg_Information:
			return fl("INFORMATION");
		default:
			return "";
	}
}

/**
 * Clear references to the message object
 */
function Message_destroy() {
	try {
		this.id = null;
		this.AppWindow = null;
		this.messageText = null;
		this.messageButtons = null;
		this.messageType = null;
		this.messageLocation = null;
		this.messageTitle = null;
		this.parameters = null;
		this.buttonHTML = null;
		this.iconHTML = null;
		this.messageHTML = null;
	} catch (error) {
	}
}




//--------------------------------------------------------------------------------
// Main constructor for "Module" object
// Passed argument is the module to check
function Module(strModuleID, isChecked)
{
	this.id = strModuleID;
	
	if (isChecked) {
		return;
	}

	hasModule(this);
}

function hasModule(objModule)
{
	var objLicence = new RPCObject("licence");

	try {
		var retVal = objLicence.execute("hasfeature", objApplication.Connection.strConnectionString, objModule.id);
	} catch(error) {
	}
	
	if (retVal == "true")
		objModule.value = true;
	else
		objModule.value = false;
}



function PersistentXML() 
{
	// Methods.
	this.getPersistentTag = PersistentXML_getPersistentTag;
	this.getPersistentData = PersistentXML_getPersistentData;
	this.setPersistentTag = PersistentXML_setPersistentTag;
	this.saveWindowSettings = PersistentXML_saveWindowSettings;
	this.getWindowSettings = PersistentXML_getWindowSettings;
	this.loadApplicationSettings = PersistentXML_loadApplicationSettings;
	this.saveApplicationSettings = PersistentXML_saveApplicationSettings;
	this.convertComponentID = PersistentXML_convertComponentID;

	// Properties.
	this.WindowAttributes = null;
	this.OriginalWindowAttributes = null;
	this.strPersistenceArea = null;
}

function PersistentXML_loadApplicationSettings(strAppName)
{
	var objRPC = new RPCObject("WindowAttribute");
	objRPC.execute("loadPersistedSettings", objApplication.Connection.strConnectionString, 
		strAppName, objApplication.User.userID, objApplication.User.language);

	var objRetVal = objRPC.getReturnedXMLDom();
	
	if (objRetVal != null)
	{
		var objApp = objRetVal.selectSingleNode("/windowattributes/windowattribute/xmlcode/value/*");
		
		if (objApp == null)
			objApp = objApplication.createXMLDocument("<application id='" + strAppName + "' />");
		
		var objOrigApp = objApp.cloneNode();

		if (this.WindowAttributes == null || this.WindowAttributes.selectSingleNode("/applications") == null)
		{
			this.WindowAttributes = objApplication.createXMLDocument("<applications>" + objApp.xml() + "</applications>");
			this.OriginalWindowAttributes = objApplication.createXMLDocument("<applications>" + objOrigApp.xml() + "</applications>");
		}
		else
		{
			var objNode = this.WindowAttributes.selectSingleNode("/applications/application[@id='" + strAppName + "']");

			if (objNode != null)
				this.WindowAttributes.selectSingleNode("/applications").removeChild(objNode);
		
			this.WindowAttributes.selectSingleNode("/applications").appendChild(objApp);

			var objOriginalNode = this.OriginalWindowAttributes.selectSingleNode("/applications/application[@id='" + strAppName + "']");

			if (objOriginalNode != null)
				this.OriginalWindowAttributes.selectSingleNode("/applications").removeChild(objOriginalNode);
		
			this.OriginalWindowAttributes.selectSingleNode("/applications").appendChild(objOrigApp);
		}
	}
}

function PersistentXML_getPersistentTag(strTag, strComponentID) 
{
	if (strComponentID != null)
	{
		var strAppName;

		if (this.strPersistenceArea != null)
			strAppName = this.strPersistenceArea;
		else
			strAppName = PersistentXML_convertComponentID(strComponentID);

		var bLoadSettings = true;
		
		if (this.WindowAttributes != null)
		{
			if (this.WindowAttributes.selectSingleNode("/applications/application[@id='" + strAppName + "']") != null)
				bLoadSettings = false;
		}
			
		if (bLoadSettings)
			this.loadApplicationSettings(strAppName);

		var objNode;
		
		if (this.WindowAttributes != null)
			objNode = this.WindowAttributes.selectSingleNode("/applications/application[@id='" + strAppName + "']/" + strTag);

		if (objNode != null)
			return objNode.getText();
	}
}

function PersistentXML_getPersistentData(strXPath, strComponentID) 
{
	if (strComponentID != null)
	{
		var strAppName;
		
		if (this.strPersistenceArea != null)
			strAppName = this.strPersistenceArea;
		else
			strAppName = PersistentXML_convertComponentID(strComponentID);

		var bLoadSettings = true;
		
		if (this.WindowAttributes != null)
		{
			if (this.WindowAttributes.selectSingleNode("/applications/application[@id='" + strAppName + "']") != null)
				bLoadSettings = false;
		}
			
		if (bLoadSettings)
			this.loadApplicationSettings(strAppName);
		
		var objNode;
		
		if (this.WindowAttributes != null)
			objNode = this.WindowAttributes.selectSingleNode("/applications/application[@id='" + strAppName + "']/" + strXPath);

		if (objNode != null)
			return objNode;
	}
}

function PersistentXML_setPersistentTag(strTag, strValue, strComponentID, strXPath) 
{
	if (strComponentID != null)
	{
		var strAppName;
		
		if (this.strPersistenceArea != null)
			strAppName = this.strPersistenceArea;
		else
			strAppName = PersistentXML_convertComponentID(strComponentID);

		var objWindowSettings = this.WindowAttributes;

		if (objWindowSettings != null) 
		{
			var strFullPath = "/applications/application[@id='" + strAppName + "']/";
			
			if (strXPath != null)
				strFullPath = strFullPath + strXPath + "/";
				
			strFullPath = strFullPath + strTag;
		
			var objNode = objWindowSettings.selectSingleNode(strFullPath);

			if (objNode == null) {
				var objTopNode;
				var objAppNode;
				
				objAppNode = objWindowSettings.selectSingleNode("/applications/application[@id='" + strAppName + "']");

				if (objAppNode == null) {
					objTopNode = objWindowSettings.selectSingleNode("/applications");

					if (objTopNode == null) {
						objTopNode = objWindowSettings.createElement("applications");
						objWindowSettings.appendChild(objTopNode);
					}
				
					objAppNode = objWindowSettings.createElement("application");
					objAppNode.setAttribute("id", strAppName);
					objTopNode.appendChild(objAppNode);
				}

				if (strXPath != null)
					objAppNode = PersistentXML_checkXPath(objAppNode, strXPath, objWindowSettings);

				objNode = objWindowSettings.createElement(strTag);
				objAppNode.appendChild(objNode);
			}

			objNode.setText(strValue);
		}
	}
}

function PersistentXML_checkXPath(objAppNode, strXPath, objWindowSettings) {
	
	var startpos = 0;

	while (strXPath.length > 0)
	{
		var pos = strXPath.indexOf("/");
		
		if (pos == -1)
			pos = strXPath.length;
		else
		{
			var openBracketPos = strXPath.indexOf("[");
			if (openBracketPos != -1)
			{
				var closeBracketPos = strXPath.indexOf("]");

				var insideBrackets = true;
				while (insideBrackets)
				{
					if ((pos > openBracketPos) && (pos < closeBracketPos))
					{
						pos = strXPath.indexOf("/", pos+1);
						if (pos == -1)	
							pos = strXPath.length;
					}
					else
						insideBrackets = false;
				}
			}
		}
		


		strElement = strXPath.substring(startpos, pos);

		strXPath = strXPath.substring(pos + 1, strXPath.length); 

		if (strElement.length > 0)
			objAppNode = PersistentXML_checkForCriteria(strElement, objAppNode, objWindowSettings);

	}
	
	return objAppNode;
}

function PersistentXML_trim(strInput) {
	strInput = strInput.replace(/^\s+|\s+$/g, "");
	return strInput.replace(/['"]/g, "");
}

function PersistentXML_checkForCriteria(strCheckElement, objAppNode, objWindowSettings) {

	var strOriginalElement = strCheckElement;
	var strParentElement;
	var arrAttributes = new Array();
	var arrNodes = new Array();
	var intAttributeCount = 0;
	var intNodeCount = 0;

	var criteriapos = strCheckElement.indexOf("[");
	
	if (criteriapos == -1)
		criteriapos = strCheckElement.length;

	strParentElement = strCheckElement.substring(0, criteriapos);

	strCheckElement = strCheckElement.substring(criteriapos + 1, strCheckElement.length); 

	while (strCheckElement.length > 0)
	{
		criteriapos = strCheckElement.indexOf(" and ");
		
		if (criteriapos == -1)
			criteriapos = strCheckElement.length;

		strCriteriaElement = strCheckElement.substring(0, criteriapos);

		strCheckElement = strCheckElement.substring(criteriapos + 5, strCheckElement.length); 

		if (strCriteriaElement.length > 0)
		{
			var operatorpos = strCriteriaElement.indexOf("=");
			
			var strNodeName = "";
			var strNodeValue = "";
			var strAttributeName = "";

			if (operatorpos > -1)
			{
				var endbracket = strCriteriaElement.indexOf("]");
				
				if (endbracket > -1)
					strCriteriaElement = strCriteriaElement.substring(0, endbracket);
				
				strNodeName = PersistentXML_trim(strCriteriaElement.substring(0, operatorpos));
				strNodeValue = PersistentXML_trim(strCriteriaElement.substring(operatorpos + 1, strCriteriaElement.length));
				
				if (strNodeName.charAt(0) == "@")
				{
					arrAttributes[intAttributeCount] = new Array();
					arrAttributes[intAttributeCount][0] = strNodeName.substring(1, strNodeName.length);
					arrAttributes[intAttributeCount][1] = strNodeValue;
					intAttributeCount++;
				}
				else
				{
					arrNodes[intNodeCount] = new Array();
					arrNodes[intNodeCount][0] = strNodeName;
					arrNodes[intNodeCount][1] = strNodeValue;
					intNodeCount++;
				}				
			}
		}
	}

	var objParentNode = objAppNode.selectSingleNode(strOriginalElement);
	var objNewNode = null;

	if (arrAttributes.length == 0 && arrNodes.length == 0)
	{
		if (objParentNode == null)
			objNewNode = objWindowSettings.createElement(strParentElement);
	}	

	if (arrAttributes.length > 0)
	{
		if (objParentNode == null)
		{
			objNewNode = objWindowSettings.createElement(strParentElement);

			for (i=0; i<arrAttributes.length; i++)
				objNewNode.setAttribute(arrAttributes[i][0], arrAttributes[i][1]);
		}
	}
		
	if (arrNodes.length > 0)
	{
		if (objParentNode == null)
		{
			objNewNode = objWindowSettings.createElement(strParentElement);
			
			for (i=0; i<arrNodes.length; i++)
			{
				var objChildNode = objNewNode.selectSingleNode(arrNodes[i][0]);
					
				if (objChildNode == null)
				{
					objChildNode = objWindowSettings.createElement(arrNodes[i][0]);
					if (arrNodes[i][1] != "")
						objChildNode.setText(arrNodes[i][1]);
						
					objNewNode.appendChild(objChildNode);
				}
			}
		}
	}

	if (objNewNode != null)
		objAppNode.appendChild(objNewNode);

	return objAppNode.selectSingleNode(strOriginalElement);
}

function PersistentXML_saveWindowSettings(strComponentID, objAppWindow, saveData) {

	var strCommand;
	var strXML;
	var objPost;
	var appName;
	var objWindowSettings;
	var objNode;
	var objGridColumnsXML;
	var objGridNode;
	var objTopNode;
	var bSave = true;

	// Cancelled from the login screen
	if (isBlank(objApplication.User.userID))
		return;

	if (strComponentID != null)
	{
		if (saveData != null && saveData == "false")
			bSave = false;

		// We need to find the window name for window settings and an app name for any others
		// The reason for this is because the app may be using a shared (persisted area) from another app
		// e.g. My Efacs and Configure My Efacs but their window settings will be different

		var strWindowName = PersistentXML_convertComponentID(strComponentID);

		if (this.WindowAttributes == null)
			this.loadApplicationSettings(strWindowName);

		if (this.strPersistenceArea != null)
			strAppName = this.strPersistenceArea;
		else
			strAppName = PersistentXML_convertComponentID(strComponentID);

		var arrGrids = objAppWindow.objApplication.arrGrids;

		var lngLeft = objAppWindow.self.screenLeft - 4;
		if (lngLeft < 0)
			lngLeft = 0;
		var lngWidth = objAppWindow.document.body.offsetWidth - 4;

		var lngTop = objAppWindow.self.screenTop - 23;
		if (lngTop < 0)
			lngTop = 0;
		var lngHeight = objAppWindow.document.body.offsetHeight - 4;

		objWindowSettings = this.WindowAttributes;

		// If no windows settings then exit.
		if (objWindowSettings == null)
			return;

		objGridColumnsXML = objApplication.createXMLDocument();

		//if we have no application node create one
		objNode = objWindowSettings.selectSingleNode("/applications/application[@id='" + strWindowName + "']");

		if (objNode == null) {
			var objTopNode;

			objTopNode = objWindowSettings.selectSingleNode("/applications");

			if (objTopNode == null) {
				objTopNode = objWindowSettings.createElement("applications");
				objWindowSettings.appendChild(objTopNode);
			}

			objNode = objWindowSettings.createElement("application");
			objTopNode.appendChild(objNode);

			objNode.setAttribute("id", strWindowName);
			objTopNode = objNode;
		}

			// we have the application node, so check for each grid...
		for (var i = 0; i < arrGrids.length; i++) {

			if (arrGrids[i] == null) {
				continue;
			}

			if (arrGrids[i].objAppWindow != objAppWindow)
				continue;
				
			objNode = objWindowSettings.selectSingleNode("/applications/application[@id='" + strAppName + "']/grid[@id='" + arrGrids[i].id + "']");

			// if there is no grid element then create one...
			if (objNode == null) {
				// if the grid node does not exist, create it
				objTopNode = objWindowSettings.selectSingleNode("/applications/application[@id='" + strAppName + "']");
				objNode = objWindowSettings.createElement("grid");
				objTopNode.appendChild(objNode);
				objNode.setAttribute("id", arrGrids[i].id);
			}

			// now we have the grid, so go through and ensure that there are the correctg number of columns
			var appSize = objWindowSettings.selectNodes("/applications/application[@id='" + strAppName + "']/grid[@id='" + arrGrids[i].id + "']/column").length();
			objTopNode = objWindowSettings.selectSingleNode("/applications/application[@id='" + strAppName + "']/grid[@id='" + arrGrids[i].id + "']");
			objGridColumnsXML.loadXML(arrGrids[i].objGridHeadingsXML.xml());
			objGridNode = objGridColumnsXML.selectNodes("/grid/column");

			// while we don't have the correct number of columns
			while (appSize != objGridNode.length()) {
				//if we have too many columns, remove the last one
				if (appSize > objGridNode.length()) {
					objTopNode.removeChild(objTopNode.lastChild());
					appSize--;
				} else {  //otherwise add a new column at the end
					objNode = objWindowSettings.createElement("column");
					objTopNode.appendChild(objNode);
					objNode.setAttribute("id", appSize + 1);
					appSize++;
				}
			}
		}

		// If window is in the menu frame then no need to save screen size.
		if (objAppWindow.opener != null) 
		{
			//reset objNode to point at application node and set the attributes
			objNode = objWindowSettings.selectSingleNode("/applications/application[@id='" + strWindowName + "']");
			objNode.setAttribute("width", lngWidth);
			objNode.setAttribute("height", lngHeight);
			objNode.setAttribute("x", lngLeft);
			objNode.setAttribute("y", lngTop);
		}
		else if (objAppWindow.dialogArguments != null)
		{
			objNode = objWindowSettings.selectSingleNode("/applications/application[@id='" + strWindowName + "']");
			
			var strHeight = objAppWindow.dialogHeight;
			var strWidth = objAppWindow.dialogWidth;
			
			if (strHeight.indexOf("px") != -1)
				lngHeight = Number(strHeight.substring(0, strHeight.indexOf("px")));
			else
				lngHeight = Number(strHeight);

			if (strWidth.indexOf("px") != -1)
				lngWidth = Number(strWidth.substring(0, strWidth.indexOf("px")));
			else
				lngWidth = Number(strWidth);

			objNode.setAttribute("width", lngWidth);
			objNode.setAttribute("height", lngHeight);
			objNode.setAttribute("x", lngLeft);
			objNode.setAttribute("y", lngTop);
		}

		//go through each grid and set the values in the app settings xml
		//so for each grid...
		for (var i = 0; i < arrGrids.length; i++) 
		{
			if (arrGrids[i] == null) {
				continue;
			}

			if (arrGrids[i].objAppWindow != objAppWindow)
				continue;
				
			// MCB - cannot do without a try catch here - problems with the timing of multiple windows unloading at once.
			try 
			{
				//set the vars to point to the correct respective grids
				var tableElement = arrGrids[i].HTMLtable.childNodes.item(0).childNodes.item(0);

				if (arrGrids[i] == null || tableElement == null)
					break;
			
				objGridColumnsXML.loadXML(arrGrids[i].objGridHeadingsXML.xml());
				var gridID = objGridColumnsXML.documentElement().getAttribute("id");
				objTopNode = objWindowSettings.selectNodes("/applications/application[@id='" + strWindowName + "']/grid[@id='" + gridID + "']/column");

				//for each column in the current grid
				for (var j = 0; j < tableElement.childNodes.length; j++) {
					//get the column width values and put them in the app settings xml
					if (j < objTopNode.length()) {
						objTopNode.item(j).setAttribute("width", tableElement.childNodes.item(j).style.width);
					}
				}
			} catch (error) {
				break;
			}
		}
		
		if (bSave)
		{
			this.saveApplicationSettings(strWindowName);

			if (String(strAppName) != String(strWindowName))
				this.saveApplicationSettings(strAppName);
			
		}
	}
}

function PersistentXML_saveApplicationSettings(strAppName)
{
	if ((this.OriginalWindowAttributes.selectSingleNode("/applications/application[@id='" + strAppName + "']") == null) ||
		(String(this.WindowAttributes.selectSingleNode("/applications/application[@id='" + strAppName + "']").xml()) != 
		String(this.OriginalWindowAttributes.selectSingleNode("/applications/application[@id='" + strAppName + "']").xml())))
	{
		var objRPC = new RPCObject("WindowAttribute");

		objRPC.execute("savePersistedSettings", objApplication.Connection.strConnectionString, 
								strAppName,
								objApplication.User.userID, 
								objApplication.User.language, 
								this.WindowAttributes.selectSingleNode("/applications/application[@id='" + strAppName + "']").xml());
		objRPC = null;
	}
}

function PersistentXML_getWindowSettings(strAppURL, flgIsModal) {
	var objWindowSettings;
	var retVal = null;

	var strWindowName = objApplication.getWindowFileName(strAppURL);

	var strUserID = objApplication.User.userID.replace("\\", "_");

	this.loadApplicationSettings(strWindowName);

	objWindowSettings = this.WindowAttributes;

	if (objWindowSettings != null && objWindowSettings.xml() != "") {
		retVal = PersistentXML_extractXML(objWindowSettings, strWindowName, flgIsModal);
	}
	
	if (retVal == null) {
		var objWS;
		var objTopNode;
		
		objWS = objApplication.createXMLDocument();
		objWS.loadURL("../WindowSettings/ws_" + strWindowName + ".xml", window.document.URL);
		// If no standard screen settings - use default values.
		if (objWS != null && objWS.xml() != "")
		{
			if (objWindowSettings != null) {
				if (objWindowSettings.xml() == "") {
					objTopNode = objWindowSettings.createElement("applications");
					objWindowSettings.appendChild(objTopNode);
				}
				strXML = "<applications>" + objWS.xml() + "</applications>";
			}
			else {					
				var strXML = objWindowSettings.xml().replace(/<\/applications>/g, objWS.xml() + "<\/applications>");
			}
			
			objWindowSettings.loadXML(strXML);

			retVal = PersistentXML_extractXML(objWindowSettings, strWindowName, flgIsModal);
		}
		else
		{
			retVal = "";
		}
	}

	return retVal;
}

/**
 * Determines the position and size of the window for the application.
 * If the window does not fit within the screen resolution then it is moved into a position
 * where it does fit.
 * 
 * @param objWindowSettings The window settings object containing information about the current application
 * @param strWindowName The application id
 * @param flgIsModal Determines how the window should be displayed - modal or modeless
 *
 * @return String The window position string which will be used by the window opening procedure
 */

function PersistentXML_extractXML(objWindowSettings, strWindowName, flgIsModal)
{
	var retVal = "";	
	var objNode = objWindowSettings.selectSingleNode("/applications/application[@id='" + strWindowName + "']");

	if (objNode != null) 
	{
		// Set up local variables for window position with default values
		var	height, width, x, y;
		if (strWindowName.indexOf("Edit") == -1)
		{
			height = 600;
			width = 800;
			x = 150;
			y = 150;
		}
		else
		{
			height = 400;
			width = 600;
			x = 250;
			y = 250;
		}

		// Retrieve the window position details from the persisted window settings

		if (objNode.getAttribute("height"))
			height = objNode.getAttribute("height");
		if (objNode.getAttribute("width"))
			width = objNode.getAttribute("width");
		if (objNode.getAttribute("x"))
			x = objNode.getAttribute("x");
		if (objNode.getAttribute("y"))
			y = objNode.getAttribute("y");

		// If the current position of the window is greater than the screen's width then
		// adjust it's position so that it falls within the screen's width
	
		if ((parseFloat(x) + parseFloat(width)) > parseFloat(screen.availWidth))
		{
			var adjust = (parseFloat(x) + parseFloat(width)) - parseFloat(screen.availWidth);
			
			if ((parseFloat(x) - parseFloat(adjust)) < 0)
			{
				x = 0;
				width = screen.availWidth;
			}
			else
			{
				x = parseFloat(x) - parseFloat(adjust);
			}
		}
		
		// If the current position of the window is greater than the screen's height then
		// adjust it's position so that it falls within the screen's height
	
		if ((parseFloat(y) + parseFloat(height)) > parseFloat(screen.availHeight))
		{
			var adjust = (parseFloat(y) + parseFloat(height)) - parseFloat(screen.availHeight);
			
			if ((parseFloat(y) - parseFloat(adjust)) < 0)
			{
				y = 0;
				height = screen.availHeight;
			}
			else
			{
				y = parseFloat(y) - parseFloat(adjust);
			}
		}

		// Depending on whether the window is modal or modeless create the window settings string to be used
		// by the window.open command
		
		if (flgIsModal) 
		{
			retVal = "dialogHeight:" + height + "px;";
			retVal += "dialogWidth:" + width + "px;";
			retVal += "dialogLeft:" + x + "px;";
			retVal += "dialogTop:" + y + "px;";
		}
		else 
		{
			retVal += ", height=" + height;
			retVal += ", width=" + width;
			retVal += ", left=" + x;
			retVal += ", top=" + y;
		}
	}
	
	return retVal;
}

function PersistentXML_convertComponentID(strComponentID) {

	if (strComponentID.indexOf(".xml") > -1)
		strComponentID = strComponentID.replace(".xml", "_html");

	return strComponentID;
}


	


function Query(queryID, objAppWindow)
{
	this.getSelectedColumnText  = Query_getSelectedColumnText;
	this.getColumnText			= Query_getColumnText;
	this.initialise				= Query_initialise;
	this.validate				= Query_validate;
	this.search					= Query_search;
	this.populateGrid			= Query_populateGrid;
	this.moveNext				= Query_moveNext;
	this.moveFirst				= Query_moveFirst;
	this.movePrevious			= Query_movePrevious;
	this.moveLast				= Query_moveLast;
	this.buildWhereClause		= Query_buildWhereClause;
	this.selectRecords			= Query_selectRecords;
	this.inheritCriteria		= Query_inheritCriteria;
	this.processFormat			= Query_processFormat;
	this.getCriteriaEntry		= Query_getCriteriaEntry;
	this.reOrder				= Query_reOrder;
	this.selectRow				= Query_selectRow;
	this.getHeight				= Query_getHeight;
	this.saveFilter				= Query_saveFilter;
	this.clearFilter			= Query_clearFilter;
	this.getFilter				= Query_getFilter;
	this.getFilterContainer		= Query_getFilterContainer;
	this.toggleFilter			= Query_toggleFilter;
	this.toggleFilterButton		= Query_toggleFilterButton;
	this.isFilterHidden			= Query_isFilterHidden;
	this.showFilter				= Query_showFilter;
	this.hideFilter				= Query_hideFilter;
	this.destroy				= Query_destroy;
	
	this.id 					= queryID;
	this.AppWindow				= objAppWindow;
	this.dataEngine				= null;
	this.searchedOnce			= false;
	this.title					= "";
	this.predefinedInput		= "";
	this.parentForm				= "";
	this.selectionMode			= "";
	this.parentfieldRef			= "";
	this.autoFilter				= true;
	this.autoSearch				= "true";
	this.Form					= null;
	this.Grid					= null;
	this.rows					= 0;
	this.XML					= "";
	this.orderArray				= new Array();
	this.directionArray			= new Array();
	this.flgClearInputParameters = true;
	this.filterHidden           = false;
}

function Query_getSelectedColumnText(strColumn)
{
	if (this.Grid)
	{
		return this.Grid.getSelectedColumnValue(strColumn);
	}
}

function Query_getColumnText(rowID, strColumn)
{
	if (this.Grid)
	{
		this.Grid.selectRow(rowID, true);
		return getSelectedColumnText(strColumn);
	}
}

function Query_selectRow(intRow) {
	this.Grid.selectRow(rowID);
}

/**
 * Initialise the query
 * @param strURL Application URL
 */
function Query_initialise(strURL) 
{
	var objField;
	var objForm;
	var strRecallFlag;
	
	this.parentForm = ParseStringFromURL("formid", strURL);
	this.selectionMode = ParseStringFromURL("selectionmode", strURL);
	this.parentfieldRef = ParseStringFromURL("fieldref", strURL);
	this.autoSearch = ParseStringFromURL("autosearch", strURL);

	if (this.Form) {
		var objWindow = getTopWindow();
		strRecallFlag = objWindow.objApplication.PersistentXML.getPersistentTag("filterDefaults", objWindow.m_strComponentId)

		this.Form.applyDefaultFormValues();

		for (var n = 0, intLen = this.Form.fields.length; n < intLen; n++)
		{
			objField = this.Form.fields[n];

			if (! (objField.isRequiredField() == true && objField.selectOne && objField.selectOne.listValueOnly == true) )
				objField.overwriteValidate = "objApplication.Queries(\"" + this.id + "\").validate";

			objField.overwriteProcessFormat = "objApplication.Queries(\"" + this.id + "\").processFormat";
			
			if (strRecallFlag == "true")
			{
				var strValue = objApplication.PersistentXML.getPersistentTag("filterDefault_" + this.Form.id + "_" + objField.strRef, m_strComponentId);
				
				if (strValue != null) {
					if (objField.selectOne) {
						if (objField.selectOne.listValueOnly == true) {
							if (objField.selectOne.getComboItemCaption(strValue) != null) {
								objField.setValue(strValue);
							}
							
						} else {
							objField.setValue(strValue);
						}
					} else {
						objField.setValue(strValue);
					}
				}
			}

			if (! objField.isRequiredField())
			{
				if (objField.HTMLElement.addressLookupColumn == "postcode" || objField.HTMLElement.strClass == "POSTCODE")
					objField.disableAddressLookup(true);
					
				if (objField.HTMLElement.mapLookup != "true")
					objField.disableMap(true);
					
				if (objField.HTMLElement.ctiLookup != "true")
					objField.disableCTI(true);
					
				if (!isBlank(objField.HTMLElement.strInfoPanelName))
					objField.disableInfoPanel(true);
			}
		}
	}

	if (this.Grid && !isBlank(this.dataEngine.sqlCommand)) {
		this.Grid.overrideSort = "objApplication.Queries(\"" + this.id + "\").reOrder";
		// remove event
		removeEvent(this.Grid.objAppWindow.document.body, "onmouseup", this.Grid.objAppWindow.et_doMouseUp);
		
		this.orderArray[0] = "";
		this.orderArray[1] = "";
		this.orderArray[2] = "";
		this.orderArray[3] = "";
	}
}

function Query_reOrder(intColumn, strDirection)
{
	var i;
	var firstComma = false;
	
	for (i = 0; i < 4; i++) {
		if (this.orderArray[i] == intColumn) {
			this.orderArray[i] = "";
		}
	}
	
	this.directionArray[3] = this.directionArray[2];
	this.directionArray[2] = this.directionArray[1];
	this.directionArray[1] = this.directionArray[0];
	this.directionArray[0] = strDirection;
	
	this.orderArray[3] = this.orderArray[2];
	this.orderArray[2] = this.orderArray[1];
	this.orderArray[1] = this.orderArray[0];
	this.orderArray[0] = intColumn;
	
	this.dataEngine.sqlOrderBy = "ORDER BY ";

	for (i = 0; i < 4; i++) {
		if (this.orderArray[i] != "") {
			if (firstComma == true) {
				this.dataEngine.sqlOrderBy += ", ";
			}

			this.dataEngine.sqlOrderBy += this.orderArray[i];
			this.dataEngine.sqlOrderBy += " " + this.directionArray[i];

			firstComma = true;
		}
	}

	if (this.searchedOnce) {
		this.populateGrid(this.dataEngine.extractXML());
	}
}

function Query_inheritCriteria()
{
	if (typeof(this.parentfieldRef) != 'undefined' && !isBlank(this.parentfieldRef)) {
		var objForm = this.AppWindow.opener.objApplication.Forms(this.parentForm);
		var objFormField = objForm.getFieldByRef(this.parentfieldRef);
		var strVal;
		var strNewParam;
		
		for (var intCtr = 0; intCtr < objFormField.queryInputs.length; intCtr++)
		{
			if (objFormField.queryInputs[intCtr].strValue != null) {
				this.predefinedInput = this.dataEngine.addInputParameter("PM" + intCtr, 
											objFormField.queryInputs[intCtr].strValue, 
											null, 
											objFormField.queryInputs[intCtr].strQueryColumnName, 
											"xsd:string");
			}
			else {
				strVal = objForm.getFieldByRef(objFormField.queryInputs[intCtr].strRef).getValue();
				strNewParamCol = "ref=\"" + objFormField.queryInputs[intCtr].strQueryColumnName + "\"";				
				
				if (strVal != "" && this.predefinedInput.indexOf(strNewParamCol) == -1) {
					this.predefinedInput = this.dataEngine.addInputParameter("PM" + intCtr, 
												strVal,
												null,
												objFormField.queryInputs[intCtr].strQueryColumnName, 
												objForm.getFieldByRef(objFormField.queryInputs[intCtr].strRef).strDataType,
												objForm.getHTMLFieldByRef(objFormField.queryInputs[intCtr].strRef).isDateFormat == "true" ? "true" : "false");
				}
			}
		}
	}
}

function Query_validate(formfield) 
{
	var parsed = true;
	var validchars = "e0123456789.-+<>=!:";
	var strData = formfield.getValue();
	var letter;

	switch (String(formfield.strDataType)) {
		case "xsd:float":
		case "xsd:integer":
		case "xsd:decimal":
		case "xsd:smallfloat":
		case "xsd:smallint":
		case "xsd:double":
			for (var i = 0; i < strData.length; i++) {
				letter = strData.charAt(i);
				
				if (validchars.indexOf(letter) != -1)
					continue;
					
				parsed = false;
				break;
			}
			break;
			
		case "xsd:dateTime":
			if (strData == "")
				break;

			if (this.processFormat(strData, formfield) == "") {
				parsed = false;
			}
			break;
	}

	return parsed;

}

function Query_processFormat(strCurrentXMLValue, objFormField)
{
	var strDate;
	var strDateTo;
	var strDateFrom;

	if (strCurrentXMLValue == "" || strCurrentXMLValue.indexOf("*") != -1 || strCurrentXMLValue.indexOf("%") != -1) {
		return "";
	}

	var objEfacsCalendar       = objApplication.getCalendarParser();
	if (isISODate(strCurrentXMLValue)) {

		objEfacsCalendar.setDateTimeInISO (strCurrentXMLValue);
		// return only the date portion?
		if (objFormField.HTMLElement.isDateFormat == "true") {
			return objEfacsCalendar.getDateInLocaleFormat();
		}
		else {
			return objEfacsCalendar.getDateTimeInLocaleFormat();
		 }
	}	
	else if (strCurrentXMLValue.indexOf("..") != -1) {
		// a range has been typed in
		try {
			objEfacsCalendar.setDateTimeInLocaleFormat (strCurrentXMLValue.substring(0, strCurrentXMLValue.indexOf("..")));
			if (objFormField.HTMLElement.isDateFormat == "true")
				strDateFrom=objEfacsCalendar.getDateInLocaleFormat();
			else	
				strDateFrom=objEfacsCalendar.getDateTimeInLocaleFormat();
		} catch(error) {
			strDateFrom="";
		}
		try {
			objEfacsCalendar.setDateTimeInLocaleFormat (strCurrentXMLValue.substring(strCurrentXMLValue.indexOf("..") + 2, strCurrentXMLValue.length));
			if (objFormField.HTMLElement.isDateFormat == "true")
				strDateTo=objEfacsCalendar.getDateInLocaleFormat();
			else	
				strDateTo=objEfacsCalendar.getDateTimeInLocaleFormat();
		} catch(error) {
			strDateTo="";
		}		
		if (strDateFrom == "" || strDateTo == "")
			return "";

		return strDateFrom + ".." + strDateTo;
	}
	else if (strCurrentXMLValue.indexOf("|") != -1) {
		var from = 0;
		var to = 0;
		var strValue = "";
		var currentValue = "";

        for (; ;) {
            to = strCurrentXMLValue.indexOf("|", from);

            if (from > 0)
                strValue += "|";

			try {
				objEfacsCalendar.setDateTimeInLocaleFormat (strCurrentXMLValue.substring(from, (to == -1 ? strCurrentXMLValue.length : to)));
				if (objFormField.HTMLElement.isDateFormat == "true")
					currentValue=objEfacsCalendar.getDateInLocaleFormat();
				else	
					currentValue=objEfacsCalendar.getDateTimeInLocaleFormat();
			} catch(error) {
				currentValue="";
			}

            if (currentValue == "")
				return "";
            
            strValue += currentValue;

            if (to == -1)
                break;

            from = to + 1;
        }
        
        return strValue;
	}
	else if (strCurrentXMLValue.indexOf("<>") != -1) {
		try {
			objEfacsCalendar.setDateTimeInLocaleFormat (strCurrentXMLValue.substring(strCurrentXMLValue.indexOf("<>") + 2, strCurrentXMLValue.length));
			if (objFormField.HTMLElement.isDateFormat == "true")
				strDate=objEfacsCalendar.getDateInLocaleFormat();
			else	
				strDate=objEfacsCalendar.getDateTimeInLocaleFormat();
		} catch(error) {
			strDate="";
		}		
		if (strDate == "")
			return "";

		return "<>" + strDate;
	}
	else if (strCurrentXMLValue.indexOf("!=") != -1) {
		try {
			objEfacsCalendar.setDateTimeInLocaleFormat (strCurrentXMLValue.substring(strCurrentXMLValue.indexOf("!=") + 2, strCurrentXMLValue.length));
			if (objFormField.HTMLElement.isDateFormat == "true")
				strDate=objEfacsCalendar.getDateInLocaleFormat();
			else	
				strDate=objEfacsCalendar.getDateTimeInLocaleFormat();
		} catch(error) {
			strDate="";
		}				
		if (strDate == "")
			return "";

		return "!=" + strDate;
	}
	else if (strCurrentXMLValue.indexOf(">=") != -1) {
		try {
			objEfacsCalendar.setDateTimeInLocaleFormat (strCurrentXMLValue.substring(strCurrentXMLValue.indexOf(">=") + 2, strCurrentXMLValue.length));
			if (objFormField.HTMLElement.isDateFormat == "true")
				strDate=objEfacsCalendar.getDateInLocaleFormat();
			else	
				strDate=objEfacsCalendar.getDateTimeInLocaleFormat();
		} catch(error) {
			strDate="";
		}
		if (strDate == "")
			return "";

		return ">=" + strDate;
	}
	else if (strCurrentXMLValue.indexOf("<=") != -1) {
		try {
			objEfacsCalendar.setDateTimeInLocaleFormat (strCurrentXMLValue.substring(strCurrentXMLValue.indexOf("<=") + 2, strCurrentXMLValue.length));
			if (objFormField.HTMLElement.isDateFormat == "true")
				strDate=objEfacsCalendar.getDateInLocaleFormat();
			else	
				strDate=objEfacsCalendar.getDateTimeInLocaleFormat();
		} catch(error) {
			strDate="";
		}		
		if (strDate == "")
			return "";

		return "<=" + strDate;
	}
	else if (strCurrentXMLValue.indexOf("!") != -1) {
		try {
			objEfacsCalendar.setDateTimeInLocaleFormat (strCurrentXMLValue.substring(strCurrentXMLValue.indexOf("!") + 1, strCurrentXMLValue.length));
			if (objFormField.HTMLElement.isDateFormat == "true")
				strDate=objEfacsCalendar.getDateInLocaleFormat();
			else	
				strDate=objEfacsCalendar.getDateTimeInLocaleFormat();
		} catch(error) {
			strDate="";
		}				
		
		if (strDate == "")
			return "";

		return "!" + strDate;
	}
	else if (strCurrentXMLValue.indexOf(">") != -1) {
		try {
			objEfacsCalendar.setDateTimeInLocaleFormat (strCurrentXMLValue.substring(strCurrentXMLValue.indexOf(">") + 1, strCurrentXMLValue.length));
			if (objFormField.HTMLElement.isDateFormat == "true")
				strDate=objEfacsCalendar.getDateInLocaleFormat();
			else	
				strDate=objEfacsCalendar.getDateTimeInLocaleFormat();
		} catch(error) {
			strDate="";
		}				
		
		if (strDate == "")
			return "";

		return ">" + strDate;

	}
	else if (strCurrentXMLValue.indexOf("<") != -1) {
		try {
			objEfacsCalendar.setDateTimeInLocaleFormat (strCurrentXMLValue.substring(strCurrentXMLValue.indexOf("<") + 1, strCurrentXMLValue.length));
			if (objFormField.HTMLElement.isDateFormat == "true")
				strDate=objEfacsCalendar.getDateInLocaleFormat();
			else	
				strDate=objEfacsCalendar.getDateTimeInLocaleFormat();
		} catch(error) {
			strDate="";
		}				
		
		if (strDate == "")
			return "";

		return "<" + strDate;
	}
	else {
		try {
			objEfacsCalendar.setDateTimeInLocaleFormat (strCurrentXMLValue);
			if (objFormField.HTMLElement.isDateFormat == "true")
				strDate=objEfacsCalendar.getDateInLocaleFormat();
			else	
				strDate=objEfacsCalendar.getDateTimeInLocaleFormat();
		} catch(error) {
			strDate="";
		}				
		
		return strDate;
	}
}

function Query_search(clearInputParams) 
{
	// If the application presearch returns false do not continue with the search
	var flgContinue;
	if (typeof(this.AppWindow[this.id + "_preSearch"]) != "undefined") {
		flgContinue = this.AppWindow[this.id + "_preSearch"]();
	}

	if (flgContinue == false)
		return false;

	if (this.Form) {
		if (! this.Form.validate()) {
			return false;
		}
	}

	if (this.Grid) {
		this.dataEngine.additionalXML = this.Grid.objGridHeadingsXML.xml();
		this.Grid.clear();
	}
	
	this.searchedOnce = true;

	if ((clearInputParams == null || clearInputParams == true) && this.flgClearInputParameters != false)
		this.dataEngine.clearInputParameters(this.predefinedInput);

	this.inheritCriteria();

	if (this.autoFilter)
		this.buildWhereClause();

	var strXML = this.dataEngine.populateEngine();

	if (objApplication.hadCriticalError || strXML.substring(0, 6) == "<error")
		return;

	if (this.Grid) {
		this.dataEngine.calculatePageSize(strXML, "rows=\"", "\"");
	}
	else {
		this.dataEngine.calculatePageSize(strXML, "<rows>", "</rows>");
	}
	
	this.populateGrid(strXML);

	if (typeof(this.AppWindow[this.id + "_postSearch"]) != "undefined") {
		this.AppWindow[this.id + "_postSearch"]();
	}

	return true;
}

function Query_populateGrid(strXML) 
{
	if (strXML != "" && strXML.substring(0, 6) != "<error") {
		if (this.Grid) {
			this.Grid.HTMLdiv.innerHTML = escapeStringDoubleSpaces(strXML);
			this.Grid.setup();
		}
		else {
			this.XML = strXML;
		}
	}

	this.saveFilter();
}

/**
 * Moves to the next page.
 */
function Query_moveNext() 
{
	if (typeof(this.AppWindow[this.id + "_preNavigate"]) != "undefined") {
		this.AppWindow[this.id + "_preNavigate"]();
	}

	this.populateGrid(this.dataEngine.moveNext());

	if (typeof(this.AppWindow[this.id + "_postNavigate"]) != "undefined") {
		this.AppWindow[this.id + "_postNavigate"]();
	}
}

/**
 * Moves to the previous page.
 */
function Query_movePrevious() 
{
	if (typeof(this.AppWindow[this.id + "_preNavigate"]) != "undefined") {
		this.AppWindow[this.id + "_preNavigate"]();
	}

	this.populateGrid(this.dataEngine.movePrevious());

	if (typeof(this.AppWindow[this.id + "_postNavigate"]) != "undefined") {
		this.AppWindow[this.id + "_postNavigate"]();
	}
}

/**
 * Moves to the first page.
 */
function Query_moveFirst() 
{
	if (typeof(this.AppWindow[this.id + "_preNavigate"]) != "undefined") {
		this.AppWindow[this.id + "_preNavigate"]();
	}

	this.populateGrid(this.dataEngine.moveFirst());

	if (typeof(this.AppWindow[this.id + "_postNavigate"]) != "undefined") {
		this.AppWindow[this.id + "_postNavigate"]();
	}
}

/**
 * Moves to the last page.
 */
function Query_moveLast() 
{
	if (typeof(this.AppWindow[this.id + "_preNavigate"]) != "undefined") {
		this.AppWindow[this.id + "_preNavigate"]();
	}

	this.populateGrid(this.dataEngine.moveLast());

	if (typeof(this.AppWindow[this.id + "_postNavigate"]) != "undefined") {
		this.AppWindow[this.id + "_postNavigate"]();
	}
}

function Query_getCriteriaEntry(strValue, objFormfield) 
{
	if (objFormfield.strDataType != "xsd:dateTime") {
		return strValue;	
	}
	// therefore date time field
	var strDateFrom;
	var strDateTo;
	var strDate;

	if (strValue == "")
		return strValue;

	var objEfacsCalendar       = objApplication.getCalendarParser();

	if (strValue.indexOf("..") != -1) {
		objEfacsCalendar.setDateTimeInLocaleFormat (strValue.substring(0, strValue.indexOf("..")));
		strDateFrom=objEfacsCalendar.getDateTimeInISO();
		objEfacsCalendar.setDateTimeInLocaleFormat (strValue.substring(strValue.indexOf("..") + 2, strValue.length));
		strDateTo=objEfacsCalendar.getDateTimeInISO();

		return strDateFrom + ".." + strDateTo;
		
	} else if (strValue.indexOf("|") != -1) {

		var from = 0;
		var to = 0;
		var strDateValue = "";

        for (; ;) {
            to = strValue.indexOf("|", from);

            if (from > 0)
                strDateValue += "|";

     		objEfacsCalendar.setDateTimeInLocaleFormat (strValue.substring(from, (to == -1 ? strValue.length : to)));
	        strDateValue += objEfacsCalendar.getDateTimeInISO();
            if (to == -1)
                break;

            from = to + 1;
        }

		return strDateValue;
		
	} else if (strValue.indexOf("<>") != -1) {
     	objEfacsCalendar.setDateTimeInLocaleFormat (strValue.substring(strValue.indexOf("<>") + 2, strValue.length));
	    return "<>" + objEfacsCalendar.getDateTimeInISO();	
	} else if (strValue.indexOf("!=") != -1) {
     	objEfacsCalendar.setDateTimeInLocaleFormat (strValue.substring(strValue.indexOf("!=") + 2, strValue.length));
	    return "!=" + objEfacsCalendar.getDateTimeInISO();	
	} else if (strValue.indexOf(">=") != -1) {
     	objEfacsCalendar.setDateTimeInLocaleFormat (strValue.substring(strValue.indexOf(">=") + 2, strValue.length));
	    return ">=" + objEfacsCalendar.getDateTimeInISO();	
	} else if (strValue.indexOf("!") != -1) {
     	objEfacsCalendar.setDateTimeInLocaleFormat (strValue.substring(strValue.indexOf("!") + 1, strValue.length));
	    return "!" + objEfacsCalendar.getDateTimeInISO();	
	} else if (strValue.indexOf("<=") != -1) {
     	objEfacsCalendar.setDateTimeInLocaleFormat (strValue.substring(strValue.indexOf("<=") + 2, strValue.length));
	    return "<=" + objEfacsCalendar.getDateTimeInISO();	
	} else if (strValue.indexOf(">") != -1) {
     	objEfacsCalendar.setDateTimeInLocaleFormat (strValue.substring(strValue.indexOf(">") + 1, strValue.length));
	    return ">" + objEfacsCalendar.getDateTimeInISO();	
	} else if (strValue.indexOf("<") != -1) {
     	objEfacsCalendar.setDateTimeInLocaleFormat (strValue.substring(strValue.indexOf("<") + 1, strValue.length));
	    return "<" + objEfacsCalendar.getDateTimeInISO();	
	} else {
     	objEfacsCalendar.setDateTimeInLocaleFormat (strValue);
	    return objEfacsCalendar.getDateTimeInISO();	
	}
}

function Query_buildWhereClause() 
{
	var objFormField;
	var strWC = "";
	var fromFound = 0;
	var strAliasedColumn = null;
	var strRefToPass = null;

	if (this.Form) {
		for (var n = 0; n != this.Form.fields.length; n++)
		{
			objFormField = this.Form.fields[n];
			
			if (objFormField.HTMLElement.blnIsDisabled == "true")
				continue;
			
			strAliasedColumn = objFormField.strAliasedColumn;
			if (!isBlank(strAliasedColumn))
				strRefToPass = strAliasedColumn;
			else
				strRefToPass = objFormField.strRef;
				
			if (objFormField.strDataType == "xsd:string") {
				if (objFormField.getValue() != "" && objFormField.getValue() != "*" && objFormField.getValue() != "%") {
					this.dataEngine.addInputParameter("W" + n, 
													this.getCriteriaEntry(objFormField.getValue(), objFormField), 
													objFormField.HTMLElement.strTable, 
													strRefToPass , 
													objFormField.strDataType,
													objFormField.HTMLElement.isDateFormat == "true" ? "true" : "false");
				}
			}
			else {
				if (objFormField.getValue() != "") {
					this.dataEngine.addInputParameter("W" + n, 
													this.getCriteriaEntry(objFormField.getValue(), objFormField), 
													objFormField.HTMLElement.strTable, 
													strRefToPass , 
													objFormField.strDataType,
													objFormField.HTMLElement.isDateFormat == "true" ? "true" : "false");
				}
			}
		}
	}
}

function Query_selectRecords() 
{
	var objForm = null;

	// Now set query results on Form (if available).
	// Get query input parameters if available.
	try {
		objForm = this.AppWindow.opener[this.parentForm];
		
		if (objForm == undefined)
			objForm = null;
	} catch(error) {
		objForm = null;
	}
	var strRef = this.parentfieldRef;

	if (objForm != null)
	{
		var objFormField = objForm.getFieldByRef(strRef);
		var strResultRef;
		var strQueryColumnName;
		var strQueryVal;

		if (objFormField.queryResults.length == 0) {
			objFormField.setValueWithEvents(this.Grid.getSelectedColumnValueByIndex(1));

			if (objForm.objWindow.objStatusBar != null)
				objForm.objWindow.objStatusBar.clear();
		}
		else {
			for (var intCtr = 0; intCtr < objFormField.queryResults.length; intCtr++)
			{
				strResultRef = objFormField.queryResults[intCtr].strRef;
				strQueryColumnName = objFormField.queryResults[intCtr].strQueryColumnName;

				objForm.getFieldByRef(strResultRef).setValueWithEvents(this.Grid.getSelectedColumnValue(strQueryColumnName));

				if (objForm.objWindow.objStatusBar != null)
					objForm.objWindow.objStatusBar.clear();
			}
		}

		this.AppWindow.close();
	}
}

/**
 *	Returns the combined height of the container and toolbar.
 *	@return Container height + Toolbar height
 */
function Query_getHeight() {
	var containerHeight = Number(this.AppWindow["cccc" + this.id].offsetHeight);
	var toolbarHeight = Number(this.AppWindow["tlb" + this.id].HTMLElement.offsetHeight);
	return Number(containerHeight + toolbarHeight);
}

/**
 * Saves current query filter criteria
 */
function Query_saveFilter() 
{
	if (this.Form == null)
		return;

	var objWindow = getTopWindow();
	var strRecallFlag = objWindow.objApplication.PersistentXML.getPersistentTag("filterDefaults", objWindow.m_strComponentId);
	if (strRecallFlag == "true")
	{
		for (var i=0, intLen = this.Form.fields.length; i < intLen; i++)
		{
			var objField = this.Form.fields[i];
			objApplication.PersistentXML.setPersistentTag("filterDefault_" + this.Form.id + "_" + objField.strRef, objField.getValue(), m_strComponentId);
		}
	}
}

/**
 * Clears current query filter criteria
 */
function Query_clearFilter() 
{
	for (var i=0, intLen = this.Form.fields.length; i < intLen; i++)
	{
		var objField = this.Form.fields[i];
		if (objField.isVisible())
		{
			if (objField.strDataType == "xsd:boolean")
				objField.setValue("false");
			else
				objField.setValue("");
		}	
	}

	this.Form.applyDefaultFormValues();
	this.saveFilter();
	this.Form.setInitialFocus();
	this.AppWindow.objStatusBar.clear();
}

/**
 * Toggle the query filter on or off.
 * @param objElement - The html element for the filter button.
 */
function Query_toggleFilter(objElement) {
	if (this.isFilterHidden()) {
		this.showFilter();
	} else {
		this.hideFilter();
	}
	this.toggleFilterButton(objElement);
	this.AppWindow.localResize();
}

/**
 * Returns true if the query filter is hidden, false otherwise.
 */
function Query_isFilterHidden() {
	return this.filterHidden;
}

/**
 * Shows the query filter.
 */
function Query_showFilter() {
	this.filterHidden = false;
	var objSearchFilter = this.getFilter();
	objSearchFilter.style.display = "inline";
	var objContainer = this.getFilterContainer();
	if (objContainer != null) {
		objContainer.isCollapsed = false;
	}
}

/**
 * Returns the query filter object.
 */
function Query_getFilter() {
	return this.AppWindow["cccc" + this.id];
}

/**
 * Returns the query filter container object.
 */
function Query_getFilterContainer() {
	return this.AppWindow["cc" + this.id];
}

/**
 * Hides the query filter.
 */
function Query_hideFilter() {
	this.filterHidden = true;
	var objSearchFilter = this.getFilter();
	objSearchFilter.style.display = "none";
	var objContainer = this.getFilterContainer();
	if (objContainer != null) {
		objContainer.isCollapsed = true;
	}
}

/**
 * Toggles the query filter button on or off.
 * @param objElement - The html element for the filter button.
 */
function Query_toggleFilterButton(objElement) {
	var objToolbar = util_getToolbarFromButton(objElement, this.AppWindow);
	var objButton = objToolbar.getButton(objElement.id);
	if (objButton != null) {
		objButton.toggle();
	}
}

/**
 * Clear references to the query object
 */
function Query_destroy() {
	try {
		this.AppWindow				= null;
		if (this.dataEngine != null) {
			this.dataEngine.destroy();
			this.dataEngine = null;
		}
		this.title					= null;
		this.predefinedInput		= null;
		this.parentForm				= null;
		this.selectionMode			= null;
		this.parentfieldRef			= null;
		this.autoSearch				= null;
		this.Form					= null;
		this.Grid					= null;
		this.rows					= 0;
		this.XML					= null;
		if (this.orderArray != null) {
			for (var i = 0, len = this.orderArray.length; i < len; i++) {
				this.orderArray[i] = null;
			}
		}
		this.orderArray				= new Array();
		if (this.directionArray != null) {
			for (var i = 0, len = this.directionArray.length; i < len; i++) {
				this.directionArray[i] = null;
			}
		}
		this.directionArray			= new Array();
		this.id 					= null;
	} catch (error) {
	}
}


/* This "RPC" object allows the web-page to make a call to a server.
	First of all the RPC object is created e.g.
	
		var objPart = new RPCObject("Part");
	
	The argument passed to the RPC object is the name of the class that is being accessed
	on the server.  To execute a particular RPC method, call the "execute" method e.g.
	
		strXML = objPart.execute("Load", objApplication.Connection.strQueryString, "AR3");
		
	...which will return the value back to the the web-page.  The first argument of the "execute"
	method is a string that contains the name of the method that should be invoked.  In most cases,
	the next argument will be the database connectivity string and the following arguments
	describe the primary key of the record being retrieved.	
	
	If an error is returned a error handler can be called using
	
		showEfacsError(objError, window);
*/

// Constructor
function RPCObject(strRPCObject, objWindow, server)
{
// properties
	this.id = strRPCObject;
	this.flgIsEmpty = true;

	this.handleRPCError = true;
	this.returnValue = null;
	this.lastXMLDom = null; // Do not access this directly!! It will be loaded over by the next call to execute().
	this.referencedLastXMLDom = false;
	this.FAILED = false;
	if (objWindow != null)
		this.objWindow = objWindow;
	else
		this.objWindow = window;

	// intialise the rpcCache the first time it is used.
	if (objApplication.Connection.rpcCache == null) 
	{
		if (server != null) {
			objApplication.Connection.rpcCache = objApplication.EfacsApplet.getRPCClient(server);
			
		} else {
			objApplication.Connection.rpcCache = objApplication.EfacsApplet.getRPCClient(objApplication.Connection.applicationServer);
		}
	}
	try {
		this.objRPCService = objApplication.Connection.rpcCache.getService(strRPCObject.toLowerCase());
	} catch (error) {
		this.FAILED=true;
		showEfacsError(error, this.objWindow, true);
	}
}

// This method uses the javascript "argument" array to dynamically build up a string which will
// then be called using the "eval" function.
RPCObject.prototype.execute = function ()
{
	var strArgs = "";
	var strCommand;
	var arrX = new Array();
	var objNodes;

	if (this.objRPCService == null)
		return;

	this.FAILED = false;

	this.objRPCService.setAction(arguments[0].toLowerCase());

	// setup the parameters for the call
	for (var n = 1; n < arguments.length; n++) {
		if (arguments[n] == null) {
			this.objRPCService.setParamNull();
		} else {
			this.objRPCService.setParam(arguments[n].toString());
		}
	}

	// Execute the RPC call.
	this.returnValue = this.objRPCService.invoke();

	if (this.objRPCService.hasException())
	{
		this.FAILED=true;

		var objError = new Error(ERROR_RPCINVOKEERROR, this.objRPCService.getErrorMessage());

		if (this.handleRPCError)
			showEfacsError(objError, this.objWindow, true);
		else
			throw(objError);
	}		

	this.flgIsEmpty = true;
	if (!isBlank(this.returnValue)) {
		if (this.returnValue.substring(0, 1) == "<") {
			// If no DOM or the last 1 is referenced then create a new DOM
			// otherwise re-use the DOM for speed!
			if (this.lastXMLDom == null || this.referencedLastXMLDom == true) {
				this.lastXMLDom = objApplication.createXMLDocument();
			}
			
			if (this.lastXMLDom.loadXML(this.returnValue)) {
				var objNodes = this.lastXMLDom.selectNodes("/*/*");
				for (var objNode = objNodes.nextNode(); objNode != null; objNode = objNodes.nextNode()) {
					if (objNode.nodeName() != "dataprocess" && objNode.nodeName() != "properties" && objNode.nodeName() != "validationerrors") {
						this.flgIsEmpty = false;
						break;
					}
				}
			}
		}
	}

	if (!this.FAILED && arguments[0].toLowerCase() == "save")
		if (typeof(objStatusBar) != 'undefined')
			objStatusBar.message("Saved");

	if (this.returnValue == null)
		return;

	return this.returnValue;
}

// Load return value from last RPC call to see if data was loaded - return true/false.
RPCObject.prototype.isEmpty = function () {
	return this.flgIsEmpty;
}

/** Returns the DOM loaded by the last call to execute().
 * @return XML dom object
 */
RPCObject.prototype.getReturnedXMLDom = function () {
	// Mark as referenced last XML dom so we need a new
	// DOM object we should not loadXML over the last one!
	this.referencedLastXMLDom = true;
	return this.lastXMLDom;
	
}




function RecordList(objNodeList) {
	
	this.intRecordNo		=	0;
	this.objCollection	=	objNodeList;
	this.currentNode	=	null;
	this.moveToRecord	=	RLmoveToRecord;
		
	this.moveFirst		=	RLmoveFirst;
	this.movePrevious	=	RLmovePrevious;
	this.moveNext		=	RLmoveNext;
	this.moveLast		=	RLmoveLast;
		
	this.currentRecord	=	RLcurrentRecord;
}
	
function RLcurrentRecord() {
	return this.currentNode;
}
	
function RLmoveToRecord(lngUniqueID) {
  var objNode;
  var strUniqueIDNode;
 
	for (var i = 0; i < this.objCollection.length(); i++) {
		objNode = this.objCollection.item(i);
		
		strUniqueIDNode = objNode.getAttribute("uniqueid");
		if (isBlank(strUniqueIDNode)) {
			alert("Cannot find record's unique identifier");
			return false;
		}

		if (strUniqueIDNode == String(lngUniqueID)) {
			this.currentNode = objNode;
			this.intRecordNo = i;
			return true;
		}       
	}
	
	return false;
}
	
function RLmoveFirst() {
	if (this.intRecordNo == 0)
		return false;
		
	this.intRecordNo = 0;
	this.currentNode = this.objCollection.item(0);

	return true;
}
	
function RLmovePrevious() {
	if (this.intRecordNo == 0)
		return false;
		
	this.currentNode = this.objCollection.item(--this.intRecordNo);
	return true;
}

function RLmoveNext() {
	if (this.intRecordNo == this.objCollection.length() - 1)
		return false;
	
	this.currentNode = this.objCollection.item(++this.intRecordNo);
	return true;
}
	
function RLmoveLast() {
	if (this.intRecordNo == this.objCollection.length() - 1)
		return false;
		
	this.intRecordNo = this.objCollection.length() - 1;
	this.currentNode = this.objCollection.item(this.intRecordNo);
		
	return true;
}

	



function ResizableContainer(objElement) {
	var objSplitter = window[objElement.id + "_split2"];

	this.objMainContainer	= objElement;

	this.blnMouseDown	= false;
	this.intLastXPos	= 0;
	this.intContainerWidth	= objElement.clientWidth - (objElement.style.paddingLeft + objElement.style.paddingRight) ;

	this.objCurrentSplitter	= null;
	this.intSplitterWidth	= getTotalElementWidth(objSplitter);

	this.mouseOver		= Resizer_mouseOver;
	this.mouseDown	= Resizer_mouseDown;
	this.mouseMove		= Resizer_mouseMove;
	this.mouseUp		= Resizer_mouseUp;
	this.resize			= Resizer_resize;

	this.leftPanel		= null;
	this.rightPanel		= null;

	setWidths(this);
}



//------------------------------------------------------------------------------------------
function Resizer_mouseDown(objElement) {

	this.blnMouseDown = true;
	this.intLastXPos = event.clientX;
	this.objCurrentSplitter = objElement;

	this.leftPanel		= objElement.parentNode.previousSibling.firstChild;
	this.rightPanel		= objElement.parentNode.nextSibling.firstChild;
}


//------------------------------------------------------------------------------------------
function Resizer_resize(objElement) {

	if (this.blnMouseDown == true)
		return;
		
	// Reset variable that contains the outer container width...
	this.intContainerWidth = this.objMainContainer.offsetWidth;
	
	// Re-calculate widths of individual panels.
	setWidths(this);
}


//------------------------------------------------------------------------------------------
function Resizer_mouseMove(objElement)
{
  var intRightWidth, intLeftWidth;

	if (this.blnMouseDown == true) {
	    var objLeftElement = this.objCurrentSplitter.parentNode.previousSibling.firstChild;
	    var objRightElement = this.objCurrentSplitter.parentNode.nextSibling.firstChild;
	    var intDeltaX = event.clientX - this.intLastXPos;

		if (intDeltaX < 0) {
			// Decrease size of left TD and increase right TD
			if (decreaseWidth(objLeftElement, -intDeltaX) == true) {
				decreaseWidth(objLeftElement.parentNode, -intDeltaX);

				if (increaseWidth(objRightElement, -intDeltaX) == true)
					increaseWidth(objRightElement.parentNode, -intDeltaX);
				
				this.intLastXPos = event.clientX;
			}
		}
		else if (intDeltaX > 0) {
			// Decrease width of right TD and set left TD
			if (decreaseWidth(objRightElement, intDeltaX) == true) {
				decreaseWidth(objRightElement.parentNode, intDeltaX);
				
				if (increaseWidth(objLeftElement, intDeltaX) == true)
					increaseWidth(objLeftElement.parentNode, intDeltaX);
				
				this.intLastXPos = event.clientX;
			}
		}
		
		
	}
}


//------------------------------------------------------------------------------------------
function Resizer_mouseOver(objElement) {

	if (this.blnMouseDown ||objElement.name == "splitter")
		objElement.style.cursor = "e-resize";
	else
		objElement.style.cursor = "default";
}


//---------------------------------------------------------------------------
function Resizer_mouseUp(objElement) {
	this.blnMouseDown = false;
}


/* ***************************************************************************************/
/* --- PRIVATE FUNCTIONS ONLY USED INTERNALY BY THIS OBJECT ----*/
/* ***************************************************************************************/


function getElementWidth(objElement) {
	return objElement.offsetWidth;
}
//---------------------------------------------------------------------------
function getTotalElementWidth(objElement) {
	var intMarginLeft = parseInt(objElement.currentStyle.marginLeft);
	var intMarginRight = parseInt(objElement.currentStyle.marginRight);

	if (isNaN(intMarginLeft))
		intMarginLeft = 0;
	
	if (isNaN(intMarginRight))
		intMarginRight = 0;

	return objElement.offsetWidth + intMarginLeft + intMarginRight;
}
//---------------------------------------------------------------------------
function decreaseWidth(objElement, intDelta) {
  var intNewElementWidth;
  
	if (intDelta <= 0 || objElement.offsetWidth < 50) {
		return false;
	}
	intNewElementWidth = getElementWidth(objElement) - intDelta;
	
	objElement.style.width = (intNewElementWidth < 0 ? 0 : intNewElementWidth) + "px";
	
	return true;
}

function increaseWidth(objElement, intDelta) {
  var intNewElementWidth;

	if (intDelta <= 0 || objElement.offsetWidth < 50)
		return false;
	
	intNewElementWidth = getElementWidth(objElement) + intDelta;
	
	objElement.style.width = (intNewElementWidth < 0 ? 0 : intNewElementWidth) + "px";
	
	return true;
}
//---------------------------------------------------------------------------

function setWidths(objResizer) {
    var objNodes, objNode;
    var intTotalWidth = 0;
    var intPanels = 0;
    var intLeftSideWidth = 0;
    var intWidth = 0;

	objNodes = objResizer.objMainContainer.cells;
	for(var n = 0; n < objNodes.length; n++) {
		objNode = objNodes(n);
		if (n % 2) continue;		// We want to skip every other TD as they are splitter elements.
		
		intPanels++;

		if (n == objNodes.length - 1) {
		
			intLeftSideWidth = intTotalWidth + ((intPanels - 1) * objResizer.intSplitterWidth);
			intWidth = objResizer.intContainerWidth - intLeftSideWidth;
		
			objNode.style.width = intWidth;
			objNode.firstChild.style.width = intWidth;
		}

		intTotalWidth += getElementWidth(objNode);
	}
}


var m_intDialogCtr = 0;

function addEvent(obj, evType, fn)
{
	if (obj.addEventListener) { // NN (Level 2 event model support)
		obj.addEventListener(evType.substring(2, evType.length), fn, false); // Do not sepcify the "on" with Netscape
		return true;
	} else if (obj.attachEvent) // IE
		return obj.attachEvent(evType, fn);
	else
		alert("Handler could not be attached");
}

function removeEvent(obj, evType, fn)
{
	if (obj.removeEventListener) { // NN
		obj.removeEventListener(evType.substring(2, evType.length), fn, false);
		return true;
	} else if (obj.detachEvent)
		return obj.detachEvent(evType, fn);
	else
		alert("Handler could not be removed");
}

/** 
 * Shows a modal dialog box. Used by login.jsp, eMsgBox etc.
 *
 * @param target The target URL.
 * @param objApplication The application object.
 * @param format The modal dialog 'features'. E.g. height, width, position etc.
 * @param objWindow The calling window from which the dialog box will be launched.
 * @return The modal dialog return value.
 */
function showModalWindow(target, objApplication, format, objWindow)
{
	if (objWindow == null)
		objWindow = window;

	// window.returnvalue is not available under Netscape and so we cannot return a value from
	// the dialog box (i.e 7 for "Yes", 6 for "No" etc...).
	// To get around this we have a variable on the application object which is set in the
	// dialog window to hold the return value.
	
	if (target.indexOf("?") == -1)
		target = target + "?";
	else
		target = target + "&";
	
	target = target + "uid=mdl" + m_intDialogCtr++;
	
	if (objApplication.browser == APPLICATION_IE) {
	
		var arrObjects = new Array();
		arrObjects[modal_APPLICATION] = objApplication;
		
		arrObjects[modal_FUNCTIONALTEST] = getFunctionalTestObject();
		arrObjects[modal_WINDOW] = objWindow;
	
		objWindow.showModalDialog(target, arrObjects, format);
	}
	else {
		for (; format.indexOf(";") != -1; )
			format = format.replace(";", ",");
		format = format.replace("dialogWidth", "width").replace("dialogHeight", "Height");

		window.open(target, "", format + ",modal=yes");
	}

	return objApplication.dialogReturnValue;
}

if(typeof(HTMLElement) != "undefined" && ! HTMLElement.prototype.insertAdjacentElement) {
	HTMLElement.prototype.insertAdjacentElement = function (where, parsedNode)
	{
		switch (where) {
		case 'beforeBegin':
			this.parentNode.insertBefore(parsedNode, this)
			break;
		case 'afterBegin':
			this.insertBefore(parsedNode, this.firstChild);
			break;
		case 'beforeEnd':
			this.appendChild(parsedNode);
			break;
		case 'afterEnd':
			if (this.nextSibling) 
				this.parentNode.insertBefore(parsedNode, this.nextSibling);
			else 
				this.parentNode.appendChild(parsedNode);
			break;
		}
	}

	HTMLElement.prototype.insertAdjacentHTML = function (where, htmlStr)
	{
		var range = this.ownerDocument.createRange();
		range.setStartBefore(this);
		var parsedHTML = range.createContextualFragment(htmlStr);
		this.insertAdjacentElement(where, parsedHTML)
	}


	HTMLElement.prototype.insertAdjacentText = function (where, txtStr)
	{
		var parsedText = document.createTextNode(txtStr)
		this.insertAdjacentElement(where, parsedText)
	}
}

function getPosX(objEvent)
{
	return objApplication.browser == APPLICATION_IE ? objEvent.clientX : objEvent.pageX;
}

function getPosY(objEvent)
{
	return objApplication.browser == APPLICATION_IE ? objEvent.clientY : objEvent.pageY;
}




/*	The status bar object allows the developer to control the contents of the status bar's panels.
  	 It current has 3 panels; a message panel, a user details panel and a company details panel.
 	 The first panel, the message area can be controlled with 3 exposed methoods
		clear()			This simply empties the contents of the message panel
		message()		This will reset the text of the message panel to the text that is passed as an argument.
		error()			This methods performs the same as "message()", but also sets the background of
						the message panel to a red colour.
	The second panel is controlled by the "setUser()" method, this method accepts a user ID and a user name.
		The user id is displayed in the panel and the user name is displayed as a tooltip.
	The third panel is controlled by the "setCompany" method.  This method accepts a company ID and a company name.
		The company id is displayed in the panel and the company name is displayed as a tooltip.
*/


function StatusBar()
{
	this.clear		=	StatusBar_clear;
	this.message	=	StatusBar_message;
	this.error		=	StatusBar_error;
	this.setCompany	=	StatusBar_setCompany;
	this.setUser	=	StatusBar_setUser;
	this.setPrinter	=	StatusBar_setPrinter;
	this.makeString	=	StatusBar_makeString;
	this.showPrinter=	StatusBar_showPrinter;
	this.hidePrinter=	StatusBar_hidePrinter;
	this.getPrinter =	StatusBar_getPrinter;
	this.flgDoBeep  =   true;
	this.flgHadInvalidMessage = false;
}

function StatusBar_clear() 
{
	this.message("");
}

function StatusBar_message()
{
	var objSB = window.document.getElementById("sbmessage");
	
	if (objSB == null)
		return;

	objSB.className = "normal";
	objSB.innerHTML = this.makeString(arguments);
}

function StatusBar_error()
{
	var objSB = window.document.getElementById("sbmessage");

	if (objSB != null) {
		objSB.className = "error";
		objSB.innerHTML = this.makeString(arguments);
	}
	
	if (m_blnWindowOnBeforeUnload)
	{
		if (this.flgHadInvalidMessage == false)
		{
			this.flgHadInvalidMessage = true;
			eMsgBox(fl("FORMISINVALID"), 0, msg_Exclamation, window);
		}
	}
	else
	{
		if (this.flgDoBeep)
			objApplication.EfacsApplet.beep();
	}

	return false;
}

function StatusBar_setCompany(strCompanyID, strCompanyDescription)
{
	var objSB = window.document.getElementById("sbcompany");
	
	if (objSB == null)
		return;

	objSB.innerHTML = strCompanyID;
	objSB.title = strCompanyDescription;
}

function StatusBar_setUser(strUserID, strUserName)
{
	var objSB = window.document.getElementById("sbuser");
	
	if (objSB == null)
		return;

	objSB.innerHTML = strUserID;
	objSB.title = strUserName;
}

function StatusBar_setPrinter(strPrinterID, strPrinterDesc)
{
	var objSB = window.document.getElementById("sbprinter");
	
	if (objSB == null)
		return;
		
	objSB.innerHTML = "Current printer: " + strPrinterID;
	objSB.title = strPrinterDesc;
}

function StatusBar_makeString(args) 
{
	var strMessage = objDict.getString(args[0]);
	if (strMessage != null)
		args[0] = strMessage;

	return processArgs(args);
}

function StatusBar_getPrinter()
{
	var objSB = window.document.getElementById("sbprinter");
	
	if (objSB == null)
		return "";
		
	return objSB.innerHTML.substring(17, objSB.innerHTML.length)
}

function StatusBar_showPrinter()
{
	var objSB = window.document.getElementById("sbprinter");
	
	if (objSB == null)
		return;

	objSB.style.visibility = "visible";
}

function StatusBar_hidePrinter()
{
	var objSB = window.document.getElementById("sbprinter");
	
	if (objSB == null)
		return;

	objSB.style.visibility = "hidden";
}


	

var TAB_WITHOUTCLICKEVENT = 0x1;

/** 
 * Constructor for the Tab object
 *
 * @param objTabbedDialog The tabbed dialog on which this tab exists.
 * @param strRef The tab id.
 * @param objButton The HTML button object reference.
 * @param intIndex The tab position index.
 */
function Tab(objTabbedDialog, strRef, objButton, intIndex)
{
// properties
	this.objTabbedDialog	= objTabbedDialog;
	this.strRef				= strRef;
	this.HTMLButton			= objButton;
	this.index				= intIndex;
	this.onclick			= null;

// methods
	this.toXML				= DialogTab_toXML;
	this.select				= DialogTab_select;
	this.hasFocus			= DialogTab_hasFocus;
	this.hide				= DialogTab_hide;
	this.show				= DialogTab_show;
	this.disable			= DialogTab_disable;
	this.enable				= DialogTab_enable;
	this.performADAPTScript = DialogTab_performADAPTScript;
	this.isVisible			= DialogTab_isVisible;
	this.isEnabled			= DialogTab_isEnabled;
	this.setCaption			= DialogTab_setCaption;
	this.destroy			= DialogTab_destroy;
}

/** 
 * Used by ADAPT - returns a tree formatted xml representation of this object.
 *
 * @return The tree formatted xml representation of this object.
 */
function DialogTab_toXML()
{
	var strUID = this.objTabbedDialog.id + "_" + this.strRef;
	
	var strXML = "<node uid='" + strUID + "' level='4'>";
	strXML += "<vals>";
	strXML += "<val id='label'>" + this.strRef + "</val>";
	strXML += "<val id='name'>" + this.strRef + "</val>";
	strXML += "<val id='event1' parameter-name='objTab'>onBeforeSelectTab</val>";
	strXML += "<val id='event2' parameter-name='objTab'>onAfterSelectTab</val>";
	strXML += "</vals>";
	strXML += "</node>";

	return strXML;
}

/** 
 * Makes the selected tab display to the screen.
 */
function DialogTab_select() 
{
	// Store the height of the tab - can be used to determine the height of the document tab if necessary.
	var objCurTab = this.objTabbedDialog.getCurrentTab();

	if (objCurTab != null && objCurTab.HTMLButton != null) {
		this.objTabbedDialog.tabHeight = objCurTab.HTMLButton.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.tBodies[0].offsetHeight;
	}

  	var objTab = objApplication.browser == APPLICATION_IE ? this.HTMLButton : this.HTMLButton.nextSibling;
  	
  	// This will set all tabs to be de-selected
	this.objTabbedDialog.disableAllTabButtons();

	var strTabStyle = "";
	if (objTab.className.indexOf("eNotes") != -1) {
		strTabStyle = "eNotes";		
	} else if (objTab.className.indexOf("documents") != -1) {
		strTabStyle = "documents";
	}

	if (this.objTabbedDialog.buttonAlignment & TABBEDDIALOG_ALIGNBOTTOM) {
		objTab.className = strTabStyle + "tabdActive " + strTabStyle + "tabdActiveBorderBottom";
	} else {
		objTab.className = strTabStyle + "tabdActive " + strTabStyle + "tabdActiveBorder";
	}

	// Find TABLE BODY element...
	var objTable = getParentElement(this.HTMLButton, "TABLE");
	var objTBody = getParentElement(objTable.parentNode, "TABLE").tBodies[0];

	var intCurrentPage = 1;
	var objTR;

	for (var n = 0; n < objTBody.childNodes.length; n++)
	{
		objTR = objTBody.childNodes.item(n);			
								
		if (objTR.nodeType == 3)	// ignore text node (looking for elements)
			continue;

		if (intCurrentPage++ == this.index)
			objTR.style.display = "inline";
		else 
			objTR.style.display = "none";
	}

	// Currently there is only one optional event but any further ones will go in the below logic test
	var flgWithoutClick = false;
	if (arguments.length == 1) {
		var intArgVal = parseInt(arguments[0]);
		flgWithoutClick =  ((intArgVal & TAB_WITHOUTCLICKEVENT) != 0);
	}
	
	if (flgWithoutClick == false) {
		if (this.onclick != null) {
			var methodNames = this.onclick.split(" ");
			
			for (var index = 0; index < methodNames.length; index++) {
				var methodName = methodNames[index];
				
				if (methodName.indexOf(".") == -1) {
					var groups = methodNames[index].match(/\([^\)]+\)/);
					
					if (groups && groups.length > 0) {
						eval("window." + methodNames[index]);
					} else {
						window[methodNames[index].replace(/(\(\));*/, "")](objTab);
					}
				} else {
					var evalFunction = new Function(methodName);
					evalFunction();
				}
			}
		}
	}

	// Added try/catch as some elements do not support focus under Netscape
	try {
		this.objTabbedDialog.HTMLElement.focus();
	} catch(error) {
	}

	this.objTabbedDialog.objWindow.localResize()
}

/** 
 * Does this tab have the focus.
 *
 * @return true is tab has focus - false if not.
 */
function DialogTab_hasFocus()
{
  	var objTab = objApplication.browser == APPLICATION_IE ? this.HTMLButton : this.HTMLButton.nextSibling;
  	
	if (objTab.className.indexOf("tabdActive") != -1)
		return true;
	else
		return false;
}

/** 
 * Hides this tab.
 */
function DialogTab_hide()
{
	var objTR = this.HTMLButton.parentNode;
	var objTab = objApplication.browser == APPLICATION_IE ? this.HTMLButton : this.HTMLButton.nextSibling;
	
	// Suppress the tab
	objTab.style.display = "none";
	
	// Need to suppress the space on the right of the tab(only do this if not last tab)
	var spacerToSuppress = ((this.index - 1) * 2) + 1;
	if (spacerToSuppress != objTR.childNodes.length - 1)
		objTR.childNodes.item(spacerToSuppress).style.display = "none";
}

/** 
 * Unhides this tab.
 */
function DialogTab_show()
{
	var objTR = this.HTMLButton.parentNode;
	var objTab = objApplication.browser == APPLICATION_IE ? this.HTMLButton : this.HTMLButton.nextSibling;
	
	// Show the tab
	objTab.style.display = "inline";
	
	// Need to show the space on the right of the tab(only do this if not last tab)
	var spacerToSuppress = ((this.index - 1) * 2) + 1;
	if (spacerToSuppress != objTR.childNodes.length - 1)
		objTR.childNodes.item(spacerToSuppress).style.display = "inline";
}

/**
 * Determines whether this tab is currently visible
 * @return true is currently visible, otherwise false
 */
function DialogTab_isVisible()
{
	var objTab = objApplication.browser == APPLICATION_IE ? this.HTMLButton : this.HTMLButton.nextSibling;
	
	if (objTab.style.display == "none")
		return false;
	else
		return true;
}

/** 
 * Disables this tab.
 */
function DialogTab_disable()
{
	if (objApplication.browser == APPLICATION_IE)
	this.HTMLButton.disabled = true;
	else
		this.HTMLButton.nextSibling.disabled = true;
}

/** 
 * Enables this tab.
 */
function DialogTab_enable()
{
	if (objApplication.browser == APPLICATION_IE)
	this.HTMLButton.disabled = false;
	else
		this.HTMLButton.nextSibling.disabled = false;
}

/**
 * Determines whether the tab is currently enabled
 * @return true if the tab is enabled, otherwise false.
 */
function DialogTab_isEnabled()
{
	var objTab = objApplication.browser == APPLICATION_IE ? this.HTMLButton : this.HTMLButton.nextSibling;
	
	if (objTab.disabled == false)
		return true;
	else
		return false;
}

/** 
 * Fires any attached ADAPT javascript.
 *
 * @param flgEventType Binary operator parameter determines which event to fire.
 * @return Returns false if the adapt javascript decided to cancel the event.
 */
function DialogTab_performADAPTScript(flgEventType)
{
	var strMethodName;

	if (flgEventType & ADAPT_ONBEFORESELECTTAB) {
		strMethodName = this.strRef + "_onBeforeSelectTab";
	} else if (flgEventType & ADAPT_ONAFTERSELECTTAB) {
		strMethodName = this.strRef + "_onAfterSelectTab";
	} else {
		alert("Tabbed dialog event type not supported");
	}

	// This should only be an issue with dynamically created ids e.g. those generated from the company id
	// for multi company tabs.
	var regEx = / /g;
	strMethodName = strMethodName.replace(regEx, "_");
	
	if (typeof(strMethodName) != "undefined" && this.objTabbedDialog.objWindow[strMethodName] != null) {
		if (this.objTabbedDialog.objWindow[strMethodName](this) == false) {
			return false;
		}
	}
	
	return true;
}

/**
 *	Sets the caption for a tab.
 *	@param	caption label
 */
function DialogTab_setCaption(strLabel)
{
	this.HTMLButton.children[0].children[0].innerHTML = strLabel;
}

/**
 * Clear references to the tab object
 */
function DialogTab_destroy() {
	try {
		this.objTabbedDialog	= null;
		this.strRef				= null;
		if (this.HTMLButton != null) {
			this.HTMLButton.onclick = null;
			this.HTMLButton.onfocus = null;
			this.HTMLButton.onblur = null;
			this.HTMLButton.onmousedown = null;
			this.HTMLButton.onmouseup = null;
			this.HTMLButton.onmouseover = null;
			this.HTMLButton.onkeypress = null;
			this.HTMLButton.onkeydown = null;
			this.HTMLButton.onkeyup = null;
			this.HTMLButton.onmouseout = null;
			
			if (this.HTMLButton.firstChild != null) {
				this.HTMLButton.firstChild.onclick = null;
				this.HTMLButton.firstChild.onfocus = null;
				this.HTMLButton.firstChild.onblur = null;
				this.HTMLButton.firstChild.onmousedown = null;
				this.HTMLButton.firstChild.onmouseup = null;
				this.HTMLButton.firstChild.onmouseover = null;
				this.HTMLButton.firstChild.onkeypress = null;
				this.HTMLButton.firstChild.onkeydown = null;
				this.HTMLButton.firstChild.onkeyup = null;
				this.HTMLButton.firstChild.onmouseout = null;
			}
			this.HTMLButton			= null;
		}
		this.onclick			= null;
	} catch (error) {
	}
}



// ADAPT constants.
var ADAPT_ONBEFORESELECTTAB = 0x1;
var ADAPT_ONAFTERSELECTTAB = 0x2;

// Alignment constants.
var TABBEDDIALOG_ALIGNTOP = 0x1;
var TABBEDDIALOG_ALIGNBOTTOM = 0x2;
var TABBEDDIALOG_ALIGNLEFT = 0x4;
var TABBEDDIALOG_ALIGNRIGHT = 0x8;

/** 
 * Constructor for the TabbedDialog object
 *
 * @param objElement The TABLE element containing the tabbed-dialog HTML.
 * @param objWindow The window object.
 */
function TabbedDialog(objElement, objWindow) 
{
// properties
	this.HTMLElement			= objElement;			// HTML container that contains the tabbed-dialog
	this.id						= objElement.id;
	this.buttonAlignment		= TABBEDDIALOG_ALIGNTOP;
	this.arrTabs				= new Array();
	this.TextEditor				= null;
	this.strTextTab				= null;
	this.objWindow				= objWindow;

	this.strDocumentTab			= null;
	this.documentQuery          = null;
	this.EditWindowManager		= null;	
	this.documentManager		= null;
	this.documentEWM			= null;
	this.tabHeight				= 0; // Used to determine the height of the documents tab where there are multiple controls on the window
	
// methods
	this.toXML					= TabbedDialog_toXML;
	this.switchPage				= TabbedDialog_switchPage;
	this.disableAllTabButtons	= TabbedDialog_disableAllTabButtons;
	this.getTabByButtonObjRef	= TabbedDialog_getTabByButtonObjRef;
	this.getTab					= TabbedDialog_getTab;
	this.addTab					= TabbedDialog_addTab;
	this.getCurrentTab			= TabbedDialog_getCurrentTab;
	this.getNextTab				= TabbedDialog_getNextTab;
	this.getPreviousTab			= TabbedDialog_getPreviousTab;
	this.hide					= TabbedDialog_hide;
	this.show					= TabbedDialog_show;
	this.doOnKeyDown			= TabbedDialog_doOnKeyDown;
	this.destroy				= TabbedDialog_destroy;
}

/** 
 * Used by ADAPT - returns an tree formatted xml representation of this object.
 *
 * @return The tree formatted xml representation of this object.
 */
function TabbedDialog_toXML()
{
	var strUID = this.id.replace("tabd", "");
	
	var strXML = "<node uid='" + strUID + "' level='3' open='false' fire-onclick='true'>";
	strXML += "<vals>";
	strXML += "<val id='label'>" + strUID + "</val>";
	strXML += "<val id='name'>" + strUID + "</val>";
	strXML += "</vals>";
	
	if (this.arrTabs.length > 0)
	{
		var strTabs = "";
	
		// TABBED DIALOG TABS
		for (var intCtr = 0; intCtr < this.arrTabs.length; intCtr++)
		{
			var strTabXML = this.arrTabs[intCtr].toXML();
			if (strTabXML != null)
				strTabs += strTabXML;
		}

		if (!isBlank(strTabs))
			strXML += "<nodes>" + strTabs + "</nodes>";
	}

	// End toolbar node.
	strXML += "</node>";

	return strXML;
}

/** 
 * Switches to another tab.
 *
 * @param objButton The HTML button element for the tab being switched to
 */
function TabbedDialog_switchPage(objButton) 
{
	var objTab = this.getTabByButtonObjRef(objButton);

	var retVal = objTab.performADAPTScript(ADAPT_ONBEFORESELECTTAB);
	if (retVal == false)
		return;
	
	objTab.select();	
	
	if (objTab.strRef == this.strTextTab)
	{
		if (! this.TextEditor.isNotesDirty())
			this.EditWindowManager.loadNotes(this.TextEditor, this.objWindow);
	}
	if (objTab.strRef == this.strDocumentTab){
		this.documentManager.loadDocuments(this.objWindow);
	}	

	objTab.performADAPTScript(ADAPT_ONAFTERSELECTTAB);
}

/** 
 * Switches to another tab.
 *
 * @param objButton The HTML button element for the tab being switched to
 */
function TabbedDialog_dynamicSwitchPage(objEvent) 
{
	if (objEvent == null)
		objEvent = window.event;

	var objTD = objEvent.srcElement;
	if (objTD.tagName != "TD")
		objTD = objTD.parentNode.parentNode;
	
	var objTable = getParentElement(getParentElement(objTD, "TABLE").parentNode, "TABLE");
	var objTabbedDialog = eval(objTable.id.replace("tabd", ""));
	objTabbedDialog.switchPage(objTD);
}

/** 
 * Disables all tab buttons.
 */
function TabbedDialog_disableAllTabButtons()
{
	var objTab;
	var objTabCompare;
	
	for (var intCtr=0; intCtr < this.arrTabs.length; intCtr++)
	{
		objTab = this.arrTabs[intCtr];
		objTabCompare = objApplication.browser == APPLICATION_IE ? objTab.HTMLButton : objTab.HTMLButton.nextSibling;
		
		var strTabStyle = "";
		if (objTabCompare.className.indexOf("eNotes") != -1) {
			strTabStyle = "eNotes";		
		} else if (objTabCompare.className.indexOf("documents")!= -1) {
			strTabStyle = "documents";
		}
		
		objTabCompare.className = strTabStyle + "tabdInactive";	
	}
}

/** 
 * Returns a tab reference for the HTML button object passed.
 *
 * @param objButton The HTML button element.
 * @return The Tab object reference.
 */
function TabbedDialog_getTabByButtonObjRef(objButton)
{
	var objTab;
	var objTabCompare;
	
	for (var intCtr=0; intCtr < this.arrTabs.length; intCtr++)
	{
		objTab = this.arrTabs[intCtr];
		objTabCompare = objApplication.browser == APPLICATION_IE ? objTab.HTMLButton : objTab.HTMLButton.nextSibling;
			
		if (objTabCompare == objButton)
			return objTab;
	}
}

/** 
 * Returns a tab reference for tab id reference passed.
 *
 * @param strRef The tab id.
 * @return The Tab object reference.
 */
function TabbedDialog_getTab(strRef)
{
	var objTab;
	
	for (var intCtr=0; intCtr < this.arrTabs.length; intCtr++)
	{
		objTab = this.arrTabs[intCtr];
		if (objTab.strRef == strRef)
			return objTab;
	}
}

/** 
 * Dynamically adds a new tab to the tabbed dialog.
 *
 * @param strRef The tab id.
 * @param objButton The HTML button object.
 * @param intIndex The position index for the new tab.
 */
function TabbedDialog_addTab(strRef, objButton, intIndex) 
{
	if (objButton != null)
	{
		var objNewTab = new Tab(this, strRef, objButton, intIndex);
		this.arrTabs[this.arrTabs.length] = objNewTab;
		return objNewTab;
	}
	else
	{
		var objTR = this.HTMLElement.tHead.rows[0].cells[0].firstChild.tBodies[0].rows[0];
		var objTD = objTR.insertCell();
		
		// Set previous tab spacer class to not expand to 100%.
		if (objTD.cellIndex > 1)
		{
			var objPreviousTD = objTR.cells[objTD.cellIndex - 1];
			objPreviousTD.className = "Spacer";
			objPreviousTD.removeAttribute("width");
			objPreviousTD.firstChild.style.marginLeft = "0px";
			objPreviousTD.firstChild.style.marginRight = "5px";
		}
		
		// Sets up the new tabbed dialog TD which contains the tab BUTTON.
		objTD.noWrap = true;
		objTD.className = "tabdInactive";
		objTD.id = "tab" + strRef;
		addEvent(objTD, "onclick", TabbedDialog_dynamicSwitchPage);
		
		var objDiv = document.createElement("DIV");
		objDiv.noWrap = true;
		addEvent(objDiv, "onmouseover", TabbedDialog_mouseover);
		addEvent(objDiv, "onmouseout", TabbedDialog_mouseout);

		var objLabel = document.createElement("LABEL");
		objLabel.style.paddingLeft = "7px";
		objLabel.style.paddingRight = "6px";
		objLabel.style.paddingTop = "1px";
		objLabel.style.margin = "0px";
		objLabel.style.height = "16px";
		objLabel.className = "toolbar-button-label";
		objLabel.innerHTML = strRef;
		objDiv.appendChild(objLabel);
		objTD.appendChild(objDiv);
		
		// Creates the tab spacer TH.
		var objSpacerTD = objTR.insertCell();
		objSpacerTD.width = "100%";
		objSpacerTD.className = "tabdNoTab";
		var objSpan = document.createElement("SPAN");
		objSpan.style.marginLeft = "1px";
		objSpacerTD.appendChild(objSpan);

		// Creates the body section for the tabbed dialog.
		objTR = this.HTMLElement.tBodies[0].insertRow();
		objTR.style.display = "none";
		objTR.style.width = "100%";
		objTR.style.height = "100%";
		objTR.name = "TabRow";
		objBodyTD = objTR.insertCell();
		objBodyTD.className = "tabdContent";
		objBodyTD.vAlign = "top";
		var objEmptyDiv = document.createElement("DIV");
		objEmptyDiv.id = "tabBodyDiv" + strRef;
		objBodyTD.appendChild(objEmptyDiv);

		var objNewTab = new Tab(this, strRef, objTD, this.arrTabs.length + 1);
		this.arrTabs[this.arrTabs.length] = objNewTab;
		return objNewTab;
	}
}

/**
 * Gets a reference to the currently selected tab in the tabbed dialog.
 */
function TabbedDialog_getCurrentTab() 
{
	for (var intCtr = 0, intLen = this.arrTabs.length; intCtr < intLen; intCtr++)
	{
		var objTab = this.arrTabs[intCtr];
		if (objTab.hasFocus())
		{
			return objTab;
			break;
		}
	}	
	return null;
}

/**
 * Hides the tabbed dialog
 * @param flgDoResize If false does not perform localResize, otherwise localResize is called
 */
function TabbedDialog_hide(flgDoResize) 
{
	this.HTMLElement.style.display = "none";

	if (flgDoResize != false)
		localResize();
}

/**
 * Shows the tabbed dialog
 * @param flgDoResize If false does not perform localResize, otherwise localResize is called
 */
function TabbedDialog_show(flgDoResize) 
{
	this.HTMLElement.style.display = "inline";

	if (flgDoResize != false)
		localResize();
}

/**
 *	Hides the tabbed dialog
 */
 function TabbedDialog_hide()
 {
	 this.HTMLElement.style.display = "none";
 }
 
 
/** 
 * Changes the background colour to highlight the passed button.
 *
 * @param objElement The HTML element containing the button to highlight.
 */
function TabbedDialog_mouseover(objElement)
{
	if (objElement.srcElement != null)
		objElement = objElement.srcElement;

	objElement.style.backgroundColor = "#FFD497";
}

/** 
 * Changes the background colour to unhighlight the passed button.
 *
 * @param objElement The HTML element containing the button to unhighlight.
 */
function TabbedDialog_mouseout(objElement)
{
	if (objElement.srcElement != null)
		objElement = objElement.srcElement;

	objElement.style.backgroundColor = "transparent";
}

/** 
 * If CTRL TAB is pressed then switch tabs.
 *
 * @param objEvent The keydown event object.
 */
function TabbedDialog_doOnKeyDown(objEvent)
{
	if (objEvent == null)
		objEvent = window.event;

	if (objEvent == null)
		return;

	if (objEvent.keyCode == 9 && objEvent.ctrlKey == true)
	{
		var objTab = null;
		if (objEvent.shiftKey == false)
			objTab = this.getNextTab();
		else
			objTab = this.getPreviousTab();
			
		if (objTab != null)
			objTab.select();

		objEvent.returnValue = false;
		objEvent.cancelBubble = true;
	}
}

/**
 * Gets a reference to the next visible, enabled tab in the tabbed dialog.
 *
 * @return Rererence to the next tab.
 */
function TabbedDialog_getNextTab() 
{
	for (var intCtr = 0, intLen = this.arrTabs.length; intCtr < intLen; intCtr++)
	{
		if (this.arrTabs[intCtr].hasFocus())
		{
			var objRetTab = this.arrTabs[(intCtr + 1) % intLen];

			// The loop counter is to avoid infinite loops
			var intLoopCtr = 0;
			var intIndex;
			while (!objRetTab.isVisible() || !objRetTab.isEnabled())
			{
				intIndex = (intCtr + 1) % intLen;
				objRetTab = this.arrTabs[intIndex];
				intCtr++;
				intLoopCtr++;
				
				if (intLoopCtr > intLen)
				{
					objRetTab = null;
					break;
				}
			}
			return objRetTab;
		}
	}	
	return null;
}

/**
 * Gets a reference to the previous visible, enabled tab in the tabbed dialog.
 *
 * @return Rererence to the previous tab.
 */
function TabbedDialog_getPreviousTab() 
{
	for (var intCtr = 0, intLen = this.arrTabs.length; intCtr < intLen; intCtr++)
	{
		if (this.arrTabs[intCtr].hasFocus())
		{
			var intIndex = (intCtr - 1) % intLen;
			if (intIndex < 0)
				intIndex += intLen;
			var objRetTab = this.arrTabs[intIndex];

			// The loop counter is to avoid infinite loops
			var intLoopCtr = 0;
			while (!objRetTab.isVisible() || !objRetTab.isEnabled())
			{
				intIndex = (intCtr - 1) % intLen;
				if (intIndex < 0)
					intIndex += intLen;
				objRetTab = this.arrTabs[intIndex];
				intCtr--;
				intLoopCtr++;
				
				if (intLoopCtr  > intLen)
				{
					objRetTab = null;
					break;
				}
			}
			return objRetTab;
		}
	}	
	return null;
}

/**
 * Clear references to the tabbed dialog object
 */
function TabbedDialog_destroy() {
	try {
		this.id						= null;
		if (this.arrTabs != null) {
			for (var i = 0, len = this.arrTabs.length; i < len; i++) {
				this.arrTabs[i].destroy();
				this.arrTabs[i] = null;
			}
		}
		this.arrTabs				= new Array();

		this.TextEditor				= null;
		this.strTextTab				= null;
		this.strDocumentTab			= null;

		if (this.documentQuery != null) {
			this.documentQuery.destroy();
			this.documentQuery = null;
		}
		this.EditWindowManager		= null;
		
		if (this.documentManager != null) {
			this.documentManager.destroy();
			this.documentManager = null;
		}

		this.documentEWM			= null;

		if (this.HTMLElement != null) {
			if (this.HTMLElement.tHead != null) {
				if (this.HTMLElement.tHead.rows != null && this.HTMLElement.tHead.rows[0] != null) {
					if (this.HTMLElement.tHead.rows[0].cells != null && this.HTMLElement.tHead.rows[0].cells[0] != null) {
						if (this.HTMLElement.tHead.rows[0].cells[0].firstChild != null) {
							if (this.HTMLElement.tHead.rows[0].cells[0].firstChild.tBodies != null && this.HTMLElement.tHead.rows[0].cells[0].firstChild.tBodies[0] != null) {
								if (this.HTMLElement.tHead.rows[0].cells[0].firstChild.tBodies[0].rows != null && this.HTMLElement.tHead.rows[0].cells[0].firstChild.tBodies[0].rows[0] != null) {
									if (this.HTMLElement.tHead.rows[0].cells[0].firstChild.tBodies[0].rows[0].cells != null) {
										for (var i = 0, len = this.HTMLElement.tHead.rows[0].cells[0].firstChild.tBodies[0].rows[0].cells.length; i < len; i++) {
											if (this.HTMLElement.tHead.rows[0].cells[0].firstChild.tBodies[0].rows[0].cells[i] != null) {
												this.HTMLElement.tHead.rows[0].cells[0].firstChild.tBodies[0].rows[0].cells[i].onclick = null;
												if (this.HTMLElement.tHead.rows[0].cells[0].firstChild.tBodies[0].rows[0].cells[i].children != null && 
													this.HTMLElement.tHead.rows[0].cells[0].firstChild.tBodies[0].rows[0].cells[i].children[0] != null) {
													this.HTMLElement.tHead.rows[0].cells[0].firstChild.tBodies[0].rows[0].cells[i].children[0].onmouseover = null;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			this.HTMLElement.onkeydown = null;
			this.HTMLElement = null;
		}

		if (this.objWindow != null && this.objWindow.document != null && this.objWindow.document.body != null) {
			this.objWindow.document.body.onclick = null;
			this.objWindow.document.body.onfocus = null;
			this.objWindow.document.body.onblur = null;
			this.objWindow.document.body.onmousedown = null;
			this.objWindow.document.body.onmouseup = null;
			this.objWindow.document.body.onmouseover = null;
			this.objWindow.document.body.onkeypress = null;
			this.objWindow.document.body.onkeydown = null;
			this.objWindow.document.body.onkeyup = null;
		}
		this.objWindow = null;	

		this.tabHeight				= 0;
	} catch(error) {
	}
}


	
/**
 * TextEditor constructor.
 * 
 * @param id Unique id string for this text editor.
 * @param emediaID Associated business object name.
 * @param tabDialog Reference to the tabbed dialog (if there is one) on which these eNotes exist.
 * @param objWindow Reference to window object where these eNotes exist.
 */
function TextEditor(id, emediaID, tabDialog, objWindow) {
// properties: -
	this.emediaID = String(emediaID).toLowerCase();
	this.previousEmediaID;
	this.XMLTypes = null;
	this.XMLDetail = objApplication.createXMLDocument();
	this.cmbFont = null;
	this.cmbSize = null;
	this.cmbTextType = null;
	this.btnEditorMode = null;

	this.appletReady = false;
	this.id = id;
	this.objToolbar = null;
	this.objWindow = objWindow;

	this.keys = new Array();
	this.keys[0] = "";
	this.keys[1] = "";
	this.keys[2] = "";
	this.keys[3] = "";

	this.flgLoaded = false;
	this.flgKeySet = false;
	this.flgEditorDisplay = true;
	this.flgInInitialisedState = false;
	this.EditWindowManager = null;	
	
	this.objEditor = null;
	this.strOriginalNotes = "";	// Original text if eNotes when they are loaded from DB. Used for isNotesDirty()

	this.unsavedNotes = false; // This is only ever set by an editWindow when unsaved notes are forced to display
	this.tabbedDialogID = tabDialog;

	this.flgNoEmedia = false;
	this.standAloneHTML = "";
	this.sTextType = "";
	
	// This variable used to circumvent the default formatting of IE therefore stores the preview mode text in its original form.
	this.strPreviewText = "";

// methods: -	
	this.initialise = TEinitialise;
	this.performOperation	= TEperformOperation;
	this.setComboTextType = TEsetComboTextType;
	this.getEmediaTypes = TEgetEmediaTypes;
	this.setKeyValue = TEsetKeyValue;
	this.setSpecificKeyValue = TEsetSpecificKeyValue;
	this.clearKeyValues = TEclearKeyValues;
	this.setTextType = TEsetTextType;
	this.loadDetail = TEloadDetail;
	this.loadDetailZ = TEloadDetailZ;
	this.saveText = TEsaveText;
	this.tableInsert = TETableInsert;
	this.libraryTextLink = TELibraryTextLink;
	this.hyperTextLink = TEHyperTextLink;
	this.imageLink = TEImageLink;
	this.isNotesDirty = TEisNotesDirty;
	this.changeEditorMode = TEchangeEditorMode;
	this.displayDiv = TEdisplayDiv;
	this.setNotesText = TEsetNotesText;
	this.initialiseApplet = TEinitialiseApplet;
	this.hideEditModeToolbar = TEhideEditModeToolbar;
	this.setReadOnly = TEsetReadOnly;
	this.prepareForSave = TEprepareForSave;
	this.pickColourRGB = TEPickColourRGB;
	this.pickColourHex = TEPickColourHex;
	this.processText = TEprocessText;
	this.storeText	= TEstoreText;
	this.textRemoved = TEtextRemoved;
	this.emptyNotesXML = TEemptyNotesXML;
	this.getDataCompareText = TEgetDataCompareText;
	this.isCorrectKeyValuesSet = TEisCorrectKeyValuesSet;
	this.isNewRecord = TEisNewRecord;
	this.destroy = TEdestroy;
}

/**
 * Initialises text editor object and sets up required references.
 *
 * @param flgAutoEnotes True when called architecturally from ewm - null or false otherwise.
 *        Allows reinitialisation of editor control for manually managed eNotes.
 */
function TEinitialise()
{
	this.cmbFont = this.objWindow.document.getElementById(this.id + "cmbFont");
	this.cmbSize = this.objWindow.document.getElementById(this.id + "cmbSize");
	this.cmbTextType = this.objWindow.document.getElementById(this.id + "cmbTextType");
	this.btnEditorMode = this.objWindow.document.getElementById(this.id + "btnEditorMode");

    if (this.flgNoEmedia)
    {
        this.cmbTextType.style.visibility = "hidden";
        this.cmbTextType.parentNode.previousSibling.previousSibling.style.visibility = "hidden";
    }
    else
    {
        this.cmbTextType.style.visibility = "visible";
        this.cmbTextType.parentNode.previousSibling.previousSibling.style.visibility = "visible";
    }

	if (this.objEditor == null)
	{
		if (objApplication.Modules("0023a-editpte"))
			this.objEditor = new LicencedEditor(this);
		else
		{
			if (objApplication.browser == APPLICATION_IE)
				this.objEditor = new IEEditor(this);
			else
				this.objEditor = new EfacsEditor(this);
		}
	}

	if(!this.flgInInitialisedState || (this.previousEmediaID != this.emediaID))
	{		
		this.flgLoaded = false;
		this.getEmediaTypes();
		this.sTextType = this.cmbTextType.options[this.cmbTextType.selectedIndex].text;
		this.flgReloadText = false;
		
		this.btnEditorMode.innerHTML = "Edit mode";
		this.loadDetailZ(this.sTextType);
		this.displayDiv();
		this.unsavedNotes = false;
	}
	else if (!this.flgLoaded)
	{
		this.loadDetailZ(this.sTextType);
		this.displayDiv();
		this.unsavedNotes = false;	
	}
}

/**
 * Initialises applet required and takes a reference to the IE edit div if used.
 */
function TEinitialiseApplet()
{
	if (!this.flgInInitialisedState || (this.previousEmediaID != this.emediaID))
		this.objWindow.document.getElementById(this.id + "_notes_div").innerHTML = this.objEditor.createEditorHTML();

	this.objEditor.appletElement = this.objWindow.document.getElementById(this.id + "_notes");
	this.objEditor.editDiv = this.objWindow.document.getElementById(this.id + "_notes_div_edit");
	
	//Add an onkeydown event and an onmouseout event to the actual appletElement, so text is saved to island.
	//-- These events are used when the applet version of the editor is in use.--
	if (this.objEditor.appletElement != null){
		addEvent(this.objEditor.appletElement, "onkeydown", ee_storeText);
		addEvent(this.objEditor.appletElement, "onmouseout", ee_storeText);
		addEvent(this.objEditor.appletElement, "onblur", ee_storeText);
	}
		
	TEeditorReady(this);
	flgSetOriginalNotes = true;
}

/**
 * Waits for applets to load.
 *
 * @param id The text editor object id.
 */
function TEeditorReady(objTextEditor)
{
	objTextEditor.appletReady = true;
	objTextEditor.performOperation(objTextEditor.objWindow, "changetexttype");
	objTextEditor.loadDetailZ(objTextEditor.cmbTextType.options[objTextEditor.cmbTextType.selectedIndex].text);
	objTextEditor.objEditor.setCombos();
	objTextEditor.strOriginalNotes = objTextEditor.objEditor.getText();
	flgSetOriginalNotes = true;
	objTextEditor.flgLoaded = true;
	objTextEditor.flgInInitialisedState = true;
}

/**
 * Perform a specific text editor command.
 *
 * @param AppWindow The window containing the text editor.
 * @param strCommand The text editor command to be performed.
 */
function TEperformOperation(AppWindow, strCommand) 
{
	if(strCommand == "changeeditormode"){
		this.changeEditorMode();
		return;
	}
	else if(strCommand == "changetexttype")
	{
		this.loadDetailZ(this.cmbTextType.options[this.cmbTextType.selectedIndex].text);
	}
		
	if(this.appletReady == false) return;

	if(strCommand == "bold")
		this.objEditor.bold();
	else if(strCommand == "italic")
		this.objEditor.italic();
	else if(strCommand == "underline")
		this.objEditor.underline();
	else if(strCommand == "colourselector")
	{
		AppWindow.setColourPickerValueRGB = new Function("r", "g", "b", this.id + ".pickColourRGB(r, g, b);");
		AppWindow.setColourPickerValueHex = new Function("hexValue", this.id + ".pickColourHex(hexValue);");

		var strFeatures = "directories=no, location=no, menubar=no,";
		strFeatures += " scrollbars=no, status=no, titlebar=no,";
		strFeatures += " toolbar=no, resizable=no";
		strFeatures += " left=" + event.screenX + ", top=" + event.screenY;
		strFeatures += " height=267, width=223";

		objApplication.openChildWindow(AppWindow, "../Applications_HTML/appColourPicker.html", null, strFeatures);
	}
	else if(strCommand == "cut")
		this.objEditor.cut();
	else if(strCommand == "paste")
		this.objEditor.paste();
	else if(strCommand == "copy")
		this.objEditor.copy();
	else if(strCommand == "justifyleft")
		this.objEditor.alignLeft();
	else if(strCommand == "justifyright")
		this.objEditor.alignRight();
	else if(strCommand == "justifycenter")
		this.objEditor.alignCenter();
	else if(strCommand == "inserttable")
		objApplication.openChildWindow(AppWindow, "../Applications_HTML/appTextEditorInsertTable.html?id=" + this.id, "window");
	else if(strCommand == "image")
		// Open the edit HTML page with this record.
		objApplication.openChildWindow(AppWindow, "../Applications_HTML/appTextEditorImage.html?id=" + this.id, "window");
	else if(strCommand == "link")
		// Open the edit HTML page with this record.
		objApplication.openChildWindow(AppWindow, "../Applications_HTML/appTextEditorHyperTextLink.html?id=" + this.id, "window");
	else if(strCommand == "library") {
		// Open the edit HTML page with this record.
		objApplication.openChildWindow(AppWindow, "../Applications_HTML/appTextEditorLibrary.html?id=" + this.id, "window");
	}
	else if(strCommand == "save")
		this.saveText();
	else if(strCommand == "changefont")
		this.objEditor.setFontFamily(this.cmbFont.options[this.cmbFont.selectedIndex].text);	
	else if(strCommand == "changefontsize")
		this.objEditor.setFontSize(parseInt(this.cmbSize.options[this.cmbSize.selectedIndex].text));
	else if (strCommand == "dateTime")
		this.objEditor.insertDate("<br>" + objApplication.getDateParser().getCurrentLocaleDateTime() + "</br>");
}

/**
 * Sets selected text to passed foreground r,g,b colour.
 *
 * @param r Red value.
 * @param g Green value.
 * @param b Blue value.
 */
function TEPickColourRGB(r, g, b)
{
	this.objEditor.pickColourRGB(r, g, b);
}

/**
 * Sets selected text to passed foreground hex colour.
 *
 * @param hexValue The rgb value in hex format.
 */
function TEPickColourHex(hexValue)
{
	this.objEditor.pickColourHex(hexValue);
}

/**
 * Inserts HTML table.
 *
 * @param numCols Number of table columns.
 * @param numRows Number of table rows.
 */
function TETableInsert(numCols, numRows)
{
	//create HTML could add fuctionallity to change colours, border settings etc.
	var strTableHTML = "<table borderColor=black cellSpacing=1 cellPadding=1 width='75%' border=1>";
	for (var j = 0; j < numRows; j++) 
	{
		strTableHTML += "<tr>";
		for (var k = 0; k < numCols; k++) 
		{
			strTableHTML += "<td>&nbsp;";
			strTableHTML += "</td>";
		}
		strTableHTML += "</tr>";
	}
	strTableHTML += "</table>";
	this.objEditor.createTable(strTableHTML);
}

/**
 * Inserts a library text link.
 *
 * @param type Emedia type.
 */
function TELibraryTextLink(type)
{	
	var objData = new RPCObject("EMediaDetail",window);  
	
	objData.execute("load", objApplication.Connection.strConnectionString, "emedialookup", "Standard", "library", type, "", "");
	
	this.objEditor.addHTML("<div>" + objData.getReturnedXMLDom().selectSingleNode("//data/value").getText() + "</div>");
}

/**
 * Inserts a hyper text link.
 *
 * @param htmlLink The hyper text link caption.
 * @param URL The hyper text link URL.
 */
function TEHyperTextLink(htmlLink, URL)
{	
	this.objEditor.addHTML("<div><a TARGET=_blank href='" + URL + "'>" + htmlLink + "</a></div>");
}

/**
 * Inserts an image link.
 *
 * @param URL The image link URL.
 */
function TEImageLink(URL)
{
	this.objEditor.addHTML("<div><img src='" + URL + "'></img></div>");
}

/**
 * Set a specified key value and ensure any keys after this one are blank
 * Also update all emediadetail's in the XMLDetail XML island with supplied keyValue.
 * @param keyNo The key number being set (a value from 1 to 4)
 * @param keyValue The value the key is to be set to.
 */
function TEsetKeyValue(keyNo, keyValue){

	this.strPreviewText = "";
		
	//Update the XMLDetail Island with the new keyvalue. So ALL types have correct keys
	if (keyValue != null){
		objTypeNodes = this.XMLDetail.selectNodes("emediadetail");
		for (var objTypeNode = objTypeNodes.nextNode(); objTypeNode != null; objTypeNode = objTypeNodes.nextNode())
			objTypeNode.selectSingleNode("keyvalue" + keyNo + "/value").setText(keyValue);
	}else{
		//In order to reinitialise the text editor XML data island. 
		//Invoked from EWM when auto eNotes and from emptyNotesXML call when manual eNotes.
		this.XMLDetail = objApplication.createXMLDocument();	
		if (this.objEditor != null && this.flgLoaded){
			this.setNotesText("");
		}
		this.flgLoaded = false;
	}
	
	this.keys[keyNo-1] = keyValue;
	for(i = keyNo; i<=3;i++)
		this.keys[i]="";
	this.flgKeySet = true;
}

/**
 * Set a specified key value
 * Also update all emediadetail's in the XMLDetail XML island with supplied keyValue.
 * @param keyNo The key number being set (a value from 1 to 4)
 * @param keyValue The value the key is to be set to.
 */
function TEsetSpecificKeyValue(keyNo, keyValue){
	this.strPreviewText = "";
	
	//Update the XMLDetail Island with the new keyvalue. So ALL types have correct keys
	if (keyValue != null){
		objTypeNodes = this.XMLDetail.selectNodes("emediadetail");
		for (var objTypeNode = objTypeNodes.nextNode(); objTypeNode != null; objTypeNode = objTypeNodes.nextNode())
			objTypeNode.selectSingleNode("keyvalue" + keyNo + "/value").setText(keyValue);
	}else{
		//In order to reinitialise the text editor XML data island. 
		//Invoked from EWM when auto eNotes and from emptyNotesXML call when manual eNotes.
		this.XMLDetail = objApplication.createXMLDocument();	
		if (this.objEditor != null && this.flgLoaded){
			this.setNotesText("");
		}
		this.flgLoaded = false;
	}

	if (0 < keyNo < 5)
		this.keys[keyNo-1] = keyValue;
	this.flgKeySet = true;
}

/**
 * Initialises all key values to be empty strings.
 */
function TEclearKeyValues()
{
	for(var intCtr = 0; intCtr < 4; intCtr++)
		this.keys[intCtr] = "";
}

/**
 * Sets up the emedia type combo box.
 */
function TEgetEmediaTypes() 
{
	var objNotesData = new RPCObject("EMediaLookUp",window);  	
	
	objNotesData.execute("loadAllByEmedia", objApplication.Connection.strConnectionString, this.emediaID);
	
	this.XMLTypes = objNotesData.getReturnedXMLDom();
	var typeNodes = this.XMLTypes.selectNodes("//emedialookup");
	var sTypes="";
	for (intCtr=0; intCtr<typeNodes.length(); intCtr++)
    	//sTypes = sTypes + typeNodes.item(intCtr).selectSingleNode("emediatype/value").getText() + "|";
    	sTypes = sTypes + typeNodes.item(intCtr).selectSingleNode("emediatype/value").getText() + "|" + typeNodes.item(intCtr).selectSingleNode("isdefault/value").getText() + "|";
	this.setComboTextType(sTypes);
}

/**
 * Pass through method to loadDetailZ.
 */
function TEloadDetail()
{
	this.loadDetailZ(this.cmbTextType.options[this.cmbTextType.selectedIndex].text);
}

/**
 * Loads the eNotes text for the specified emedia type.
 *
 * @param emediaType - the emedia type. If this is left blank then the eNotes
 *                     is regarded as 'standalone' (i.e. not related to any emedia type).
 */
function TEloadDetailZ(emediaType) 
{
  	this.previousEmediaID = this.emediaID;

	if (emediaType == "")
	{
	    if (this.flgNoEmedia == true)
		    this.setNotesText(this.standAloneHTML);

        return;
	}

	var topNode = this.XMLDetail.selectSingleNode("/emediadetails");

	if(topNode == null){
		var topNode = objApplication.Data.convertToCollection(objApplication.Data.generateNewRow("EmediaDetail"));
		topNode.removeChild(topNode.selectSingleNode("emediadetail"));
		this.XMLDetail.loadXML(topNode.xml());
	}
	
	if(emediaType != null) {
		this.sTextType = emediaType;
	}
	
	//First check if the texttype selected already has an entry in the XMLDetail XML island.
	var editElement = this.XMLDetail.selectSingleNode("//emediadetail[emediaid/value='" + this.emediaID +
		"' and emediatype/value='" + this.sTextType + "']");

	if(editElement != null)
	{
		this.setNotesText(editElement.selectSingleNode("data/value").getText());
		return;
	}

	var primaryKey = this.keys[0];
	var objRPCNotes = new RPCObject("EMediaDetail", window);
	var loadElement = objApplication.createXMLDocument();
	
	//Only ever load eNotes from the database if all the required key values are set and the record is not new.
	//(The isNewRecord check is a requirement for several application which sets default keyvalues the same as possible existing records)
	if(this.isCorrectKeyValuesSet() && !this.isNewRecord()) {
		var strXML = objRPCNotes.execute("load", objApplication.Connection.strConnectionString, this.emediaID, this.sTextType, this.keys[0], this.keys[1], this.keys[2], this.keys[3]);
		loadElement.loadXML(strXML);
	}
	
	if (primaryKey == null){
		this.setSpecificKeyValue(1, "");
		this.setNotesText("");
	}
	
	if(loadElement.selectSingleNode("//emediadetail") == null){
		//No record found so create new one
		var newRow = objApplication.Data.generateNewRow("EmediaDetail");		
		newRow.selectSingleNode("/emediadetail/emediaid/value").setText(this.emediaID);
		newRow.selectSingleNode("/emediadetail/emediaid/value").removeAttribute("xsi:nil");

		newRow.selectSingleNode("/emediadetail/emediatype/value").setText(this.sTextType);
		newRow.selectSingleNode("/emediadetail/emediatype/value").removeAttribute("xsi:nil");
		
		if (!isBlank(this.keys[0])) {
			newRow.selectSingleNode("/emediadetail/keyvalue1/value").setText(this.keys[0]);
			newRow.selectSingleNode("/emediadetail/keyvalue1/value").removeAttribute("xsi:nil");
		}

		if (!isBlank(this.keys[1])) {
			newRow.selectSingleNode("/emediadetail/keyvalue2/value").setText(this.keys[1]);
			newRow.selectSingleNode("/emediadetail/keyvalue2/value").removeAttribute("xsi:nil");
		}
		
		if (!isBlank(this.keys[2])) {
			newRow.selectSingleNode("/emediadetail/keyvalue3/value").setText(this.keys[2]);
			newRow.selectSingleNode("/emediadetail/keyvalue3/value").removeAttribute("xsi:nil");
		}
		
		if (!isBlank(this.keys[3])) {
			newRow.selectSingleNode("/emediadetail/keyvalue4/value").setText(this.keys[3]);
			newRow.selectSingleNode("/emediadetail/keyvalue4/value").removeAttribute("xsi:nil");
		}
		
		newRow.selectSingleNode("/emediadetail/data/value").setText("<html><head></head><body><p></p></body></html>");
		this.setNotesText(newRow.selectSingleNode("/emediadetail/data/value").getText());
		newRow.selectSingleNode("/emediadetail/data/value").removeAttribute("xsi:nil");

		var objXML = objApplication.createXMLDocument();
		objXML.loadXML(newRow.selectSingleNode("/emediadetail").xml());
		this.XMLDetail.selectSingleNode("/emediadetails").appendChild(objXML);
		
	} else {
		this.setNotesText(loadElement.selectSingleNode("//emediadetail/data/value").getText());

		var objXML = objApplication.createXMLDocument();
		objXML.loadXML(loadElement.selectSingleNode("//emediadetail").xml());
		this.XMLDetail.selectSingleNode("/emediadetails").appendChild(objXML);
	}
	if(this.appletReady)
	{
		this.flgLoaded = true;
		// 14/02/02 YVS 5601 Store original eNotes text
		this.strOriginalNotes = this.objEditor.getText();
		this.objEditor.setCombos();
	}
}

/**
 * Creates the emedia type combo box options.
 *
 * @param sValues Array of values for the combo options.
 */
function TEsetComboTextType(sValues)
{
	var sTypes = sValues.split("|");
	var i = 0;
	for (loop=0; loop < sTypes.length - 1;loop++)
	{			
		if (loop % 2 == 0)		
		{
			this.cmbTextType.options[i] = new Option(sTypes[loop]);
			i++;
		}
	}
	
	var i = 0;
	for (loop=0; loop < sTypes.length - 1;loop++)
	{			
		if (loop % 2 == 1)		
		{
			if (sTypes[loop] == "true")
			{
				this.cmbTextType.options[i].selected = true;
				break;
			}
			i++;
		}
	}
}

/**
 * Sets the current emedia text type.
 *
 * @param sTextType The emedia text type.
 */
function TEsetTextType (sTextType){

	this.loadDetailZ(sTextType);
}

/**
 * Commits any enotes changes to the database.
 */
function TEsaveText()
{
	if(this.flgLoaded == false) return;	
	
	if (this.isNotesDirty() == false)
		return;
	// ensure that all changes since the last onmouseout event are included in the XML
	this.storeText();

	/*
	 * Special case for backslash and single quote - need to escape manually for XPath
	 */
	var key0 = this.keys[0].replace("\\", "\\\\").replace("'", "\\'");
	var key1 = this.keys[1].replace("\\", "\\\\").replace("'", "\\'");
	var key2 = this.keys[2].replace("\\", "\\\\").replace("'", "\\'");
	var key3 = this.keys[3].replace("\\", "\\\\").replace("'", "\\'");

	var editElements = this.XMLDetail.selectNodes("//emediadetail[emediaid/value='" + this.emediaID +
	"' and keyvalue1/value='" + key0 +
	"' and keyvalue2/value='" + key1 +
	"' and keyvalue3/value='" + key2 +
	"' and keyvalue4/value='" + key3 +
	"']");
	
	if (editElements.length() == 0 || !this.isCorrectKeyValuesSet())
	{		
		if (this.EditWindowManager == null)
			this.EditWindowManager = eval(this.tabbedDialogID).EditWindowManager;

        	if (this.EditWindowManager != null)
        	{
			this.EditWindowManager.loadNotes(this, this.objWindow);

			editElements = this.XMLDetail.selectNodes("//emediadetail[emediaid/value='" + this.emediaID +
			"' and keyvalue1/value='" + key0 +
			"' and keyvalue2/value='" + key1 +
			"' and keyvalue3/value='" + key2 +
			"' and keyvalue4/value='" + key3 +
			"']");
		}

		if (editElements.length() == 0 || !this.isCorrectKeyValuesSet())
		{
			eMsgBox(fl("INSUFFICIENTINFO"), vbOKOnly, msg_Information, window);
			return;
		}
	}
	
    	// If eNotes text is blank (User has manually deleted text which previously existed) - Flag the record for deletion.
	if(this.textRemoved(this.XMLDetail) > 0)
	{
		// Once we know at least one texttype has been manually deleted, iterate through the emediadetails and flag these for deletion.
		for (var editElementNode = editElements.nextNode(); editElementNode != null; editElementNode = editElements.nextNode()) 
		{
			if (TEremovedcheck(editElementNode))
				editElementNode.setAttribute("isdeleted", "true");
		}
	}
	
	if (objApplication.Data.isDirty(this.XMLDetail))
	{
		var objSave = new RPCObject("EMediaDetail",window);
		//Use the XMLDetail XML island directly in the save RPC Call.
		var strXML = objSave.execute("save", objApplication.Connection.strConnectionString, this.XMLDetail.xml());
		
		//Reload the returned save XML into the XMLDetail so notes are no longer dirty.
		this.XMLDetail.loadXML(strXML);

		if (typeof(objStatusBar) != 'undefined')
			objStatusBar.message("eNotes saved");
	}
	
	//strOriginalNotes is set for text editors which set the flgNoEmedia flag. 
	//It is only used to determine that eNotes are dirty for those applications..
	this.strOriginalNotes = this.objEditor.getText();
	
	this.unsavedNotes = false;
}	

/**
 * Returns enotes business data ready for saving to database.
 *
 * @param objDataCollection The data object containing the enotes to be saved.
 * @return The business data xml string ready for saving to database.
 * @deprecated Method no longer required as XMLDetail contains the xml required to save.
 */
function TEprepareForSave(objDataCollection) {
	return objDataCollection.xml();
}

/**
 * Determines whether enotes data has been changed by user.
 *
 * @return True if data has been changed, false if not.
 */
function TEisNotesDirty()
{
	if (this.unsavedNotes)
		return true;
	
	//Check if applet was even launched
	if(!this.flgLoaded)
		return false;

	if(!this.appletReady)
		return false;
	
	// This flag is set on applications with no emedia and therefore no text type selection.
	// The strOriginalNotes property is only used in this mode as there will only be one set of eNotes.
	if (this.flgNoEmedia){
		if (String(this.objEditor.getText()) != String(this.strOriginalNotes))
			return	true;
		else
			return	false;
	}
	
	if (objApplication.Data.isDirty(this.XMLDetail)){
		objEmediaDetailNodes = this.XMLDetail.selectNodes("emediadetail");
		for (var objNode = objEmediaDetailNodes.nextNode(); objNode != null; objNode = objEmediaDetailNodes.nextNode())
		{
			var datOrigNode = objNode.selectSingleNode("data");
			var strOriginallyNew = datOrigNode.selectSingleNode("original").getAttribute("xsi:nil");
			if (strOriginallyNew == undefined){
				// If this emediadetail node is not new and it is dirty, then return true. 
				if (objApplication.Data.isDirty(objNode))
					return true;
			}
			var strDataCompareText = this.getDataCompareText(datOrigNode.selectSingleNode("value").getText());
			// When the user selects edit mode, "<html><head></head><body><p></p></body></html>" is entered
			// As this will cause the objApplication.Data.isDirty to return true, we need to check if anything was entered.
			if (strOriginallyNew == "true" && (strDataCompareText != "" && strDataCompareText != "<html><head></head><body><p></p></body></html>"))
				return true;
		}
	}	
	
	return false;
}

/**
 * Changes text editor display from readonly to editable mode
 * and vice versa.
 */
function TEchangeEditorMode()
{
	var strText = this.objEditor.getText();
	
	this.flgEditorDisplay = !this.flgEditorDisplay;
	this.displayDiv();
	if (this.flgEditorDisplay && this.appletReady)
		this.setNotesText(strText);
	else
	{
	    // This "else" section has been added to maintain editor synchronisation between edit and preview modes.
	    this.setNotesText(this.strPreviewText);
    }
	this.objEditor.changeEditorMode();
}

/**
 * Toggle the text editor window from disabled to enabled.
 *
 * @param flg True when setting as disabled, false when setting as enabled.
 */
function TEsetReadOnly(flag)
{
	if (flag)
		this.btnEditorMode.disabled = true;
	else
		this.btnEditorMode.disabled = false;
}

/**
 * Shows the text editor content either in readonly or edit mode.
 */
function TEdisplayDiv(){

	if (this.flgEditorDisplay)
	{
		this.objWindow.document.getElementById(this.id + "_notes_td_display").style.display = "block";
		this.objWindow.document.getElementById(this.id + "_notes_td_edit").style.display = "none";
		this.objEditor.hideGroup(this.objToolbar, this.id);
		this.btnEditorMode.innerHTML = fl("EDITMODE");
	}
	else{
		this.objWindow.document.getElementById(this.id + "_notes_td_display").style.display = "none";
		this.objWindow.document.getElementById(this.id + "_notes_td_edit").style.display = "block";
		this.objEditor.showGroup(this.objToolbar, this.id);
		this.btnEditorMode.innerHTML = fl("DISPLAYMODE");
		this.objEditor.displayDiv();
	}
}

/**
 * Copies the text specified in 'sHTML' into the editor window so that it can be edited.
 *
 * @param sHTML - the text to be edited.
 */
function TEsetNotesText(sHTML)
{
	var genHTML = TEgenerateHTML(sHTML);

	genHTML = this.processText(genHTML);

	var regEx = /<\/br>/g;
	genHTML = genHTML.replace(regEx, "");
	
	regEx = /<\/IMG>/g;
	genHTML = genHTML.replace(regEx, "");
	
	if (this.flgEditorDisplay){
		this.objWindow.document.getElementById(this.id + "_notes_div_display").innerHTML = genHTML;
		
		// This line added as a temporary store for the standard, unformatted text data.
		this.strPreviewText = genHTML;

		if (this.flgNoEmedia == true)
		    this.standAloneHTML = genHTML;
	}
	else{
		if(!this.appletReady)
			return;
		this.objEditor.setNotesText(genHTML);
	}
}

function TEgenerateHTML(sHTML)
{
	var newStrHTML = String(sHTML);

	var regEx = /font size=\"10\"/g;
	newStrHTML = newStrHTML.replace(regEx, "font size=\"1\"");

	var regEx = /font size=\"12\"/g;
	newStrHTML = newStrHTML.replace(regEx, "font size=\"2\"");

	var regEx = /font size=\"15\"/g;
	newStrHTML = newStrHTML.replace(regEx, "font size=\"3\"");

	var regEx = /font size=\"18\"/g;
	newStrHTML = newStrHTML.replace(regEx, "font size=\"4\"");

	var regEx = /font size=\"24\"/g;
	newStrHTML = newStrHTML.replace(regEx, "font size=\"5\"");

	var regEx = /font size=\"36\"/g;
	newStrHTML = newStrHTML.replace(regEx, "font size=\"6\"");

	var regEx = /font size=\"48\"/g;
	newStrHTML = newStrHTML.replace(regEx, "font size=\"7\"");

	return newStrHTML;
}

function TEhideEditModeToolbar()
{
	this.objWindow.document.getElementById(this.id + "btnEditorMode").style.display = "none";
	this.objWindow.document.getElementById(this.id + "cmbTextType").parentElement.previousSibling.previousSibling.style.display = "none";
	this.objWindow.document.getElementById(this.id + "cmbTextType").style.display = "none";
}

/**
 * Performs any editor specific text manipulation.
 * Called before saving and setting notes text into the editor.
 *
 * @param strHTML The preprocessed HTML.
 * @return The processed HTML.
 */
function TEprocessText(strHTML)
{
	return this.objEditor.processText(strHTML);
}

/**
 * Stores the text from the editor window, for the currently selected texttype to the XML island.
 * Invoked by events attached to either applet or div text edit pane.
 * Once stored in XMLDetail, any initialise calls from apps or tab selects won't loose the eNotes text.
 */
function TEstoreText()
{
	var typeElement = this.XMLDetail.selectSingleNode("//emediadetail[emediaid/value='" + this.emediaID +
	"' and emediatype/value='" + this.sTextType + "']");
	if (typeElement != null){
		if (this.objEditor.getText() != "<html><head></head><body><p></p></body></html>")
			typeElement.selectSingleNode("data/value").setText(this.objEditor.processText(this.objEditor.getText()));
	}
}

/**
 * Iterates through the emediadetail's passed and counts how many are blank (Possible deletion by user).
 *
 * @param objXML - Emediadetail's XML Island.
 * @return ctrENotesRemoved - Number of blank eNotes.
 */
function TEtextRemoved(objXML)
{
	var ctrENotesRemoved = 0;
	var emediadetailElements = objXML.selectNodes("emediadetail[emediaid/value='" + this.emediaID + "']");
	
	for (var emediadetailNode = emediadetailElements.nextNode(); emediadetailNode != null; emediadetailNode = emediadetailElements.nextNode()) {
		if (TEremovedcheck(emediadetailNode))
			ctrENotesRemoved++;
	}
	return ctrENotesRemoved;
}

/**
 * Carries out the actual notes empty/removed check.
 * Depending on IEEditor or EfacsEditor, notes can be blank but different, so manipulate a
 * copy of the data before carrying out a generic check.
 *
 * @param objNodeXML - The individual node which is being checked.
 * @return boolean of whether emediadetail node is empty.
 */
function TEremovedcheck(objNodeXML){
	var strTextData = String(objNodeXML.selectSingleNode("data/value").getText());
	if (strTextData.length <100) {
		var textHTMLnoSpaces = strTextData.replace(/&nbsp;/g, "");
		textHTMLnoSpaces = textHTMLnoSpaces.replace(/&#160;/g, "");
		textHTMLnoSpaces = textHTMLnoSpaces.replace(/ /g, "");
		if (textHTMLnoSpaces == "<html><head></head><body><p></p></body></html>")
			return true;
	}
	return false;
}

/**
 * Calls setKeyValue method with parameters which will cause the 
 * keys and XMLDetail to be reset and loaded flag to false.
 */
function TEemptyNotesXML() {
	this.setKeyValue(1, null);
}

/**
 * Manipulate emediadetail text to obtain a generic string representation
 * which can be used for comparison between notes. Used for dirty check.
 * 
 * @param strNotesText - The emediadetail data text.
 * @return strNotesText - Return text after all possible anomlies have been removed.
 */
function TEgetDataCompareText(strNotesText) 
{
	strNotesText = strNotesText.replace(/&nbsp;/g, "");
	strNotesText = strNotesText.replace(/&#160;/g, "");
	strNotesText = strNotesText.replace(/ /g, "");
		
	var loadElement = objApplication.createXMLDocument();
	if (loadElement.loadXML(strNotesText)){
		if (loadElement.selectSingleNode("body/p"))
		{
			return loadElement.selectSingleNode("body/p").getText();
		}
		else if (loadElement.selectSingleNode("body"))
		{
			return loadElement.selectSingleNode("body").getText();
		}
	}
	return strNotesText;
}

/**
 * Carries out a check on attached form in order to make sure all the correct keyvalues have been set.
 * The keyvalues should be set according to the primary schema fields on the form
 *
 * @return boolean of whether the correct keyvalues are set.  
 */
function TEisCorrectKeyValuesSet()
{
	if (this.EditWindowManager == null && this.tabbedDialogID != null && this.tabbedDialogID != "")
		this.EditWindowManager = eval(this.tabbedDialogID).EditWindowManager;
		
	if (this.EditWindowManager != null){
		var objEditWindow = this.EditWindowManager.getEditWindow(this.objWindow);
		if (objEditWindow != null && objEditWindow.Form != null){
			for (var n = 0; n < objEditWindow.Form.fields.length; n++)
			{
				var objField = objEditWindow.Form.fields[n];
				if (objField.HTMLElement.isprimary == "true" && objField.HTMLElement.schemaField == "true")
				{
					var keyValue = this.keys[Number(objField.HTMLElement.primarykeyno)-1];
					if ( String(keyValue) == "" || keyValue == null )
						return false;
				}
			}
		}
	}
	//If references for editWindow and/or form can not be established, then simply check that the primary key is  not blank
	if (String(this.keys[0]) == "" || this.keys[0] == null)
		return false;

	return true;
}

/**
 * Checks whether the editMode state of the edit window is in add mode to determine whether
 * the record is new. The boolean returned determines whether an emediadetail needs to be loaded from DB.
 *
 * @return boolean of whether record is new. If we dont know then return false by default.
 */
function TEisNewRecord()
{
	if (this.EditWindowManager == null && this.tabbedDialogID != null && this.tabbedDialogID != "")
		this.EditWindowManager = eval(this.tabbedDialogID).EditWindowManager;
		
	if (this.EditWindowManager != null){
		var objEditWindow = this.EditWindowManager.getEditWindow(this.objWindow);
		if (objEditWindow != null)
			return (objEditWindow.editMode == "add");
	}
	
	return false;
}

/**
 * Clear references to the text editor
 */
function TEdestroy() {
	try {
		this.XMLTypes = null;
		this.XMLDetail = null;
		this.cmbFont = null;
		this.cmbSize = null;
		this.cmbTextType = null;
		this.id = null;
		
		if (this.objToolbar != null) {
			var arrButtons = this.objToolbar.HTMLElement.getElementsByTagName("BUTTON");
			if (arrButtons != null) {
				for (var i = 0, len = arrButtons.length; i < len; i++) {
					arrButtons[i].onmouseover = null;
					arrButtons[i].onclick = null;
					arrButtons[i].onmouseout = null;
				}	
			}
			arrButtons = null;
			this.objToolbar.destroy();
			this.objToolbar = null;
		}
	
		this.objWindow = null;
	
		this.keys = new Array();
		this.EditWindowManager = null;	
		this.objEditor = null;
		this.tabbedDialogID = null;
		this.standAloneHTML = null;
	} catch (error) {
	}
}


	

// ADAPT constants.
var ADAPT_ONBEFORECLICK = 0x1;
var ADAPT_ONAFTERCLICK = 0x2;

// Cache details from the style sheets
var m_strToggleHover = null;
var m_strToggleHoverBorder = null;
var m_strToggleFilter = null;
var m_strToggleBorder = null;
var m_strNormalHighlight = null;
var m_strNormalHighlightBorder = null;

/** 
 * Constructor for the Toolbar object
 *
 * @param objHTMLElement The TABLE element containing the toolbar HTML.
 * @param objWindow The window object.
 */
function Toolbar(objHTMLElement, objWindow) 
{
// properties
	this.HTMLElement			= objHTMLElement;
	this.objWindow				= objWindow;
	this.id						= objHTMLElement.id.replace("tlb", "");
	this.arrButtons				= new Array();
	
// methods
	this.toXML					= Toolbar_toXML;
	this.hide					= Toolbar_hide;
	this.show					= Toolbar_show;
	this.isVisible				= Toolbar_isVisible;
	this.suppressLabels			= Toolbar_suppressLabels;
	this.suppressGroupLabels	= Toolbar_suppressGroupLabels;
	this.suppressLabel			= Toolbar_suppressLabel;
	this.hideGroup				= Toolbar_hideGroup;
	this.showGroup				= Toolbar_showGroup;
	this.addButton				= Toolbar_addButton; // HTML Button
	this.addToolbarButton		= Toolbar_addToolbarButton; // ToolbarButton object
	this.getButtons				= Toolbar_getButtons;
	this.getButton				= Toolbar_getButton;
	this.mouseover				= Toolbar_mouseover;
	this.mouseout				= Toolbar_mouseout;
	this.mouseover_cascading	= Toolbar_mouseover_cascading;
	this.mouseout_cascading		= Toolbar_mouseout_cascading;
	this.destroy				= Toolbar_destroy;
}

/** 
 * Used by ADAPT - returns an tree formatted xml representation of this object.
 *
 * @return The tree formatted xml representation of this object.
 */
function Toolbar_toXML()
{
	var strUID = this.id;
	
	var strXML = "<node uid='" + strUID + "' level='3' open='false' fire-onclick='true'>";
	strXML += "<vals>";
	strXML += "<val id='label'>" + strUID + "</val>";
	strXML += "<val id='name'>" + strUID + "</val>";
	strXML += "</vals>";
	
	var objButtons = this.getButtons();
	if (objButtons.length > 0)
	{
		var strButtons = "";
	
		// TOOLBAR BUTTONS
		for (var intCtr = 0; intCtr < objButtons.length; intCtr++)
		{
			if (objButtons[intCtr].HTMLElement != null && objButtons[intCtr].HTMLElement.className == "toolbar-button")
			{
				var strButtonXML = objButtons[intCtr].toXML();
				if (strButtonXML != null)
					strButtons += strButtonXML;
			}
		}

		if (!isBlank(strButtons))
			strXML += "<nodes>" + strButtons + "</nodes>";
	}

	// End toolbar node.
	strXML += "</node>";

	return strXML;
}

/** 
 * Get an array of buttons contained in this toolbar.
 *
 * @return A javascript array of ToolbarButton objects.
 */
function Toolbar_getButtons()
{
	return this.arrButtons;
}

/** 
 * Get an button reference based on the passed button id.
 *
 * @param strButtonId The button id.
 * @return A reference to the ToolbarButton object.
 */
function Toolbar_getButton(strButtonId)
{
	var objButtons = this.arrButtons;
	for (var i=0, intLen = objButtons.length; i < intLen; i++)
	{
		var objButton = objButtons[i];
		if (objButton.id == strButtonId || objButton.id == (this.id + "_" + strButtonId))
			return objButton;
	}
}

/** 
 * Hides the toolbar.
 */
function Toolbar_hide()
{
	getParentElement(this.HTMLElement.parentElement, "TABLE").style.display = "none";
}

/** 
 * Unhides to the toolbar.
 */
function Toolbar_show()
{
	getParentElement(this.HTMLElement.parentElement, "TABLE").style.display = "inline";
}

/** 
 * Is the toolbar visible ?
 *
 * @return true if visible - false if not visible.
 */
function Toolbar_isVisible()
{
	if (getParentElement(this.HTMLElement.parentElement, "TABLE").style.display == "none")
		return false;
	else
		return true;
}

/** 
 * This methods simply iterates through all the toolbar''s buttons, removing the labels.
 */
function Toolbar_suppressLabels()
{
	var objNodes = this.HTMLElement.getElementsByTagName("BUTTON");

	for (var i = 0; i < objNodes.length; i++)
	{
		this.suppressLabel(objNodes.item(i));
	}
}

/** 
 * Suppresses toolbar group labels.
 * 
 * @param strGroupName The toolbar group name.
 */
function Toolbar_suppressGroupLabels(strGroupName)
{
	var objSpans = this.HTMLElement.getElementsByTagName("SPAN");
	for (var i = 0; i < objSpans.length; i++)
	{
		var objSpan = objSpans.item(i);

		if (objSpan.getAttribute("toolbar_group_id") == strGroupName)
		{
			var objNodes = objSpan.getElementsByTagName("BUTTON");

			for (var intCtr = 0; intCtr < objNodes.length; intCtr++)
			{
				this.suppressLabel(objNodes.item(intCtr));
			}
		}
	}
}

/** 
 * Suppresses toolbar label.
 *
 * @param objHTMLElement The HTML button object.
 */
function Toolbar_suppressLabel(objHTMLElement)
{
	objHTMLElement.innerHTML = "";
}

/** 
 * Fires a toolbar button onclick event.
 * Also calls the attached before and after ADAPT onclick events if any are declared.
 *
 * @param strFunction The application specific method name attached to the onclick for a button.
 * @param objElement The HTML button object.
 * @param objEvent The window event object.
 */
function Toolbar_fireFunction(strFunction, objElement, objEvent) 
{
	var flgFireOptions = false;
	var objToolbar = eval(getParentElement(objElement, "TABLE").id.replace("tlb", ""));
	var objButton = null;

	if (objElement.tagName != "BUTTON")
	{
		if (objElement.children[0].className == "toolbar-button-option")
		{
			objElement = objElement.previousSibling;
			flgFireOptions = true;
		}

		objButton = objToolbar.getButton(objElement.id);

		if (isBlank(strFunction) && objButton.arrOptions != null)
			flgFireOptions = true;
	}

	if (flgFireOptions == false)
	{
		if (objButton != null && objToolbar != null)
		{
			var retVal = objButton.performADAPTScript(ADAPT_ONBEFORECLICK);
			if (retVal == false)
				return;
		}

		objStatusBar.clear();

		if (objButton != null && objButton.flgToggleButton)
			objButton.toggle();

		if (strFunction.length > 0) {
			var methodName = strFunction.replace(/(\(\));*/, "");
			if (methodName.indexOf("(") != -1 || methodName.indexOf(".") != -1) {
				var evalFunction = new Function(strFunction);
				evalFunction();
			} else {
				window[methodName]();
			}
		}

		if (objButton != null && objToolbar != null)
			objButton.performADAPTScript(ADAPT_ONAFTERCLICK);

		return;
	}

	var contextMenu = new ContextMenu();
	var objWindow = objElement.ownerDocument.parentWindow;

	for (var i=0, intLen = objButton.arrOptions.length; i < intLen; i++)
	{
	    var strOnClick = null;
		var objOption = objButton.arrOptions[i];
		var intParamPos = objOption.onclick.indexOf("(");
		var arrParams = null;
		if (intParamPos != -1)
		{
			var strParams = objOption.onclick.substring(intParamPos + 1, objOption.onclick.length - 1);
			var arrParams = strParams.split(",");

			strOnClick = objOption.onclick.substring(0, intParamPos);
		}
		else
		    strOnClick = objOption.onclick;

		contextMenu.addOption(objOption.label, objOption.image, objWindow.eval(strOnClick), arrParams, objOption.isDisabled);
	}
	contextMenu.show(getOffsetLeftFromElement(objElement, "mainBodyTag") - 5, getOffsetTopFromElement(objElement, "mainBodyTag") + objElement.offsetHeight);
}

/** 
 * Hides a group of toolbar buttons.
 *
 * @param strGroupName The toolbar button group name.
 */
function Toolbar_hideGroup(strGroupName) 
{
	var objSpans = this.HTMLElement.getElementsByTagName("SPAN")

	for (var i = 0; i < objSpans.length; i++) 
	{
		var objSpan = objSpans.item(i);
		if(objSpan.getAttribute("toolbar_group_id") == strGroupName)
			objSpan.style.display = "none";
	}
}

/** 
 * Unhides a group of toolbar buttons.
 *
 * @param strGroupName The toolbar button group name.
 */
function Toolbar_showGroup(strGroupName) 
{
	var objSpans, objSpan;	
	objSpans = this.HTMLElement.getElementsByTagName("SPAN")

	for (var i = 0; i < objSpans.length; i++) 
	{
		objSpan = objSpans.item(i);
		if(objSpan.getAttribute("toolbar_group_id") == strGroupName)
			objSpan.style.display = "block";
	}
}

/** 
 * Add a new HTML button to an existing toolbar (see addToolbarButton for adding objects)
 *
 * @param id ID of the new button
 * @param label Label of the new button
 * @param title Title (tooltip) of the new button
 * @param onclickevent Function pointer to the method called when the button is clicked
 */
function Toolbar_addButton(id, label, title, onclickevent) 
{
	var objNew = this.HTMLElement.tBodies[0].rows[0].insertCell();
	objNew.unselectable = "on";
	objNew.tabIndex = 1;
	objNew.noWrap = true
	objNew.id = id;
	objNew.title = title;
	objNew.className = "toolbar-button";
	addEvent(objNew, "onclick", onclickevent);
	addEvent(objNew, "onmouseover", Toolbar_mouseover);
	addEvent(objNew, "onmouseout", Toolbar_mouseout);
	addEvent(objNew, "onkeydown", Toolbar_onkeydown);

	var objLabel = this.objWindow.document.createElement("LABEL");
	objLabel.unselectable = "on";
	objLabel.className = "toolbar-button-label";
	objLabel.innerHTML = label;
	objLabel.style.height = "16px";
	
	objNew.appendChild(objLabel);

	//append the button to the containing Row.
	this.HTMLElement.tBodies[0].rows[0].appendChild(objNew);
}

/**
 * This method creates a ToolbarButton object and adds it to the array of toolbar buttons
 * for future manipulation
 * @param id The button id
 * @param label The button label
 * @param title The tooltip for the button
 * @param onclickevent The method to be called when the button is clicked
 */
function Toolbar_addToolbarButton(id, label, title, onclickevent)
{
	this.addButton(id, label, title, onclickevent);
	var objButtonHTML = this.objWindow.document.getElementById(id);
	var objButton = new ToolbarButton(objButtonHTML, this);
	this.arrButtons[this.arrButtons.length] = objButton;
}

/** 
 * Changes the background colour to highlight the passed button.
 *
 * @param objObject Either a button HTML element or an event containing the button HTML element.
 */
function Toolbar_mouseover(objObject) {
	var fromContext = false;
	var objButton = objObject.srcElement;

	if (objButton == null)
		objButton = objObject;
	
	if (objButton.tagName == "TR")
		fromContext = true;
		
	if (objButton.className == "toolbar-button-hover-cascading") {
		// The cascading contextmenu has been selected so no need to process
		return;
	}
	
	if (objButton.tagName == "LABEL")
		objButton = objButton.parentElement;

	// Determine if this is an option button;
	var objOptionButton = null;
	if (objButton.nextSibling != null && 
		objButton.nextSibling.children[0] != null && 
		objButton.nextSibling.children[0].className == "toolbar-button-option")	{
		objOptionButton = objButton.nextSibling;
	}
	if (objButton.children[0].className == "toolbar-button-option")	{
		objOptionButton = objButton;
		objButton = objOptionButton.previousSibling;
	}

	if (objButton.toggled == true || objButton.toggled == "true") {
		if (m_strToggleHover == null || m_strToggleHoverBorder == null) {
			if ((typeof(objApplication) != "undefined" && objApplication.browser == APPLICATION_IE) || getCurrentBrowser() == APPLICATION_IE) {
				var objTmp = window.document.createElement("SPAN");
				objTmp.style.visibility = "hidden";
				objTmp.className = "toolbar-toggle-button-hover";
				window.document.body.appendChild(objTmp);
				m_strToggleHover = objTmp.currentStyle.filter;
				m_strToggleHoverBorder = objTmp.currentStyle.borderStyle + " " + objTmp.currentStyle.borderColor + " " + objTmp.currentStyle.borderWidth;
				window.document.body.removeChild(objTmp);
			} else {
				m_strToggleHover = "progid:DXImageTransform.Microsoft.Gradient(endColorstr='#FFD38E', startColorstr='#FE914E', gradientType='0')";
			}
		}
		
		if (fromContext) {
			objButton.children[0].style.filter = m_strToggleHover;
			objButton.children[0].style.borderTop = m_strToggleHoverBorder;
			objButton.children[0].style.borderLeft = m_strToggleHoverBorder;
			objButton.children[0].style.borderBottom = m_strToggleHoverBorder;
			objButton.children[0].style.padding = "1px";
			
			objButton.children[1].style.filter = m_strToggleHover;
			objButton.children[1].style.borderTop = m_strToggleHoverBorder;
			objButton.children[1].style.borderBottom = m_strToggleHoverBorder;
			objButton.children[1].style.padding = "1px";
			
			objButton.children[2].style.filter = m_strToggleHover;
			objButton.children[2].style.borderTop = m_strToggleHoverBorder;
			objButton.children[2].style.borderRight = m_strToggleHoverBorder;
			objButton.children[2].style.borderBottom = m_strToggleHoverBorder;
			objButton.children[2].style.padding = "1px";
		}
		else {
			objButton.style.filter = m_strToggleHover;
		}
	} else {
		if (m_strNormalHighlight == null || m_strNormalHighlightBorder == null) {
			if ((typeof(objApplication) != "undefined" && objApplication.browser == APPLICATION_IE) || getCurrentBrowser() == APPLICATION_IE) {
				var objTmp = window.document.createElement("SPAN");
				objTmp.style.visibility = "hidden";
				objTmp.className = "toolbar-button-hover";
				window.document.body.appendChild(objTmp);
				m_strNormalHighlight = objTmp.currentStyle.backgroundColor;
				m_strNormalHighlightBorder = objTmp.currentStyle.borderStyle + " " + objTmp.currentStyle.borderColor + " " + objTmp.currentStyle.borderWidth;
				window.document.body.removeChild(objTmp);
			} else {
				m_strNormalHighlight = "#FFD497";
				m_strNormalHighlightBorder = "1px solid black";
			}
		}
	
		if (fromContext) {
			objButton.children[0].style.backgroundColor = m_strNormalHighlight;
			objButton.children[0].style.borderTop = m_strNormalHighlightBorder;
			objButton.children[0].style.borderLeft = m_strNormalHighlightBorder;
			objButton.children[0].style.borderBottom = m_strNormalHighlightBorder;
			objButton.children[0].style.padding = "1px";
			objButton.children[0].style.paddingRight = "2px";
			
			objButton.children[1].style.backgroundColor = m_strNormalHighlight;
			objButton.children[1].style.borderTop = m_strNormalHighlightBorder;
			objButton.children[1].style.borderBottom = m_strNormalHighlightBorder;
			objButton.children[1].style.padding = "2px";
			
			objButton.children[2].style.backgroundColor = m_strNormalHighlight;
			objButton.children[2].style.borderTop = m_strNormalHighlightBorder;
			objButton.children[2].style.borderRight = m_strNormalHighlightBorder;
			objButton.children[2].style.borderBottom = m_strNormalHighlightBorder;
			objButton.children[2].style.padding = "1px";
		}
		else {
			objButton.style.backgroundColor = m_strNormalHighlight;
			objButton.style.border = m_strNormalHighlightBorder;
			objButton.style.padding = "1px";
		}
	} 

	if (objOptionButton != null)
	{
		if (m_strNormalHighlight == null || m_strNormalHighlightBorder == null) {
		
			if ((typeof(objApplication) != "undefined" && objApplication.browser == APPLICATION_IE) || getCurrentBrowser() == APPLICATION_IE) {
				var objTmp = window.document.createElement("SPAN");
				objTmp.style.visibility = "hidden";
				objTmp.className = "toolbar-button-hover";
				window.document.body.appendChild(objTmp);
				m_strNormalHighlight = objTmp.currentStyle.backgroundColor;
				m_strNormalHighlightBorder = objTmp.currentStyle.borderStyle + " " + objTmp.currentStyle.borderColor + " " + objTmp.currentStyle.borderWidth;
				window.document.body.removeChild(objTmp);
			} else {
				m_strNormalHighlight = "#FFD497";
				m_strNormalHighlightBorder = "1px solid black";
			}
		}
		objOptionButton.style.backgroundColor = m_strNormalHighlight;
		objOptionButton.style.border = m_strNormalHighlightBorder;
		objOptionButton.style.borderLeft = "none";
		objOptionButton.style.padding = "1px";
		objOptionButton.style.paddingLeft = "0px";
	}
}

/** 
 * Changes the background colour to unhighlight the passed button.
 *
 * @param objObject Either a button HTML element or an event containing the button HTML element.
 */
function Toolbar_mouseout(objObject)
{
	var fromContext = false;
	var objButton = objObject.srcElement;

	if (objButton == null)
		objButton = objObject;

	if (objButton.className == "toolbar-button-hover-cascading") {
		// The cascading contextmenu has been selected so no need to process
		return;
	}
	
	if (objButton.tagName == "TR")
		fromContext = true;
		
	if (objButton.tagName == "LABEL")
		objButton = objButton.parentElement;

	// Determine if this is an option button;
	var objOptionButton = null;
	if (objButton.nextSibling != null && 
		objButton.nextSibling.children[0] != null && 
		objButton.nextSibling.children[0].className == "toolbar-button-option")	{
		objOptionButton = objButton.nextSibling;
	}
	if (objButton.children[0].className == "toolbar-button-option")	{
		objOptionButton = objButton;
		objButton = objOptionButton.previousSibling;
	}

	if (objButton.toggled == true || objButton.toggled == "true") {
		if (m_strToggleFilter == null || m_strToggleBorder == null) {
			if ((typeof(objApplication) != "undefined" && objApplication.browser == APPLICATION_IE) || getCurrentBrowser() == APPLICATION_IE) {
				var objTmp = window.document.createElement("SPAN");
				objTmp.style.visibility = "hidden";
				objTmp.className = "toolbar-toggle-button";
				window.document.body.appendChild(objTmp);
				m_strToggleFilter = objTmp.currentStyle.filter;
				m_strToggleBorder = objTmp.currentStyle.borderStyle + " " + objTmp.currentStyle.borderColor + " " + objTmp.currentStyle.borderWidth;
				window.document.body.removeChild(objTmp);
			} else {
				m_strToggleFilter = "progid:DXImageTransform.Microsoft.Gradient(endColorstr='#FFAD55', startColorstr='#FFD58C', gradientType='0')";
				m_strTogleBorder = "black 1px solid";
			}
		}
		if (fromContext) {
			objButton.children[0].style.filter = m_strToggleFilter;
			objButton.children[1].style.filter = m_strToggleFilter;
			objButton.children[2].style.filter = m_strToggleFilter;
		}
		else {
			objButton.style.filter = m_strToggleFilter;
			objButton.style.border = m_strToggleBorder; // ???
			objButton.style.padding = "1px";
		}
	} else {
		if (fromContext) {
			objButton.children[0].style.backgroundColor = "transparent";
			objButton.children[0].style.border = "none";
			objButton.children[0].style.padding = "2px";
			objButton.children[1].style.backgroundColor = "transparent";
			objButton.children[1].style.border = "none";
			objButton.children[1].style.padding = "2px";
			objButton.children[2].style.backgroundColor = "transparent";
			objButton.children[2].style.border = "none";
			objButton.children[2].style.padding = "2px";
		}
		else {
			objButton.style.backgroundColor = "transparent";
			objButton.style.border = "none";
			objButton.style.padding = "2px";
		}
	}
	
	if (objOptionButton != null) {
		objOptionButton.style.backgroundColor = "transparent";
		objOptionButton.style.border = "none";
		objOptionButton.style.padding = "2px";
		objOptionButton.style.paddingLeft = "0px";
	}
}

/**
 * Mouseover event for cascading context menu
 * @param objObject HTML object
 */
function Toolbar_mouseover_cascading(objObject) {
	if (m_strNormalHighlight == null || m_strNormalHighlightBorder == null) {
		if ((typeof(objApplication) != "undefined" && objApplication.browser == APPLICATION_IE) || getCurrentBrowser() == APPLICATION_IE) {
			var objTmp = window.document.createElement("SPAN");
			objTmp.style.visibility = "hidden";
			objTmp.className = "toolbar-button-hover-cascading";
			window.document.body.appendChild(objTmp);
			m_strNormalHighlight = objTmp.currentStyle.backgroundColor;
			m_strNormalHighlightBorder = objTmp.currentStyle.borderStyle + " " + objTmp.currentStyle.borderColor + " " + objTmp.currentStyle.borderWidth;
			window.document.body.removeChild(objTmp);
		} else {
			m_strNormalHighlight = "#FFD497";
			m_strNormalHighlightBorder = "1px solid black";
		}
	}

	objObject.className = "toolbar-button-hover-cascading";
	
	objObject.children[0].style.backgroundColor = m_strNormalHighlight;
	objObject.children[0].style.borderTop = m_strNormalHighlightBorder;
	objObject.children[0].style.borderLeft = m_strNormalHighlightBorder;
	objObject.children[0].style.borderBottom = m_strNormalHighlightBorder;
	objObject.children[0].style.padding = "1px";
	
	objObject.children[1].style.backgroundColor = m_strNormalHighlight;
	objObject.children[1].style.borderTop = m_strNormalHighlightBorder;
	objObject.children[1].style.borderBottom = m_strNormalHighlightBorder;
	objObject.children[1].style.padding = "2px";
	
	objObject.children[2].style.backgroundColor = m_strNormalHighlight;
	objObject.children[2].style.borderTop = m_strNormalHighlightBorder;
	objObject.children[2].style.borderRight = m_strNormalHighlightBorder;
	objObject.children[2].style.borderBottom = m_strNormalHighlightBorder;
	objObject.children[2].style.paddingTop = "1px";
	objObject.children[2].style.paddingLeft = "2px";
	objObject.children[2].style.paddingBottom = "1px";
}

/**
 * Mouseout event for cascading context menu
 * @param objObject HTML object
 */
function Toolbar_mouseout_cascading(objObject) {
	objObject.className = "toolbar-button";
	
	objObject.children[0].style.backgroundColor = "transparent";
	objObject.children[0].style.border = "none";
	objObject.children[0].style.padding = "2px";
	objObject.children[1].style.backgroundColor = "transparent";
	objObject.children[1].style.border = "none";
	objObject.children[1].style.padding = "2px";
	objObject.children[2].style.backgroundColor = "transparent";
	objObject.children[2].style.border = "none";
	objObject.children[2].style.padding = "2px";
}

/** 
 * Fires the click event if the keypress was spacebar - 32.
 *
 * @param The window event object.
 */
function Toolbar_onkeydown(objEvent)
{
	if (objEvent == null)
		objEvent = this.objWindow.event;

	if (objEvent.keyCode == 32)
		objEvent.srcElement.click();
}


/**
 * Clear references to the toolbar object
 */
function Toolbar_destroy() {
	try {
		if (this.arrButtons != null) {
			for (var i = 0, len = this.arrButtons.length; i < len; i++) {
				this.arrButtons[i].destroy();
				this.arrButtons[i] = null;
			}
		}
		this.arrButtons = new Array();

		if (this.HTMLElement != null) {
			if (this.HTMLElement.tBodies != null && this.HTMLElement.tBodies[0] != null) {
				if (this.HTMLElement.tBodies[0].rows != null && this.HTMLElement.tBodies[0].rows[0] != null) {
					if (this.HTMLElement.tBodies[0].rows[0].cells != null) {
						for (var i = 0, len = this.HTMLElement.tBodies[0].rows[0].cells.length; i < len; i++) {
							if (this.HTMLElement.tBodies[0].rows[0].cells[i] != null) {
								this.HTMLElement.tBodies[0].rows[0].cells[i].onclick = null;
								this.HTMLElement.tBodies[0].rows[0].cells[i].onmouseover = null;
								this.HTMLElement.tBodies[0].rows[0].cells[i].onmouseout = null;
								this.HTMLElement.tBodies[0].rows[0].cells[i].onkeydown = null;
								this.HTMLElement.tBodies[0].rows[0].cells[i].onfocus = null;
								this.HTMLElement.tBodies[0].rows[0].cells[i].onblur = null;
								this.HTMLElement.tBodies[0].rows[0].cells[i].onchange = null;
								this.HTMLElement.tBodies[0].rows[0].cells[i].onmousedown = null;
								this.HTMLElement.tBodies[0].rows[0].cells[i].onmouseup = null;
								this.HTMLElement.tBodies[0].rows[0].cells[i].onkeypress = null;
								this.HTMLElement.tBodies[0].rows[0].cells[i].onkeyup = null;
							}
						}
					}
				}
			}
			this.HTMLElement = null;
		}

		if (this.objWindow != null && this.objWindow.document != null && this.objWindow.document.body != null) {
			this.objWindow.document.body.onclick = null;
			this.objWindow.document.body.onfocus = null;
			this.objWindow.document.body.onblur = null;
			this.objWindow.document.body.onchange = null;
			this.objWindow.document.body.onmousedown = null;
			this.objWindow.document.body.onmouseup = null;
			this.objWindow.document.body.onmouseover = null;
			this.objWindow.document.body.onkeypress = null;
			this.objWindow.document.body.onkeydown = null;
			this.objWindow.document.body.onkeyup = null;
			this.objWindow.document.body.ondblclick = null;
			this.objWindow.document.body.onresize = null;
			this.objWindow.document.body.ondragover = null;
			this.objWindow.document.body.onbeforeunload = null;
			this.objWindow.document.body.onload = null;
			this.objWindow.document.body.onunload = null;
			this.objWindow.document.body.onchange = null;
		}
		this.objWindow = null;
		this.id	= null;
	} catch (error) {
	}
}

	

var m_strToggleFilter = null;
var m_strToggleBorder = null;

/** 
 * Constructor for the ToolbarButton object
 *
 * @param objHTMLELement The HTML button element.
 * @param objToolbar The toolbar on which this button exists.
 */
function ToolbarButton(objHTMLELement, objToolbar)
{
// properties
	this.HTMLElement			= objHTMLELement;
	this.id						= objHTMLELement.id;
	this.objToolbar				= objToolbar;
	this.arrOptions				= null;
	this.flgToggleButton		= false;
	this.moduleRequired			= null;
	this.haveModule				= true;
	
// methods
	this.getLabel				= ToolbarButton_getLabel;
	this.setLabel				= ToolbarButton_setLabel;
	this.toXML					= ToolbarButton_toXML;
	this.performADAPTScript		= ToolbarButton_performADAPTScript;
	this.enable					= ToolbarButton_enable;
	this.disable				= ToolbarButton_disable;
	this.isDisabled				= ToolbarButton_isDisabled;
	this.isVisible				= ToolbarButton_isVisible;
	this.hide					= ToolbarButton_hide;
	this.show					= ToolbarButton_show;
	this.setFocus				= ToolbarButton_setFocus;
	this.setTabIndex			= ToolbarButton_setTabIndex;
	this.getTabIndex			= ToolbarButton_getTabIndex;
	this.setTooltip				= ToolbarButton_setTooltip;
	this.getTooltip				= ToolbarButton_getTooltip;
	this.getOptionByID			= ToolbarButton_getOptionByID;
	this.toggle					= ToolbarButton_toggle;
	this.destroy				= ToolbarButton_destroy;
}

/** 
 * Used by ADAPT - returns an tree formatted xml representation of this object.
 *
 * @return The tree formatted xml representation of this object.
 */
function ToolbarButton_toXML()
{
	var strUID = this.objToolbar.id + "_" + this.id;
	
	var strXML = "<node uid='" + strUID + "' level='4' tooltip='" + this.getLabel() + "'>";
	strXML += "<vals>";
	strXML += "<val id='label'>" + this.id + "</val>";
	strXML += "<val id='name'>" + this.getLabel() + "</val>";
	strXML += "<val id='event1' parameter-name='objButton'>onBeforeClick</val>";
	strXML += "<val id='event2' parameter-name='objButton'>onAfterClick</val>";
	strXML += "</vals>";
	strXML += "</node>";

	return strXML;
}

/** 
 * Returns the toolbar button label text.
 *
 * @return The label text.
 */
function ToolbarButton_getLabel()
{
	var objLabels = this.HTMLElement.getElementsByTagName("LABEL");
	if (objLabels.length > 0)
		return objLabels[0].innerHTML;
	else
		return "";
}

/** 
 * Sets the toolbar button label text.
 *
 * @param The label text.
 */
function ToolbarButton_setLabel(strValue)
{
	this.HTMLElement.getElementsByTagName("LABEL")[0].innerHTML = strValue;
}

/** 
 * Fires any attached ADAPT javascript.
 *
 * @param flgEventType Binary operator parameter determines which event to fire.
 * @return Returns false if the adapt javascript decided to cancel the event.
 */
function ToolbarButton_performADAPTScript(flgEventType)
{
	var strMethodName;

	if (this.objToolbar.objWindow == null)
		return true;

	if (flgEventType & ADAPT_ONBEFORECLICK) {
		strMethodName = this.id + "_onBeforeClick";
	} else if (flgEventType & ADAPT_ONAFTERCLICK) {
		strMethodName = this.id + "_onAfterClick";
	} else {
		alert("Toolbar button event type not supported");
	}
	
	if (typeof(strMethodName) != "undefined" && this.objToolbar.objWindow[strMethodName] != null) {
		if (this.objToolbar.objWindow[strMethodName](this) == false) {
			return false;
		}
	}
	
	return true;
}

/** 
 * Enables a toolbar button
 */
function ToolbarButton_enable() {
	// Don't enable the button if the module it is dependent on is not in the licence
	if (this.haveModule == false)
		return;
		
	this.HTMLElement.disabled = false;
	
	if (this.arrOptions != null)
		this.HTMLElement.nextSibling.disabled = false;
}

/** 
 * Disables a toolbar button
 */
function ToolbarButton_disable()
{
	this.objToolbar.mouseout(this.HTMLElement);
	this.HTMLElement.disabled = true;
	
	if (this.arrOptions != null)
		this.HTMLElement.nextSibling.disabled = true;
}

/** 
 * Returns whether a toolbar button is currently disabled.
 *
 * @return Returns true if disabled - false if enabled.
 */
function ToolbarButton_isDisabled()
{
	return this.HTMLElement.disabled;
}

/** 
 * Returns whether a toolbar button is currently visible.
 *
 * @return Returns true if visible - false if not.
 */
function ToolbarButton_isVisible()
{
	return !(this.HTMLElement.style.display == "none");
}

/** 
 * Hides a toolbar button
 */
function ToolbarButton_hide()
{
	this.HTMLElement.style.display = "none";

	if (this.arrOptions != null)
		this.HTMLElement.nextSibling.style.display = "none";
}

/** 
 * Unhides a toolbar button
 */
function ToolbarButton_show()
{
	this.HTMLElement.style.display = "inline";

	if (this.arrOptions != null)
		this.HTMLElement.nextSibling.style.display = "inline";
}

/** 
 * Sets focus to toolbar button
 */
function ToolbarButton_setFocus()
{
	this.HTMLElement.focus();
}

/** 
 * Sets toolbar buttons tab index to the passed integer value
 *
 * @param intTabIndex supplies the integer value for setting the buttons tabIndex.
 */
function ToolbarButton_setTabIndex(intTabIndex)
{
	this.HTMLElement.tabIndex = intTabIndex;
}

/** 
 * Gets the toolbar buttons tabIndex value.
 *
 * @return Returns the integer value which indicates the tabIndex of the button.
 */
function ToolbarButton_getTabIndex()
{
	return this.HTMLElement.tabIndex;
}

/** 
 * Sets toolbar buttons tooltip to the passed string value
 *
 * @param strTooltipText supplies the string text for setting the buttons tooltip.
 */
function ToolbarButton_setTooltip(strTooltipText)
{
	this.HTMLElement.title = strTooltipText;
}

/** 
 * Gets the toolbar buttons tooltip text.
 *
 * @return Returns the string value of the buttons tooltip.
 */
function ToolbarButton_getTooltip()
{
	return this.HTMLElement.title;
}

/**
 * Constructor for toolbar button option object.
 */
function ToolbarButtonOption()
{
	this.onclick = null;
	this.image = null;
	this.label = null;
	this.tooltip = null;
	this.id = null;
	this.isDisabled = false;
	this.moduleRequired = null;
	this.haveModule = true;
	
	this.disable = ToolbarButtonOption_disable;
	this.enable = ToolbarButtonOption_enable;
	this.destroy = ToolbarButtonOption_destroy;
} 
	
/**
* Disable a button option
*/
function ToolbarButtonOption_disable() {
	this.isDisabled = true;
}

/**
* Enable a button option
*/
function ToolbarButtonOption_enable() {
	// Don't enable the button if the module it is dependent on is not in the licence
	if (this.haveModule == false)
		return;
		
	this.isDisabled = false;
}

/**
 * Clear references held in the toolbar button option object
 */
function ToolbarButtonOption_destroy() {
	try {
		this.onclick = null;
		this.image = null;
		this.label = null;
		this.tooltip = null;
		this.id = null;
	} catch (error) {
	}
}

/** 
 * Gets the a toolbar button option by ID.
 *
 * @return The button option.
 */
function ToolbarButton_getOptionByID(optionID) {
	if (this.arrOptions == null) {
		return null;
	} else {
		for (var i = 0, intLen = this.arrOptions.length; i < intLen; i++) {
			if (this.arrOptions[i].id == optionID) {
				return this.arrOptions[i];
			}
		}
		return null;
	}
}

/**
 * Toggle the state of a toggle button
 */
function ToolbarButton_toggle()
{
	if (this.HTMLElement.toggled == true)
	{
		this.HTMLElement.toggled = false;
		this.HTMLElement.style.filter = "";
		this.HTMLElement.style.backgroundColor = "transparent";
		this.HTMLElement.style.border = "none";
		this.HTMLElement.style.padding = "2px";
	}
	else
	{
		this.HTMLElement.toggled = true;
		if (m_strToggleFilter == null || m_strToggleBorder == null)
		{
			if ((typeof(objApplication) != "undefined" && objApplication.browser == APPLICATION_IE) || getCurrentBrowser() == APPLICATION_IE) {
				var objTmp = window.document.createElement("SPAN");
				objTmp.style.visibility = "hidden";
				objTmp.className = "toolbar-toggle-button";
				window.document.body.appendChild(objTmp);
				m_strToggleFilter = objTmp.currentStyle.filter;
				m_strToggleBorder = objTmp.currentStyle.borderStyle + " " + objTmp.currentStyle.borderColor + " " + objTmp.currentStyle.borderWidth;
				window.document.body.removeChild(objTmp);
			} else {
				m_strToggleFilter = "progid:DXImageTransform.Microsoft.Gradient(endColorstr='#FFAD55', startColorstr='#FFD58C', gradientType='0')";
				m_strTogleBorder = "black 1px solid";
			}
		}
		this.HTMLElement.style.filter = m_strToggleFilter;
		this.HTMLElement.style.border = m_strToggleBorder;
		this.HTMLElement.style.padding = "1px";
	}
}

/**
 * Clear references held in the toolbar button object
 */
function ToolbarButton_destroy() {
	try {
		if (this.HTMLElement != null) {
			this.HTMLElement.onclick = null;
			this.HTMLElement.onmouseover = null;
			this.HTMLElement.onmouseout = null;
			this.HTMLElement.onkeydown = null;
			this.HTMLElement.onfocus = null;
			this.HTMLElement.onblur = null;
			this.HTMLElement.onmousedown = null;
			this.HTMLElement.onmouseup = null;
			this.HTMLElement.onkeypress = null;
			this.HTMLElement.onkeyup = null;
			this.HTMLElement = null;
		}
		this.id	= null;
		this.objToolbar	= null;
		if (this.arrOptions != null) {
			for (var i = 0, len = this.arrOptions.length; i < len; i++) {
				this.arrOptions[i].destroy(); 
				this.arrOptions[i] = null;
			}
			this.arrOptions = null;
		}
	} catch(error) {
	}
}

	

//--------------------------------------------------------------------------------
// Main constructor for "Tree" object

var Tree_blankIndent = "<span style=\"padding:0px; margin-left:1px; width : 17px; height : 15px\">&#160;</span>";
var Tree_IIndent = "<img src=\"../GIF/giftreeviewI.gif\" align=\"absbottom\" style=\"padding:0px; margin-left:1px;\" width=\"17px\" height=\"16px\" />";

function Tree(objGrid, objWindow)
{
	// Properties
	this.Grid					= objGrid;
	this.Grid.isTreeGrid		= true;
	this.objWindow				= objWindow;
	this.onNodeExpand			= null;
	this.onNodeCollapse			= null;
	this.onTreeItemSelect		= null;
	this.onLeafIconClick		= null;
	this.arrContextOptions		= new Array();
	this.onDragStart			= null;
	this.onDragEnd				= null;
	this.autoCollapseTreeItems	= false;
	this.onTreeItemRightClick	= null;
	this.arrExpandedNodes		= null;
	this.arrSelectedNodes		= null;
	this.showMouseOver			= null;
	this.loadingNode			= null;
	
	// Methods
	this.toggleOpen				= Tree_toggleOpen;
	this.onClick				= Tree_onClick;
	this.dragStarted			= Tree_dragStarted;
	this.dragEnded				= Tree_dragEnded;
	this.onContextMenu			= Tree_onContextMenu;
	this.onMouseOver			= Tree_onMouseOver;
	this.onMouseOut				= Tree_onMouseOut;
	this.leafIconClick			= Tree_leafIconClick;

	// Events to handle the tree events
	this.evtDragStart				= Tree_evtDragStart;
	this.evtDragEnd				= Tree_evtDragEnd;
	this.evtContextMenu			= Tree_evtContextMenu;
	this.evtClick				= Tree_evtClick;
	this.evtDblClick				= Tree_evtDblClick;
	this.evtMouseOver				= Tree_evtMouseOver;
	this.evtMouseOut				= Tree_evtMouseOut;

	this.getTreeNode			= Tree_getTreeNode;
	this.getFirstNode			= Tree_getFirstNode;
	this.createTreeNode			= Tree_createTreeNode;
	this.addContextMenuOption	= Tree_addContextMenuOption;

	this.removeChildNodes	    = Tree_removeChildNodes;
	this.saveState				= Tree_saveState;
	this.restoreState			= Tree_restoreState;
	
	this.setRule				= Tree_setRule;
	this.removeRule				= Tree_removeRule;
	
	this.loadAllChildren		= Tree_loadAllChildren;
	
	this.getSelectedNodes		= Tree_getSelectedNodes;
	
	this.refresh				= Tree_refresh;
}

/** Get an array of selected nodes
 */
function Tree_getSelectedNodes() {
	// Now build up an array of selected nodes.	
	var arrNodes = new Array();
	var objTableRows = this.Grid.HTMLtable.tBodies[0].rows;
	for (var intCtr = 0; intCtr != objTableRows.length; intCtr++) {
		if (objTableRows[intCtr].selected == "true") {
			arrNodes[arrNodes.length] = new TreeNode(this.Grid, objTableRows[intCtr]);
		}
	}

	return arrNodes;
}

/** Called by the tree when the tree has recieved the 
 *  ondragstart event.  If required it calls the correct
 *  code to handle the event.
 */
function Tree_evtDragStart() {
	if (window.event.srcElement.doDrag == 'true') {
		this.dragStarted(window.event.srcElement);
	}
}

/** Called by the tree when the tree has recieved the 
 *  ondragend event.  If required it calls the correct
 *  code to handle the event.
 */
function Tree_evtDragEnd() {
	if (window.event.srcElement.doDrag == 'true') {
		this.dragEnded(window.event.srcElement);
	}
}

/** Called by the tree when the tress has recieved the 
 *  oncontextmenu event.  If required it calls the correct
 *  code to handle the event.
 */
function Tree_evtContextMenu() {
	if (window.event.srcElement.doContextMenu == 'true') {
		this.onContextMenu(window.event.srcElement);
	}
}

/** Called by the tree when the tress has recieved the 
 *  onclick event.  If required it calls the correct
 *  code to handle the event.
 */
function Tree_evtClick() {
	var srcElement = window.event.srcElement;
	var mode = srcElement.doOnClick
	if (mode == null) {
		return;
	}

	if (mode == 'toggle') {
		this.toggleOpen(srcElement);
	} else if (mode == 'leaf') {
		this.leafIconClick(srcElement);
	} else if (mode == 'onclick') {
		this.onClick(srcElement);
	} else {
		alert('unknown doOnClick ' + mode); 
	}
}

/** Called by the tree when the tress has recieved the 
 *  ondblclick event.  If required it calls the correct
 *  code to handle the event.
 */
function Tree_evtDblClick() {
	var srcElement = window.event.srcElement;
	var mode = srcElement.doOnDblclick;
	if (mode == null) {
		return;
	}

	if (mode == 'onclick') {
		this.onClick(srcElement);
	} else if (mode == 'toggle') {
		this.toggleOpen(srcElement);
	} else {
		alert('unknown doOnDblclick ' + mode); 
	}
}

/** Called by the tree when the tress has recieved the 
 *  onmouseover event.  If required it calls the correct
 *  code to handle the event.
 */
function Tree_evtMouseOver() {
	if (window.event.srcElement.doOnMouseover == 'true') {
		this.onMouseOver(window.event.srcElement);	}
}

/** Called by the tree when the tress has recieved the 
 *  onmouseout event.  If required it calls the correct
 *  code to handle the event.
 */
function Tree_evtMouseOut() {
	if (window.event.srcElement.doOnMouseout == 'true') {
		this.onMouseOut(window.event.srcElement);
	}
}

/** Get a tree node for a unique ID or null if it does not exist
 * @param strUniqueID The unique ID
 * @return The tree node
 */
function Tree_getTreeNode(strUniqueID)
{
	var objTR = this.Grid.HTMLtable.tBodies[0].rows[this.Grid.getRowIndex(strUniqueID)];
	if (objTR == null)
		return null;

	return new TreeNode(this.Grid, objTR);
}

/** Get the root node for the tree
 * @return the root node
 */
function Tree_getFirstNode() {
	var objTR = this.Grid.HTMLtable.tBodies[0].rows[0];
	return new TreeNode(this.Grid, objTR);
}

/** Function to create TreeNode objects elsewhere - used in ssGrid
 * @param objHTMLElement the html element for this node
 * @return the tree node
 */
function Tree_createTreeNode(objHTMLElement) {
	return new TreeNode(this.Grid, objHTMLElement);
}

/** Toggle between expanded and collapsed
 * @param objElement The HTML element of the node
 */
function Tree_toggleOpen(objElement)
{
	var objTreeNode = new TreeNode(this.Grid, objElement.parentElement.parentElement);

	var flgShow;
	if (objTreeNode.isCollapsed())
	{
		objTreeNode.setExpanded();
		flgShow = true;
	}
	else
	{
		objTreeNode.setCollapsed();
		flgShow = false;
	}

	if (flgShow && !isBlank(this.onNodeExpand)) {
		this.objWindow[this.onNodeExpand](objTreeNode);
	} else if (!flgShow && !isBlank(this.onNodeCollapse)) {
		this.objWindow[this.onNodeCollapse](objTreeNode);
	}
}

/** Onclick event
 * @param objElement The tree HTML element
 */
function Tree_onClick(objElement)
{
	if (!isBlank(this.onTreeItemSelect))
	{
		var objTreeNode = new TreeNode(this.Grid, objElement.parentElement.parentElement);
		this.objWindow[this.onTreeItemSelect](objTreeNode);
	}
}

/**
 * Called when a leaf level icon is clicked.  
 * Any method associated with the event is then carried out.
 */
function Tree_leafIconClick(objElement)
{
	if (!isBlank(this.onLeafIconClick))
	{
		var objTreeNode = new TreeNode(this.Grid, objElement.parentElement.parentElement);
		this.objWindow[this.onLeafIconClick](objTreeNode);
	}
}

/**
 * Displays the context menu if there are any context menu options to display.
 */
function Tree_onContextMenu(objElement)
{
	if (this.arrContextOptions.length == 0)
	{
		var objTreeNode = new TreeNode(this.Grid, objElement.parentElement.parentElement);
		if (!isBlank(this.onTreeItemRightClick)) {
			this.objWindow[this.onTreeItemRightClick](objTreeNode);
		}
		return;
	}
		
	var contextMenu  = new ContextMenu();
	var objOption;
	var flgDisabled;

	for (var intCtr=0; intCtr < this.arrContextOptions.length; intCtr++)
	{
		objOption = this.arrContextOptions[intCtr];
		flgDisabled = false;

		if (objOption.buttonId != "" && objOption.buttonId != null)
			flgDisabled = window.document.getElementById(objOption.buttonId).disabled;

		if (objOption.actionObject != null && typeof(objOption.actionObject) == "string")
			objOption.actionObject = eval(objOption.actionObject);

		if (objOption.methodName.indexOf("()") != -1 || objOption.methodName.indexOf("(") == -1)
			contextMenu.addOption(objOption.label, objOption.imageName, eval(objOption.methodName.replace("()", "")), null, null, null, null, false, null, flgDisabled, objOption.tooltip, objOption.actionObject);
	}

	contextMenu.show(getPosX(event), getPosY(event));

	event.cancelBubble = true;
	event.returnValue = false;
}

function Tree_addContextMenuOption(strLabel, strMethodName, strImageName, strButtonId, tooltip, actionObject)
{
	if (actionObject == null && strMethodName.indexOf(".") != -1)
		actionObject = strMethodName.substring(0, strMethodName.indexOf("."));

	this.arrContextOptions[this.arrContextOptions.length] = new TreeContextOption(strLabel, strMethodName, strImageName, strButtonId, tooltip, actionObject);
}

function TreeContextOption(strLabel, strMethodName, strImageName, strButtonId, tooltip, actionObject)
{
	this.label = strLabel;
	this.methodName = strMethodName;
	this.imageName = strImageName;
	this.buttonId = strButtonId;
	this.tooltip = tooltip;
	this.actionObject = actionObject;
}

function Tree_onMouseOver(objElement)
{
	if (this.showMouseOver != "false")
	{
		objElement.style.color = "red";
    	objElement.style.textDecoration = "underline";
	}
}

function Tree_onMouseOut(objElement)
{
	if (this.showMouseOver != "false")
	{
		objElement.style.color = "black";
    	objElement.style.textDecoration = "none";
	}
}

function Tree_loadAllChildren() {
	var tNode = this.getFirstNode();
	
	while (tNode != null) {
		tNode.loadAllChildren();
		tNode = tNode.getNextSibling();
	}
}

//Constructor for TreeNode object
function TreeNode(objGrid, objHTMLElement)
{
	// Properties
	this.Grid				= objGrid;
	this.objHTMLElement		= objHTMLElement;
	this.reloadDynamicNodes	= false;

	// Methods
	this.getParentNode		= TreeNode_getParentNode;
	this.isCollapsed		= TreeNode_isCollapsed;
	this.getLevel			= TreeNode_getLevel;
	this.getNextNode		= TreeNode_getNextNode;
	this.show				= TreeNode_show;
	this.hide				= TreeNode_hide;
	this.setExpanded		= TreeNode_setExpanded;
	this.setCollapsed		= TreeNode_setCollapsed;
	this.hasCollapsedParent = TreeNode_hasCollapsedParent;
	this.getNextSibling		= TreeNode_getNextSibling;
	this.getPreviousSibling	= TreeNode_getPreviousSibling;
	this.getNodeValues		= TreeNode_getNodeValues;
	this.getID				= TreeNode_getID;
	this.getIcon			= TreeNode_getIcon;
	this.getNodeLabel		= TreeNode_getNodeLabel;
	this.getChildCount		= TreeNode_getChildCount;
	this.updateGifs			= TreeNode_updateGifs;
	this.getChildren		= TreeNode_getChildren;
	this.getLastChild		= TreeNode_getLastChild;
	this.getLastVisibleChild = TreeNode_getLastVisibleChild;
	this.hasChildren		= TreeNode_hasChildren;
	this.updateNode			= TreeNode_updateNode;
	this.hasRule			= TreeNode_hasRule;
	this.hasHideRule		= TreeNode_hasHideRule;
	this.getRule			= TreeNode_getRule;
	this.addChildNodes		= TreeNode_addChildNodes;
	this.loadChildren		= TreeNode_loadChildren;
	this.loadChildrenHTML	= TreeNode_loadChildrenHTML;
	this.loadAllChildren	= TreeNode_loadAllChildren;
	this.getIndent		= TreeNode_getIndent;
	this.removeChildNodes	= TreeNode_removeChildNodes;
	this.getColumnValue	= TreeNode_getColumnValue;
	this.getRow			= TreeNode_getRow;
}

function TreeNode_getNodeValues()
{
	var arrValues = new Array();
	var length = this.objHTMLElement.cells.length;
	var numChildren;

	for (var i=0; i < length; i++)
	{
		if (this.objHTMLElement.cells[i].children.length > 0)
		{
			numChildren = this.objHTMLElement.cells[i].children.length;
			arrValues[i] = this.objHTMLElement.cells[i].children[numChildren-1].innerHTML;
		}
		else
		{
			arrValues[i] = this.objHTMLElement.cells[i].innerHTML;
		}
	}

	return arrValues;
}

function TreeNode_hasCollapsedParent()
{
	var flgReturn = false;
	var objTreeNode = this.getParentNode();

	while (objTreeNode != null)
	{
		if (objTreeNode.isCollapsed())
		{
			flgReturn = true;
			break;
		}
		objTreeNode = objTreeNode.getParentNode()
	}
	return flgReturn;
}

function TreeNode_show()
{	
	this.objHTMLElement.style.display = "inline";
	this.updateGifs();
}

function TreeNode_hide()
{
	this.objHTMLElement.style.display = "none";
}

function TreeNode_getNextNode()
{
	if (this.objHTMLElement.nextSibling != null)
		return new TreeNode(this.Grid, this.objHTMLElement.nextSibling);
}

/**
 * Loop through next nodes and gets next sibling (on the same level) to this node.
 * @param blnUseRules optional - should we use rules or not
 * @return the next sibling if one exists or null if not.
 */
function TreeNode_getNextSibling(blnUseRules)
{
	for(var objElement = this.objHTMLElement.nextSibling; objElement != null && Number(objElement.level) >= this.getLevel(); objElement = objElement.nextSibling)
	{
		if (Number(objElement.level) == this.getLevel())
		{
			var objNode = new TreeNode(this.Grid, objElement);
			if (blnUseRules == true) {
				if (objNode.hasHideRule()) {
					continue;
				}
			}
			return objNode;
			break;
		}
	}
}

/**
 * Loop through previous nodes and gets previous sibling (on the same level) to this node.
 * @param blnUseRules optional - should we use rules or not
 * @return the previous sibling if one exists or null if not.
 */
function TreeNode_getPreviousSibling(blnUseRules)
{
	for(var objElement = this.objHTMLElement.previousSibling; objElement != null && Number(objElement.level) >= this.getLevel(); objElement = objElement.previousSibling)
	{
		if (Number(objElement.level) == this.getLevel())
		{
			var objNode = new TreeNode(this.Grid, objElement);
			if (blnUseRules == true) {
				if (objNode.hasHideRule()) {
					continue;
				}
			}
			return objNode;
			break;
		}
	}
}

function TreeNode_getLevel()
{
	return Number(this.objHTMLElement.level)
}

function TreeNode_isCollapsed()
{
	return (this.objHTMLElement.collapsed == "true");
}

function TreeNode_getParentNode()
{
	var objPreviousTR = this.objHTMLElement.previousSibling;

	while (objPreviousTR != null)
	{
		if (Number(objPreviousTR.level) == Number(this.objHTMLElement.level) - 1)
			return new TreeNode(this.Grid, objPreviousTR);

		objPreviousTR = objPreviousTR.previousSibling;
	}
	return null;
}

function TreeNode_setExpanded()
{
	var blnHasActiveRule = this.hasRule(true);
	var loadedChildren = false;
	this.objHTMLElement.collapsed = "false";
	
	if (this.objHTMLElement.loadChildren == "true") {
		// load the children
		this.loadChildren();
		loadedChildren = true;
	}
	
	if (!this.hasChildren()) {
		// Still no children!
		return;
	}

	var objTDContents = this.objHTMLElement.cells[1].children;
	if (this.getNextSibling() != null)
		objTDContents[objTDContents.length - 3].src = "../GIF/giftreeviewTminus.gif";
	else
		objTDContents[objTDContents.length - 3].src = "../GIF/giftreeviewLminus.gif";

	objTDContents[objTDContents.length - 3].title = fl("COLLAPSE");

	if (objTDContents[objTDContents.length - 2] != null)
	{	
		var objCurrentHTMLElement = objTDContents[objTDContents.length - 2];
		if (objCurrentHTMLElement.tagName == 'IMG' && objCurrentHTMLElement.src.indexOf("giftreeviewfoldericon.gif") != -1)
			objCurrentHTMLElement.src = "../GIF/giftreeviewopenfoldericon.gif";
	}

	// Set any grid rules for child nodes
	if (blnHasActiveRule) {
		var objNextNode = this.getNextNode();
		while (objNextNode != null)
		{
			if (objNextNode.getLevel() <= this.getLevel())
				break;

			// only do rules this node if parent is set as expanded.
			if (objNextNode.hasCollapsedParent() == false)
			{
				var objRow = objNextNode.getRow();
				this.Grid.processAllRules(objRow);
				objNextNode.updateGifs();
			}
			objNextNode = objNextNode.getNextNode();
		}
	}

	// Only need to show the children if not loaded (loaded children will be displayed)
	if (!loadedChildren) {
		var objNextNode = this.getNextNode();
		while (objNextNode != null)
		{
			if (objNextNode.getLevel() <= this.getLevel())
				break;

			// only show this node if parent is set as expanded.
			if (objNextNode.hasCollapsedParent() == false)
			{
				// only show this node if it has not been hidden by any rule.
				if (!objNextNode.hasHideRule())
					objNextNode.show();
			}

			objNextNode = objNextNode.getNextNode();
		}
	}
	
	// If auto collapse tree items is on then collapse all siblings of this node.
	if (this.Grid.Tree.autoCollapseTreeItems == true)
	{
		for (var objLoopNode = this.getNextSibling(); objLoopNode != null; objLoopNode = objLoopNode.getNextSibling())
		{
			if (!objLoopNode.isCollapsed())
				objLoopNode.setCollapsed();
		}
			
		for (var objLoopNode = this.getPreviousSibling(); objLoopNode != null; objLoopNode = objLoopNode.getPreviousSibling())
		{
			if (!objLoopNode.isCollapsed())
				objLoopNode.setCollapsed();
		}
	}

	if (this.Grid.scrollIntoView == true) {
		// Need to scroll the view to display the last child
		// Logic is a bit complicated. Following situations are possible
		// 1) Don't need to scroll the view - all the children are visible
		// *if the last child is not visible then*
		// 2) display is large enough to hold all the children 
		//    so scroll the last child to the bottom
		// 3) display is too small to hold all the children
		//    so scroll the parent to the top of the view
		var lastChild = this.getLastVisibleChild();
		
		if (lastChild != null)
		{
			// Check if the last child is visible
			if (lastChild.objHTMLElement.offsetTop + lastChild.objHTMLElement.offsetHeight > this.Grid.HTMLdiv.scrollTop + this.Grid.HTMLdiv.clientHeight) {
				// Last child is not visible so how do we scoll?
				if (lastChild.objHTMLElement.offsetTop + lastChild.objHTMLElement.offsetHeight - this.objHTMLElement.offsetTop < this.Grid.HTMLdiv.clientHeight) {
					// DIV will show this and all it's children
					// Scroll last child to the bottom of the window - so all children are displayed
					// and the window will be scrolled the least amount
					lastChild.objHTMLElement.scrollIntoView(false); // false for scroll to bottom
				} else {
					// DIV will not show this and all it's children
					// Scroll this element to the top of the window - so the window is full of children
					this.objHTMLElement.scrollIntoView(true); // true for scroll to top
				}
			}
		}
	}
}

function TreeNode_setCollapsed()
{
	var blnHasActiveRule = this.hasRule(true);
	this.objHTMLElement.collapsed = "true";
	
	var objTDContents = this.objHTMLElement.cells[1].children;
	if (this.getNextSibling() != null)
		objTDContents[objTDContents.length - 3].src = "../GIF/giftreeviewTplus.gif";
	else
		objTDContents[objTDContents.length - 3].src = "../GIF/giftreeviewLplus.gif";

	objTDContents[objTDContents.length - 3].title = fl("EXPAND");

	if (objTDContents[objTDContents.length - 2] != null)
	{	
		if (objTDContents[objTDContents.length - 2].tagName == 'IMG' && objTDContents[objTDContents.length - 2].src.indexOf("giftreeviewopenfoldericon.gif") != -1)
			objTDContents[objTDContents.length - 2].src = "../GIF/giftreeviewfoldericon.gif";
	}

	// Delete children if reloading dynamic nodes and this node was loaded
	if (this.reloadDynamicNodes
		&& (this.objHTMLElement.loadChildren == "loaded")) {
		this.removeChildNodes();
		
		// Reset to reload!
		this.objHTMLElement.loadChildren = "true";
	} else {
		// Hide the child nodes
		var objNextNode = this.getNextNode();
		while (objNextNode != null)
		{
			if (objNextNode.getLevel() <= this.getLevel())
				break;

			// Hide the nodes
			objNextNode.hide();
			objNextNode = objNextNode.getNextNode();
		}
	}
}

/**
 * Gets the unique ID of the selected node
 * @return the unique ID
 */
function TreeNode_getID()
{
	return unescapeXML(this.objHTMLElement.cells[0].innerHTML);
}

/**
 * Gets the text that is actually displayed against the node in the tree
 * @return the node label or an empty string if no label found.
 */
function TreeNode_getNodeLabel()
{
	var objTDContents = this.objHTMLElement.cells[1].children;
	if (objTDContents[objTDContents.length - 1] != null)
	{
		return unescapeXML(objTDContents[objTDContents.length - 1].innerHTML);
	}
	return "";
}

/**
 * Gets the icon for this particular node (nb This is not the 
 * + or - expand/collapse, but the actual icon).
 * @return the icon name (or an empty string if no icon)
 */
function TreeNode_getIcon()
{
	var objTDContents = this.objHTMLElement.cells[1].children;
	
	if (objTDContents[objTDContents.length - 2] != null)
	{
		// Only interested in the actual gif name
		var fullPath = objTDContents[objTDContents.length - 2].src;
		return fullPath.substr(fullPath.lastIndexOf("/GIF/") + 5);
	}
	
	// No icon specified so return an empty string
	return "";
}

/**
 * Called when an icon is initially dragged.
 */
function Tree_dragStarted(objElement)
{
	if (!isBlank(this.onDragStart))
	{
		var objTreeNode = new TreeNode(this.Grid, objElement.parentElement.parentElement);
		this.objWindow[this.onDragStart](objTreeNode);
	}
}

/**
 * Called when an icon drag is ended.
 */
function Tree_dragEnded(objElement)
{
	if (!isBlank(this.onDragEnd))
	{
		var objTreeNode = new TreeNode(this.Grid, objElement.parentElement.parentElement);
		this.objWindow[this.onDragEnd](objTreeNode);
	}
}

/**
 *	Removes all child nodes of the specified uniqueid.
 *	@param uniqueid - The uniqueid of which to remove all child nodes.
 */
function Tree_removeChildNodes(uniqueid)
{
	var tNode = this.getTreeNode(uniqueid);
	
	if (tNode) {
		tNode.removeChildNodes();
	}
}

/**
 *	Stores the expanded state of all nodes.
 */
function Tree_saveState()
{
	var tRootNode = this.getFirstNode();
	
	this.arrExpandedNodes = new Array();
	var position = 0;
	
	for (var tNextNode = tRootNode; tNextNode != null; tNextNode = tNextNode.getNextNode())
	{
		if (!tNextNode.isCollapsed())
		{
			this.arrExpandedNodes[position] = tNextNode.getID();		
			position++;
		}
	}
	
	this.arrSelectedNodes = this.Grid.getSelectedColumnValue("uniqueid");
}

/**
 *	Restores the expanded state of all nodes.
 */
function Tree_restoreState()
{
	for (var i=0; i < this.arrExpandedNodes.length; i++)
	{
		var tNode = this.getTreeNode(this.arrExpandedNodes[i]);
		if (tNode != null)
			tNode.setExpanded();
	}
	this.arrExpandedNodes = null;
	
	for (var i=0; i < this.arrSelectedNodes.length; i++) {
		this.Grid.selectRow(this.arrSelectedNodes[i], true);
	}
	this.arrSelectedNodes = null;
}

/** Refresh the tree
 */
function Tree_refresh() {
	// Reload the tree - NB this is the best way in general
	// because the nodes effected might be reused accross the tree
	this.saveState();
	this.Grid.setupWithDataEngine();
	this.restoreState();
}

/**
 *	Gets the number of children of the currently selected item.
 *	@return Number of children.
 */
function TreeNode_getChildCount()
{
	var count = 0;
	var level = this.getLevel();
	var tChildNode = this.getNextNode();
	
	while (tChildNode != null && tChildNode.getLevel() == level+1)
	{
		count++;
		tChildNode = tChildNode.getNextSibling();		
	}
	return count;
}

/**
 *	Applies a rule to the current tree grid.
 *	@param ruleID - A unique string identifier for this rule.
 *	@param ruleScript - A predicate consisting of a string of valid JavaScript.
 *	@param ruleCommand - The type of rule being applied, i.e. HIDE/HIGHLIGHT.
 *	@param cssClassName - A className reference supplying HIGHLIGHT colours.
 */
function Tree_setRule(ruleID, ruleScript, ruleCommand, cssClassName)
{
	// First apply this rule to the Grid data.
	this.Grid.setRule(ruleID, ruleScript, ruleCommand, cssClassName);
	
	// If this is a HIDE rule then we need to hide the appropriate children.
	if (ruleCommand == "HIDE")
	{
		// Get the actual rows that satisfy this rule criterion.
		var arrRows = this.Grid.getRuleRows(ruleID);

		for (var i=0; i<arrRows.length; i++)
		{
			var objTreeNode = new TreeNode(this.Grid, arrRows[i].HTMLElement);

			// If this row has children then hide them.
			// NB only interested in children that count under the rule
			// because other children will already be hidden
			if (objTreeNode.hasChildren(true))
			{
				var arrChildNodes = objTreeNode.getChildren(true);
				for (var f=0; f<arrChildNodes.length; f++)
				{
					arrChildNodes[f].objHTMLElement.style.display = "none";				
				}
				
				// We now have to alter the state of this parent node.
				objTreeNode.objHTMLElement.collapsed = "true";
			}
			
			// Now set the appropriate L or T gifs for the current row of the tree.
			objTreeNode.updateGifs();
		}
	}
}

/**
 *	Gets the children of this tree node
 *  @param boolean blnUseRules optional - take into account rules.
 *	@return An array of TreeNodes that are the children of this node.
 */
function TreeNode_getChildren(blnUseRules)
{
	var arrNodes = new Array();
	for (var objChildNode = this.getNextNode(); objChildNode != null && (Number(objChildNode.getLevel()) > Number(this.getLevel())); objChildNode = objChildNode.getNextNode())
	{
		if (blnUseRules == true) {
			if (objChildNode.hasHideRule()) {
				continue;
			}
		}
		arrNodes[arrNodes.length] = objChildNode;
	}
	return arrNodes;
}

/**
 *	Gets the last child of this tree node
 *  @param boolean blnUseRules optional - take into account rules.
 *	@return The last child or null.
 */
function TreeNode_getLastChild(blnUseRules) {
	var lastChild = null;
	for (var objChildNode = this.getNextNode(); objChildNode != null && (Number(objChildNode.getLevel()) > Number(this.getLevel())); objChildNode = objChildNode.getNextNode())
	{
		if (blnUseRules == true) {
			if (objChildNode.hasHideRule()) {
				continue;
			}
		}
		lastChild = objChildNode;
	}
	
	return lastChild;
}

/**
 * Gets the last visible child of this tree node
 * @return The last visible child or null if no children
 */
function TreeNode_getLastVisibleChild() {
	var lastChild = null;
	for (var objChildNode = this.getNextNode(); objChildNode != null && (Number(objChildNode.getLevel()) > Number(this.getLevel())); objChildNode = objChildNode.getNextNode())
	{
		if (objChildNode.objHTMLElement.style.display == "none") {
				continue;
		}
		
		lastChild = objChildNode;
	}
	
	return lastChild;
}

/**
 *	Has this node got children?
 *  @param boolean blnUseRules optional - take into account rules.
 *	@return boolean true if there are any children
 */
function TreeNode_hasChildren(blnUseRules)
{
	if (this.objHTMLElement.loadChildren == "true") {
		if (blnUseRules == true && this.hasRule(true)) {
			// Need to load the children so that we can check the rule
			this.loadChildren();
		} else {
			// No rule so there are children (just not loaded)
			return true;
		}
	}
	
	var arrNodes = new Array();
	var thisNodeLevel = Number(this.getLevel());
	for (var objChildNode = this.getNextNode(); objChildNode != null && (Number(objChildNode.getLevel()) > thisNodeLevel); objChildNode = objChildNode.getNextNode())
	{
		if (blnUseRules == true) {
			if ((Number(objChildNode.getLevel()) != (thisNodeLevel + 1))
				|| objChildNode.hasHideRule()) {
				continue;
			}
		}
		return true;
	}
	return false;
}

/** Update this node graphic and events etc
 * to the appropriate L or T...
 * The 2 parameters are to optimize this method if the details are
 * already known.
 * @paran blnHasNextSibling Optional Has this a next sibling or null if unknown
 * @param blnIsParent Optional Is this a parent node or null if unknown
 */
function TreeNode_updateNode(blnHasNextSibling, blnIsParent) {
	// Work out if it is an L or a T
	// Find the next sibling that is not hidden
	if (blnHasNextSibling == null) {
		blnHasNextSibling = false;
		var sibling = this.getNextSibling(true);
		if (sibling != null) {
			blnHasNextSibling = true;
		}
	}
	// Use an L if no next sibling
	var strLorT;
	if (blnHasNextSibling) {
		strLorT = "T";
	} else {
		strLorT = "L";
	}
	
	if (blnIsParent == null) {
		// Get the child nodes taking into account of rules
		if (this.hasChildren(true)) {
			blnIsParent = true;
		} else {
			blnIsParent = false;
		}
	}
	
	var strPlusMinus;
	var strCursor;
	var strTitle;
	if (blnIsParent) {
		// Has children must be a + or -
		if (this.isCollapsed()) {
			strPlusMinus = "plus";
			strTitle = "Expand";
		} else {
			strPlusMinus = "minus";
			strTitle = "Collapse";
		}
		strCursor = "hand";
	} else {
		strPlusMinus = "";
		strCursor = "default";
		strTitle = "";
	}
		 
	var strGif = "../GIF/giftreeview" + strLorT + strPlusMinus + ".gif";
	
	var objTDContents = this.objHTMLElement.cells[1].children;
	var objHTMLElement = objTDContents[objTDContents.length - 3];
	objHTMLElement.src = strGif;
	objHTMLElement.style.cursor = strCursor;
	objHTMLElement.title = strTitle;
}

/**
 *	Updates this TreeNodes graphic to the appropriate L or T or derivative.
 */
function TreeNode_updateGifs()
{
	var blnThisIsHidden = this.hasHideRule();
	
	// Update this node
	this.updateNode();
	// Update parent
	var objParentNode = this.getParentNode();
	if (objParentNode != null) {
		objParentNode.updateNode(null, blnThisIsHidden ? null: true);
	}
	// Update previous sibling (if any) if this is the last node
	var objPreviousSibling = this.getPreviousSibling(true);
	if (objPreviousSibling != null) {
		objPreviousSibling.updateNode(blnThisIsHidden ? null: true, null);
		
		if (this.getNextSibling(true) == null) {
			// Update I gifs for children of the previous sibling - not needed now
			var arrPreviousChildren = objPreviousSibling.getChildren();
			
			// Update I icons at the level [minus 1 for array index]
			var intIconPos = this.getLevel() - 1;
			for (var i=0; i < arrPreviousChildren.length; i++)
			{
				var objTDContents = arrPreviousChildren[i].objHTMLElement.cells[1].children;

				var objCurrentHTMLElement = objTDContents[intIconPos];
				if (blnThisIsHidden) {
					if (objCurrentHTMLElement.tagName == 'IMG') {
						objCurrentHTMLElement.style.visibility = "hidden";
					}
				} else {
					if (objCurrentHTMLElement.tagName == 'IMG') {
						objCurrentHTMLElement.src = "../GIF/giftreeviewI.gif";
						objCurrentHTMLElement.style.visibility = "visible";
					}
				}
			}
		}
	}
}

/**
 *	Removes (turns off) the specified rule.
 *	@param A unique string ID reference for this rule.
 */
function Tree_removeRule(strID)
{
	this.Grid.removeRule(strID);
	var arrRows = this.Grid.getRuleRows(strID);
	if (arrRows == null)
		return;
		
	for (var i=0; i<arrRows.length; i++)
	{
		var objTreeNode = new TreeNode(this.Grid, arrRows[i].HTMLElement);
		objTreeNode.updateGifs();
	}
}

/** Determines if this node has an rule that is active
 * @param blnOnlyActive optional default false if true then only include rules that are active
 * @return boolean true if there are any rules
 */
function TreeNode_hasRule(blnOnlyActive) {
	if (blnOnlyActive != true)
		blnOnlyActive = false;
	var blnHasRule = false;
	for (var i = 0; i < this.Grid.arrRules.length; i++) {
		if (!blnOnlyActive || this.Grid.arrRules[i].ruleApply) {
			blnHasRule = true;
			break;
		}
	}
	
	return blnHasRule;
}

/** Determines if this node has a hide rule
 * @return boolean true if there is a hide rule
 */
function TreeNode_hasHideRule() {
	var arrRulesApplied = this.getRow().rulesApplied;
	for (var x = arrRulesApplied.length - 1; x >= 0; x--)
	{
		var objRule = this.getRule(arrRulesApplied[x]);
		if (objRule.ruleType == "HIDE") {
			return true;
		}
	}
	return false;
}

/** Get a rule by ID
 * @param strID Rule ID
 */
function TreeNode_getRule(strID) {
	var arrRules = this.Grid.arrRules;
	
	for (var i = arrRules.length - 1; i >= 0; i--)
	{
		var rule = arrRules[i];
		if (rule.ruleID == strID)
		{
			return rule;
		}
	}
	
	return null;
}

/** Get the indent for children
 * @return the HTML
 */
function TreeNode_getIndent() {
	var arrCells = this.objHTMLElement.cells;
	var strIndentHTML = "";
	
	for (var objNode = this; objNode != null; objNode = objNode.getParentNode()) {
		var indentHTML;
		if (objNode.getNextSibling() == null) {
			// Last node - blank indent
			indentHTML = Tree_blankIndent;
		} else {
			// Not last node - I image
			indentHTML = Tree_IIndent;
		}
		strIndentHTML = indentHTML + strIndentHTML;
	}

	return strIndentHTML;
}

/** Load the child nodes using data engine and add the HTML to this node
 */
function TreeNode_loadChildren() {
	var strHTML = this.loadChildrenHTML();

	if (!isBlank(strHTML))
		this.addChildNodes(strHTML);
		
	this.objHTMLElement.loadChildren = "loaded";
}

/** Load the child nodes HTML using data engine
 */
function TreeNode_loadChildrenHTML() {
	// Used for grid binding - use this node from the grid to bind to
	this.Grid.Tree.loadingNode = this;

	var loadDataEngine;
	if (this.Grid.treeDataEngine != null)
		loadDataEngine = this.Grid.treeDataEngine;
	else
		loadDataEngine = this.Grid.DataEngine;
	loadDataEngine.standardTransform = false;
	if (loadDataEngine.arrXSLTParamNames.length == 0)
	{
		loadDataEngine.addXSLTParam("localeLanguageCode", objApplication.User.localeid);
		loadDataEngine.addXSLTParam("baseURL", window.document.URL);
		loadDataEngine.addXSLTParam("relativeURL", "../XML/xmlRegionalSettings.xml");
		loadDataEngine.addXSLTParam("gridID", this.Grid.id);
		loadDataEngine.addXSLTParam("gridURL", "http://" + objApplication.Connection.applicationServer + "/efacs/" + objApplication.User.languageDirectory + "/Grids/" + this.Grid.strSrc);
	}

	var strHTML = loadDataEngine.populateEngine();
	
	// Remove grid binding now - used so you can call grid setupWithDataEngine()
	this.Grid.Tree.loadingNode = null;
	
	if (objApplication.hadCriticalError)
		return "";
		
	return strHTML;
}

/** Load the child HTML for all the children recursively
 */
function TreeNode_loadAllChildren() {
	var currentNode = this;
	var collapse = this.isCollapsed();
	var thisLevel = this.getLevel();
	
	if (currentNode.objHTMLElement.loadChildren == "true") {
		// load the children
		currentNode.loadChildren();
	}
	
	for (currentNode = currentNode.getNextNode(); currentNode != null && currentNode.getLevel() > thisLevel; currentNode = currentNode.getNextNode()) {
		if (currentNode.objHTMLElement.loadChildren == "true") {
			// load the children
			currentNode.loadChildren();
		}
		
		// If this node is collapsed then make sure the child
		// nodes are - but there children will still be loaded.
		if (thisLevel == currentNode.getLevel() - 1) {
			if (!collapse) {
				currentNode.setCollapsed();
			}
		}
	
	if (collapse) {
			currentNode.objHTMLElement.style.display = "none";
		}
	}
	
}

/**
 * Add child nodes
 * @param uniqueid - the uniqueid of the parent node
 * @param treeXML - the tree HTML to add
 */
function TreeNode_addChildNodes(treeHTML) {
	var intChildLvl = this.getLevel() + 1;
	var blnHasActiveRule = this.hasRule(true);
	var blnNodeCollapsed = this.isCollapsed();
		
	// Put HTML into an element
	var objDoc = this.Grid.objAppWindow.document;
	var objDiv = objDoc.createElement("div");
	objDiv.innerHTML = escapeStringDoubleSpaces(treeHTML);
	var arrSourceRows = objDiv.childNodes(0).tBodies[0].rows;
	var nodeIndex = this.objHTMLElement.rowIndex + 1;
	var targetTable = this.Grid.HTMLtable;
	var htmlIndent = this.getIndent();
	
	var objIndentDiv = objDoc.createElement("div");
	objIndentDiv.innerHTML = htmlIndent;
	
	for (var i = arrSourceRows.length - 1; i >= 0; i--) {
		// For collapsed nodes hide the nodes as we add them
		if (blnNodeCollapsed)
			arrSourceRows[i].style.display = "none";

		// Swap in 1 node
		targetTable.insertRow(nodeIndex);
		targetTable.rows(nodeIndex).swapNode(arrSourceRows[i]);
		targetTable.rows(nodeIndex).level = intChildLvl;
		
		// Swap in indent
		var arrIndentNodes = objIndentDiv.childNodes;
		var targetCell = targetTable.rows(nodeIndex).cells(1);
		var firstChild = targetCell.childNodes[0];
		var nodesLen = arrIndentNodes.length;
		for (var idx = 0; idx < nodesLen; idx++) {
			targetCell.insertBefore(arrIndentNodes[idx].cloneNode(true), firstChild);
		}
	}
}

/** Remove the child nodes from a tree
 */
function TreeNode_removeChildNodes() {
		var tChildNode = this.getNextNode();
		while (tChildNode != null && Number(this.getLevel()) < Number(tChildNode.getLevel()))
		{
			tNextChildNode = tChildNode.getNextNode();
			var nodeID = tChildNode.getID();
			this.Grid.deleteRow(nodeID);
			tChildNode = tNextChildNode;
		}
}

/** Get column value
 * @param strColumn name of the column
 * @return the value of the column
 */
function TreeNode_getColumnValue(strColumnName)
{
	// Get cell index for required column.
	var intCellIndex = this.Grid.getColumnCellIndex(strColumnName);

	var objTD = this.objHTMLElement.cells[intCellIndex];
	var strValue;
	if (objTD.childNodes.length > 1)
		strValue = unescapeXML(objTD.lastChild.innerHTML);
	else
		strValue = unescapeXML(objTD.innerHTML);

	var objHeadTD = this.Grid.HTMLtable.tHead.rows[0].cells[intCellIndex];
	if (intCellIndex > 0 &&
		(objHeadTD.type == "xsd:float" || objHeadTD.type == "xsd:double" ||
		 objHeadTD.type == "xsd:integer" || objHeadTD.type == "xsd:short" ||
	     objHeadTD.type == "xsd:smallint" || objHeadTD.type == "xsd:decimal"))
	{
		var intNum = Number(util_parseNumber(strValue));
		if (!isNaN(intNum))
			strValue = intNum;
	}
	
	if (strValue == "")
	{
		if (objTD.style.backgroundImage.indexOf("checkBoxTicked") != -1)
			strValue = cb_CHECKED;
		else if (objTD.style.backgroundImage.indexOf("checkBoxNotTicked") != -1)
			strValue = cb_UNCHECKED;
	}
	return strValue;
}

/** Faster version of getRow from grid for tree nodes - no need to search by unique
 * ID since we already have the HTML element
 */
function TreeNode_getRow()
{
	var objRow = this.objHTMLElement;
	return new Row(objRow, this.Grid);
}




function User() {

//properties

	this.objUserXML					= null;

	this.userID						= null;
	this.userName					= null;
	this.logUser					= null;	
	this.company					= null;
	this.companyName				= null;
	this.language					= null;
	this.localeid					= null;
	this.languageName				= null;
	this.languageDirectory			= null;
	this.selectedMenuItem			= null;
	this.selectedMenuItemName		= null;
	this.crystalReportSettings		= null;
	this.homeCurrency				= null;
	this.homeCurrencyDescription	= null;
	this.homeCurrencySymbol			= null;
	this.cssGroupID					= null;

//methods

	this.setupFromXML				= User_setupFromXML;
	this.getHomeCurrencySymbol		= User_getHomeCurrencySymbol;
}

function User_setupFromXML(objXML) {
	this.objUserXML = objXML;
	
	if (objXML != null) {
		this.userID				= this.objUserXML.selectSingleNode("/userdata/id").getText();
		this.userName				= this.objUserXML.selectSingleNode("/userdata/username").getText();
		this.logUser				= this.objUserXML.selectSingleNode("/userdata/logactivity").getText();
		this.company				= this.objUserXML.selectSingleNode("/userdata/company").getText();
		this.companyName			= this.objUserXML.selectSingleNode("/userdata/companyname").getText();
		this.language				= this.objUserXML.selectSingleNode("/userdata/language").getText();

		this.languageName		= this.objUserXML.selectSingleNode("/userdata/languagename").getText();
		this.localeid			= this.objUserXML.selectSingleNode("/userdata/localeid").getText();
		this.languageDirectory = this.objUserXML.selectSingleNode("/userdata/languagedirectory").getText();
		if (this.objUserXML.selectSingleNode("/userdata/selectedmenuitem"))
			this.selectedMenuItem	= this.objUserXML.selectSingleNode("/userdata/selectedmenuitem").getText();
		this.selectedMenuItemName = this.objUserXML.selectSingleNode("/userdata/selectedmenuitemname").getText();
		this.crystalReportSettings = this.objUserXML.selectSingleNode("/userdata/crystalreportsettings").getText();

		this.homeCurrency			= this.objUserXML.selectSingleNode("/userdata/homecurrency").getText();
		this.homeCurrencyDescription		= this.objUserXML.selectSingleNode("/userdata/homecurrencydescription").getText();
		this.cssGroupID = this.objUserXML.selectSingleNode("/userdata/usercssgroupid").getText();
	}
}

/**
 * Loads and caches the home currency symbol.
 *
 * @return The home currency symbol string.
 */
function User_getHomeCurrencySymbol()
{
	if (this.homeCurrencySymbol == null)
	{
		var objCurrXML = objApplication.Data.getHomeCurrencyXML(window);

		if (objApplication.hadCriticalError == true)
			return;

		this.homeCurrencySymbol = objCurrXML.selectSingleNode("symbol/value").getText();
	}
	
	return this.homeCurrencySymbol;
}


//start base64 encoding
function b64Encode(str) 
{
	str = String(str);
	
	if (isBlank(str))
		return "";

	return getEfacsApplet().b64Encode(str);
}

function b64Decode(str)
{
	if (isBlank(str))
		return "";

	return getEfacsApplet().b64Decode(str);
}

function replaceForURL(base64)
{
	var newString;

	if (base64 == null)
		return;

	newString = base64.replace(/\+/g, "-");
	newString = newString.replace(/\=/g, ".");
	newString = newString.replace(/\//g, "_");

	return newString;
}

function undoReplaceForURL(base64)
{
	var newString;

	if (base64 == null)
		return;

	newString = base64.replace(/\-/g, "+");
	newString = newString.replace(/\./g, "=");
	newString = newString.replace(/\_/g, "/");

	return newString;
}
